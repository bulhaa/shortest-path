/******/ (function(modules) { // webpackBootstrap
exports.__webpack_require__ = __webpack_require__;
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/visibility-graph-master/use/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../node_modules/ngraph.events/index.js":
/*!**********************************************!*\
  !*** ../node_modules/ngraph.events/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(subject) {\n  validateSubject(subject);\n\n  var eventsStorage = createEventsStorage(subject);\n  subject.on = eventsStorage.on;\n  subject.off = eventsStorage.off;\n  subject.fire = eventsStorage.fire;\n  return subject;\n};\n\nfunction createEventsStorage(subject) {\n  // Store all event listeners to this hash. Key is event name, value is array\n  // of callback records.\n  //\n  // A callback record consists of callback function and its optional context:\n  // { 'eventName' => [{callback: function, ctx: object}] }\n  var registeredEvents = Object.create(null);\n\n  return {\n    on: function (eventName, callback, ctx) {\n      if (typeof callback !== 'function') {\n        throw new Error('callback is expected to be a function');\n      }\n      var handlers = registeredEvents[eventName];\n      if (!handlers) {\n        handlers = registeredEvents[eventName] = [];\n      }\n      handlers.push({callback: callback, ctx: ctx});\n\n      return subject;\n    },\n\n    off: function (eventName, callback) {\n      var wantToRemoveAll = (typeof eventName === 'undefined');\n      if (wantToRemoveAll) {\n        // Killing old events storage should be enough in this case:\n        registeredEvents = Object.create(null);\n        return subject;\n      }\n\n      if (registeredEvents[eventName]) {\n        var deleteAllCallbacksForEvent = (typeof callback !== 'function');\n        if (deleteAllCallbacksForEvent) {\n          delete registeredEvents[eventName];\n        } else {\n          var callbacks = registeredEvents[eventName];\n          for (var i = 0; i < callbacks.length; ++i) {\n            if (callbacks[i].callback === callback) {\n              callbacks.splice(i, 1);\n            }\n          }\n        }\n      }\n\n      return subject;\n    },\n\n    fire: function (eventName) {\n      var callbacks = registeredEvents[eventName];\n      if (!callbacks) {\n        return subject;\n      }\n\n      var fireArguments;\n      if (arguments.length > 1) {\n        fireArguments = Array.prototype.splice.call(arguments, 1);\n      }\n      for(var i = 0; i < callbacks.length; ++i) {\n        var callbackInfo = callbacks[i];\n        callbackInfo.callback.apply(callbackInfo.ctx, fireArguments);\n      }\n\n      return subject;\n    }\n  };\n}\n\nfunction validateSubject(subject) {\n  if (!subject) {\n    throw new Error('Eventify cannot use falsy object as events subject');\n  }\n  var reservedWords = ['on', 'fire', 'off'];\n  for (var i = 0; i < reservedWords.length; ++i) {\n    if (subject.hasOwnProperty(reservedWords[i])) {\n      throw new Error(\"Subject cannot be eventified, since it already has property '\" + reservedWords[i] + \"'\");\n    }\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL25ncmFwaC5ldmVudHMvaW5kZXguanM/ZDM5YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxrQkFBa0IsZ0NBQWdDO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw2QkFBNkI7O0FBRWxEO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHlCQUF5QixzQkFBc0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwwQkFBMEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuLi9ub2RlX21vZHVsZXMvbmdyYXBoLmV2ZW50cy9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3ViamVjdCkge1xuICB2YWxpZGF0ZVN1YmplY3Qoc3ViamVjdCk7XG5cbiAgdmFyIGV2ZW50c1N0b3JhZ2UgPSBjcmVhdGVFdmVudHNTdG9yYWdlKHN1YmplY3QpO1xuICBzdWJqZWN0Lm9uID0gZXZlbnRzU3RvcmFnZS5vbjtcbiAgc3ViamVjdC5vZmYgPSBldmVudHNTdG9yYWdlLm9mZjtcbiAgc3ViamVjdC5maXJlID0gZXZlbnRzU3RvcmFnZS5maXJlO1xuICByZXR1cm4gc3ViamVjdDtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50c1N0b3JhZ2Uoc3ViamVjdCkge1xuICAvLyBTdG9yZSBhbGwgZXZlbnQgbGlzdGVuZXJzIHRvIHRoaXMgaGFzaC4gS2V5IGlzIGV2ZW50IG5hbWUsIHZhbHVlIGlzIGFycmF5XG4gIC8vIG9mIGNhbGxiYWNrIHJlY29yZHMuXG4gIC8vXG4gIC8vIEEgY2FsbGJhY2sgcmVjb3JkIGNvbnNpc3RzIG9mIGNhbGxiYWNrIGZ1bmN0aW9uIGFuZCBpdHMgb3B0aW9uYWwgY29udGV4dDpcbiAgLy8geyAnZXZlbnROYW1lJyA9PiBbe2NhbGxiYWNrOiBmdW5jdGlvbiwgY3R4OiBvYmplY3R9XSB9XG4gIHZhciByZWdpc3RlcmVkRXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICByZXR1cm4ge1xuICAgIG9uOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBjYWxsYmFjaywgY3R4KSB7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2FsbGJhY2sgaXMgZXhwZWN0ZWQgdG8gYmUgYSBmdW5jdGlvbicpO1xuICAgICAgfVxuICAgICAgdmFyIGhhbmRsZXJzID0gcmVnaXN0ZXJlZEV2ZW50c1tldmVudE5hbWVdO1xuICAgICAgaWYgKCFoYW5kbGVycykge1xuICAgICAgICBoYW5kbGVycyA9IHJlZ2lzdGVyZWRFdmVudHNbZXZlbnROYW1lXSA9IFtdO1xuICAgICAgfVxuICAgICAgaGFuZGxlcnMucHVzaCh7Y2FsbGJhY2s6IGNhbGxiYWNrLCBjdHg6IGN0eH0pO1xuXG4gICAgICByZXR1cm4gc3ViamVjdDtcbiAgICB9LFxuXG4gICAgb2ZmOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgdmFyIHdhbnRUb1JlbW92ZUFsbCA9ICh0eXBlb2YgZXZlbnROYW1lID09PSAndW5kZWZpbmVkJyk7XG4gICAgICBpZiAod2FudFRvUmVtb3ZlQWxsKSB7XG4gICAgICAgIC8vIEtpbGxpbmcgb2xkIGV2ZW50cyBzdG9yYWdlIHNob3VsZCBiZSBlbm91Z2ggaW4gdGhpcyBjYXNlOlxuICAgICAgICByZWdpc3RlcmVkRXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgcmV0dXJuIHN1YmplY3Q7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWdpc3RlcmVkRXZlbnRzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgdmFyIGRlbGV0ZUFsbENhbGxiYWNrc0ZvckV2ZW50ID0gKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJyk7XG4gICAgICAgIGlmIChkZWxldGVBbGxDYWxsYmFja3NGb3JFdmVudCkge1xuICAgICAgICAgIGRlbGV0ZSByZWdpc3RlcmVkRXZlbnRzW2V2ZW50TmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNhbGxiYWNrcyA9IHJlZ2lzdGVyZWRFdmVudHNbZXZlbnROYW1lXTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrc1tpXS5jYWxsYmFjayA9PT0gY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN1YmplY3Q7XG4gICAgfSxcblxuICAgIGZpcmU6IGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgIHZhciBjYWxsYmFja3MgPSByZWdpc3RlcmVkRXZlbnRzW2V2ZW50TmFtZV07XG4gICAgICBpZiAoIWNhbGxiYWNrcykge1xuICAgICAgICByZXR1cm4gc3ViamVjdDtcbiAgICAgIH1cblxuICAgICAgdmFyIGZpcmVBcmd1bWVudHM7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZmlyZUFyZ3VtZW50cyA9IEFycmF5LnByb3RvdHlwZS5zcGxpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgfVxuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgY2FsbGJhY2tJbmZvID0gY2FsbGJhY2tzW2ldO1xuICAgICAgICBjYWxsYmFja0luZm8uY2FsbGJhY2suYXBwbHkoY2FsbGJhY2tJbmZvLmN0eCwgZmlyZUFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdWJqZWN0O1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVTdWJqZWN0KHN1YmplY3QpIHtcbiAgaWYgKCFzdWJqZWN0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFdmVudGlmeSBjYW5ub3QgdXNlIGZhbHN5IG9iamVjdCBhcyBldmVudHMgc3ViamVjdCcpO1xuICB9XG4gIHZhciByZXNlcnZlZFdvcmRzID0gWydvbicsICdmaXJlJywgJ29mZiddO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc2VydmVkV29yZHMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoc3ViamVjdC5oYXNPd25Qcm9wZXJ0eShyZXNlcnZlZFdvcmRzW2ldKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3ViamVjdCBjYW5ub3QgYmUgZXZlbnRpZmllZCwgc2luY2UgaXQgYWxyZWFkeSBoYXMgcHJvcGVydHkgJ1wiICsgcmVzZXJ2ZWRXb3Jkc1tpXSArIFwiJ1wiKTtcbiAgICB9XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ngraph.events/index.js\n");

/***/ }),

/***/ "../node_modules/ngraph.fromjson/index.js":
/*!************************************************!*\
  !*** ../node_modules/ngraph.fromjson/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = load;\n\nvar createGraph = __webpack_require__(/*! ngraph.graph */ \"../node_modules/ngraph.fromjson/node_modules/ngraph.graph/index.js\");\n\nfunction load(jsonGraph, nodeTransform, linkTransform) {\n  var stored;\n  nodeTransform = nodeTransform || id;\n  linkTransform = linkTransform || id;\n  if (typeof jsonGraph === 'string') {\n    stored = JSON.parse(jsonGraph);\n  } else {\n    stored = jsonGraph;\n  }\n\n  var graph = createGraph(),\n      i;\n\n  if (stored.links === undefined || stored.nodes === undefined) {\n    throw new Error('Cannot load graph without links and nodes');\n  }\n\n  for (i = 0; i < stored.nodes.length; ++i) {\n    var parsedNode = nodeTransform(stored.nodes[i]);\n    if (!parsedNode.hasOwnProperty('id')) {\n      throw new Error('Graph node format is invalid: Node id is missing');\n    }\n\n    graph.addNode(parsedNode.id, parsedNode.data);\n  }\n\n  for (i = 0; i < stored.links.length; ++i) {\n    var link = linkTransform(stored.links[i]);\n    if (!link.hasOwnProperty('fromId') || !link.hasOwnProperty('toId')) {\n      throw new Error('Graph link format is invalid. Both fromId and toId are required');\n    }\n\n    graph.addLink(link.fromId, link.toId, link.data);\n  }\n\n  return graph;\n}\n\nfunction id(x) { return x; }\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL25ncmFwaC5mcm9tanNvbi9pbmRleC5qcz9hZDNkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLGtCQUFrQixtQkFBTyxDQUFDLHdGQUFjOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLHlCQUF5QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxnQkFBZ0IsVUFBVSIsImZpbGUiOiIuLi9ub2RlX21vZHVsZXMvbmdyYXBoLmZyb21qc29uL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBsb2FkO1xuXG52YXIgY3JlYXRlR3JhcGggPSByZXF1aXJlKCduZ3JhcGguZ3JhcGgnKTtcblxuZnVuY3Rpb24gbG9hZChqc29uR3JhcGgsIG5vZGVUcmFuc2Zvcm0sIGxpbmtUcmFuc2Zvcm0pIHtcbiAgdmFyIHN0b3JlZDtcbiAgbm9kZVRyYW5zZm9ybSA9IG5vZGVUcmFuc2Zvcm0gfHwgaWQ7XG4gIGxpbmtUcmFuc2Zvcm0gPSBsaW5rVHJhbnNmb3JtIHx8IGlkO1xuICBpZiAodHlwZW9mIGpzb25HcmFwaCA9PT0gJ3N0cmluZycpIHtcbiAgICBzdG9yZWQgPSBKU09OLnBhcnNlKGpzb25HcmFwaCk7XG4gIH0gZWxzZSB7XG4gICAgc3RvcmVkID0ganNvbkdyYXBoO1xuICB9XG5cbiAgdmFyIGdyYXBoID0gY3JlYXRlR3JhcGgoKSxcbiAgICAgIGk7XG5cbiAgaWYgKHN0b3JlZC5saW5rcyA9PT0gdW5kZWZpbmVkIHx8IHN0b3JlZC5ub2RlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgbG9hZCBncmFwaCB3aXRob3V0IGxpbmtzIGFuZCBub2RlcycpO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IHN0b3JlZC5ub2Rlcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWROb2RlID0gbm9kZVRyYW5zZm9ybShzdG9yZWQubm9kZXNbaV0pO1xuICAgIGlmICghcGFyc2VkTm9kZS5oYXNPd25Qcm9wZXJ0eSgnaWQnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdHcmFwaCBub2RlIGZvcm1hdCBpcyBpbnZhbGlkOiBOb2RlIGlkIGlzIG1pc3NpbmcnKTtcbiAgICB9XG5cbiAgICBncmFwaC5hZGROb2RlKHBhcnNlZE5vZGUuaWQsIHBhcnNlZE5vZGUuZGF0YSk7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgc3RvcmVkLmxpbmtzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGxpbmsgPSBsaW5rVHJhbnNmb3JtKHN0b3JlZC5saW5rc1tpXSk7XG4gICAgaWYgKCFsaW5rLmhhc093blByb3BlcnR5KCdmcm9tSWQnKSB8fCAhbGluay5oYXNPd25Qcm9wZXJ0eSgndG9JZCcpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dyYXBoIGxpbmsgZm9ybWF0IGlzIGludmFsaWQuIEJvdGggZnJvbUlkIGFuZCB0b0lkIGFyZSByZXF1aXJlZCcpO1xuICAgIH1cblxuICAgIGdyYXBoLmFkZExpbmsobGluay5mcm9tSWQsIGxpbmsudG9JZCwgbGluay5kYXRhKTtcbiAgfVxuXG4gIHJldHVybiBncmFwaDtcbn1cblxuZnVuY3Rpb24gaWQoeCkgeyByZXR1cm4geDsgfVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ngraph.fromjson/index.js\n");

/***/ }),

/***/ "../node_modules/ngraph.fromjson/node_modules/ngraph.graph/index.js":
/*!**************************************************************************!*\
  !*** ../node_modules/ngraph.fromjson/node_modules/ngraph.graph/index.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @fileOverview Contains definition of the core graph object.\n */\n\n// TODO: need to change storage layer:\n// 1. Be able to get all nodes O(1)\n// 2. Be able to get number of links O(1)\n\n/**\n * @example\n *  var graph = require('ngraph.graph')();\n *  graph.addNode(1);     // graph has one node.\n *  graph.addLink(2, 3);  // now graph contains three nodes and one link.\n *\n */\nmodule.exports = createGraph;\n\nvar eventify = __webpack_require__(/*! ngraph.events */ \"../node_modules/ngraph.events/index.js\");\n\n/**\n * Creates a new graph\n */\nfunction createGraph(options) {\n  // Graph structure is maintained as dictionary of nodes\n  // and array of links. Each node has 'links' property which\n  // hold all links related to that node. And general links\n  // array is used to speed up all links enumeration. This is inefficient\n  // in terms of memory, but simplifies coding.\n  options = options || {};\n  if ('uniqueLinkId' in options) {\n    console.warn(\n      'ngraph.graph: Starting from version 0.14 `uniqueLinkId` is deprecated.\\n' +\n      'Use `multigraph` option instead\\n',\n      '\\n',\n      'Note: there is also change in default behavior: From now own each graph\\n'+\n      'is considered to be not a multigraph by default (each edge is unique).'\n    );\n\n    options.multigraph = options.uniqueLinkId;\n  }\n\n  // Dear reader, the non-multigraphs do not guarantee that there is only\n  // one link for a given pair of node. When this option is set to false\n  // we can save some memory and CPU (18% faster for non-multigraph);\n  if (options.multigraph === undefined) options.multigraph = false;\n\n  var nodes = typeof Object.create === 'function' ? Object.create(null) : {},\n    links = [],\n    // Hash of multi-edges. Used to track ids of edges between same nodes\n    multiEdges = {},\n    nodesCount = 0,\n    suspendEvents = 0,\n\n    forEachNode = createNodeIterator(),\n    createLink = options.multigraph ? createUniqueLink : createSingleLink,\n\n    // Our graph API provides means to listen to graph changes. Users can subscribe\n    // to be notified about changes in the graph by using `on` method. However\n    // in some cases they don't use it. To avoid unnecessary memory consumption\n    // we will not record graph changes until we have at least one subscriber.\n    // Code below supports this optimization.\n    //\n    // Accumulates all changes made during graph updates.\n    // Each change element contains:\n    //  changeType - one of the strings: 'add', 'remove' or 'update';\n    //  node - if change is related to node this property is set to changed graph's node;\n    //  link - if change is related to link this property is set to changed graph's link;\n    changes = [],\n    recordLinkChange = noop,\n    recordNodeChange = noop,\n    enterModification = noop,\n    exitModification = noop;\n\n  // this is our public API:\n  var graphPart = {\n    /**\n     * Adds node to the graph. If node with given id already exists in the graph\n     * its data is extended with whatever comes in 'data' argument.\n     *\n     * @param nodeId the node's identifier. A string or number is preferred.\n     * @param [data] additional data for the node being added. If node already\n     *   exists its data object is augmented with the new one.\n     *\n     * @return {node} The newly added node or node with given id if it already exists.\n     */\n    addNode: addNode,\n\n    /**\n     * Adds a link to the graph. The function always create a new\n     * link between two nodes. If one of the nodes does not exists\n     * a new node is created.\n     *\n     * @param fromId link start node id;\n     * @param toId link end node id;\n     * @param [data] additional data to be set on the new link;\n     *\n     * @return {link} The newly created link\n     */\n    addLink: addLink,\n\n    /**\n     * Removes link from the graph. If link does not exist does nothing.\n     *\n     * @param link - object returned by addLink() or getLinks() methods.\n     *\n     * @returns true if link was removed; false otherwise.\n     */\n    removeLink: removeLink,\n\n    /**\n     * Removes node with given id from the graph. If node does not exist in the graph\n     * does nothing.\n     *\n     * @param nodeId node's identifier passed to addNode() function.\n     *\n     * @returns true if node was removed; false otherwise.\n     */\n    removeNode: removeNode,\n\n    /**\n     * Gets node with given identifier. If node does not exist undefined value is returned.\n     *\n     * @param nodeId requested node identifier;\n     *\n     * @return {node} in with requested identifier or undefined if no such node exists.\n     */\n    getNode: getNode,\n\n    /**\n     * Gets number of nodes in this graph.\n     *\n     * @return number of nodes in the graph.\n     */\n    getNodesCount: function () {\n      return nodesCount;\n    },\n\n    /**\n     * Gets total number of links in the graph.\n     */\n    getLinksCount: function () {\n      return links.length;\n    },\n\n    /**\n     * Gets all links (inbound and outbound) from the node with given id.\n     * If node with given id is not found null is returned.\n     *\n     * @param nodeId requested node identifier.\n     *\n     * @return Array of links from and to requested node if such node exists;\n     *   otherwise null is returned.\n     */\n    getLinks: getLinks,\n\n    /**\n     * Invokes callback on each node of the graph.\n     *\n     * @param {Function(node)} callback Function to be invoked. The function\n     *   is passed one argument: visited node.\n     */\n    forEachNode: forEachNode,\n\n    /**\n     * Invokes callback on every linked (adjacent) node to the given one.\n     *\n     * @param nodeId Identifier of the requested node.\n     * @param {Function(node, link)} callback Function to be called on all linked nodes.\n     *   The function is passed two parameters: adjacent node and link object itself.\n     * @param oriented if true graph treated as oriented.\n     */\n    forEachLinkedNode: forEachLinkedNode,\n\n    /**\n     * Enumerates all links in the graph\n     *\n     * @param {Function(link)} callback Function to be called on all links in the graph.\n     *   The function is passed one parameter: graph's link object.\n     *\n     * Link object contains at least the following fields:\n     *  fromId - node id where link starts;\n     *  toId - node id where link ends,\n     *  data - additional data passed to graph.addLink() method.\n     */\n    forEachLink: forEachLink,\n\n    /**\n     * Suspend all notifications about graph changes until\n     * endUpdate is called.\n     */\n    beginUpdate: enterModification,\n\n    /**\n     * Resumes all notifications about graph changes and fires\n     * graph 'changed' event in case there are any pending changes.\n     */\n    endUpdate: exitModification,\n\n    /**\n     * Removes all nodes and links from the graph.\n     */\n    clear: clear,\n\n    /**\n     * Detects whether there is a link between two nodes.\n     * Operation complexity is O(n) where n - number of links of a node.\n     * NOTE: this function is synonim for getLink()\n     *\n     * @returns link if there is one. null otherwise.\n     */\n    hasLink: getLink,\n\n    /**\n     * Detects whether there is a node with given id\n     * \n     * Operation complexity is O(1)\n     * NOTE: this function is synonim for getNode()\n     *\n     * @returns node if there is one; Falsy value otherwise.\n     */\n    hasNode: getNode,\n\n    /**\n     * Gets an edge between two nodes.\n     * Operation complexity is O(n) where n - number of links of a node.\n     *\n     * @param {string} fromId link start identifier\n     * @param {string} toId link end identifier\n     *\n     * @returns link if there is one. null otherwise.\n     */\n    getLink: getLink\n  };\n\n  // this will add `on()` and `fire()` methods.\n  eventify(graphPart);\n\n  monitorSubscribers();\n\n  return graphPart;\n\n  function monitorSubscribers() {\n    var realOn = graphPart.on;\n\n    // replace real `on` with our temporary on, which will trigger change\n    // modification monitoring:\n    graphPart.on = on;\n\n    function on() {\n      // now it's time to start tracking stuff:\n      graphPart.beginUpdate = enterModification = enterModificationReal;\n      graphPart.endUpdate = exitModification = exitModificationReal;\n      recordLinkChange = recordLinkChangeReal;\n      recordNodeChange = recordNodeChangeReal;\n\n      // this will replace current `on` method with real pub/sub from `eventify`.\n      graphPart.on = realOn;\n      // delegate to real `on` handler:\n      return realOn.apply(graphPart, arguments);\n    }\n  }\n\n  function recordLinkChangeReal(link, changeType) {\n    changes.push({\n      link: link,\n      changeType: changeType\n    });\n  }\n\n  function recordNodeChangeReal(node, changeType) {\n    changes.push({\n      node: node,\n      changeType: changeType\n    });\n  }\n\n  function addNode(nodeId, data) {\n    if (nodeId === undefined) {\n      throw new Error('Invalid node identifier');\n    }\n\n    enterModification();\n\n    var node = getNode(nodeId);\n    if (!node) {\n      node = new Node(nodeId, data);\n      nodesCount++;\n      recordNodeChange(node, 'add');\n    } else {\n      node.data = data;\n      recordNodeChange(node, 'update');\n    }\n\n    nodes[nodeId] = node;\n\n    exitModification();\n    return node;\n  }\n\n  function getNode(nodeId) {\n    return nodes[nodeId];\n  }\n\n  function removeNode(nodeId) {\n    var node = getNode(nodeId);\n    if (!node) {\n      return false;\n    }\n\n    enterModification();\n\n    var prevLinks = node.links;\n    if (prevLinks) {\n      node.links = null;\n      for(var i = 0; i < prevLinks.length; ++i) {\n        removeLink(prevLinks[i]);\n      }\n    }\n\n    delete nodes[nodeId];\n    nodesCount--;\n\n    recordNodeChange(node, 'remove');\n\n    exitModification();\n\n    return true;\n  }\n\n\n  function addLink(fromId, toId, data) {\n    enterModification();\n\n    var fromNode = getNode(fromId) || addNode(fromId);\n    var toNode = getNode(toId) || addNode(toId);\n\n    var link = createLink(fromId, toId, data);\n\n    links.push(link);\n\n    // TODO: this is not cool. On large graphs potentially would consume more memory.\n    addLinkToNode(fromNode, link);\n    if (fromId !== toId) {\n      // make sure we are not duplicating links for self-loops\n      addLinkToNode(toNode, link);\n    }\n\n    recordLinkChange(link, 'add');\n\n    exitModification();\n\n    return link;\n  }\n\n  function createSingleLink(fromId, toId, data) {\n    var linkId = makeLinkId(fromId, toId);\n    return new Link(fromId, toId, data, linkId);\n  }\n\n  function createUniqueLink(fromId, toId, data) {\n    // TODO: Get rid of this method.\n    var linkId = makeLinkId(fromId, toId);\n    var isMultiEdge = multiEdges.hasOwnProperty(linkId);\n    if (isMultiEdge || getLink(fromId, toId)) {\n      if (!isMultiEdge) {\n        multiEdges[linkId] = 0;\n      }\n      var suffix = '@' + (++multiEdges[linkId]);\n      linkId = makeLinkId(fromId + suffix, toId + suffix);\n    }\n\n    return new Link(fromId, toId, data, linkId);\n  }\n\n  function getLinks(nodeId) {\n    var node = getNode(nodeId);\n    return node ? node.links : null;\n  }\n\n  function removeLink(link) {\n    if (!link) {\n      return false;\n    }\n    var idx = indexOfElementInArray(link, links);\n    if (idx < 0) {\n      return false;\n    }\n\n    enterModification();\n\n    links.splice(idx, 1);\n\n    var fromNode = getNode(link.fromId);\n    var toNode = getNode(link.toId);\n\n    if (fromNode) {\n      idx = indexOfElementInArray(link, fromNode.links);\n      if (idx >= 0) {\n        fromNode.links.splice(idx, 1);\n      }\n    }\n\n    if (toNode) {\n      idx = indexOfElementInArray(link, toNode.links);\n      if (idx >= 0) {\n        toNode.links.splice(idx, 1);\n      }\n    }\n\n    recordLinkChange(link, 'remove');\n\n    exitModification();\n\n    return true;\n  }\n\n  function getLink(fromNodeId, toNodeId) {\n    // TODO: Use sorted links to speed this up\n    var node = getNode(fromNodeId),\n      i;\n    if (!node || !node.links) {\n      return null;\n    }\n\n    for (i = 0; i < node.links.length; ++i) {\n      var link = node.links[i];\n      if (link.fromId === fromNodeId && link.toId === toNodeId) {\n        return link;\n      }\n    }\n\n    return null; // no link.\n  }\n\n  function clear() {\n    enterModification();\n    forEachNode(function(node) {\n      removeNode(node.id);\n    });\n    exitModification();\n  }\n\n  function forEachLink(callback) {\n    var i, length;\n    if (typeof callback === 'function') {\n      for (i = 0, length = links.length; i < length; ++i) {\n        callback(links[i]);\n      }\n    }\n  }\n\n  function forEachLinkedNode(nodeId, callback, oriented) {\n    var node = getNode(nodeId);\n\n    if (node && node.links && typeof callback === 'function') {\n      if (oriented) {\n        return forEachOrientedLink(node.links, nodeId, callback);\n      } else {\n        return forEachNonOrientedLink(node.links, nodeId, callback);\n      }\n    }\n  }\n\n  function forEachNonOrientedLink(links, nodeId, callback) {\n    var quitFast;\n    for (var i = 0; i < links.length; ++i) {\n      var link = links[i];\n      var linkedNodeId = link.fromId === nodeId ? link.toId : link.fromId;\n\n      quitFast = callback(nodes[linkedNodeId], link);\n      if (quitFast) {\n        return true; // Client does not need more iterations. Break now.\n      }\n    }\n  }\n\n  function forEachOrientedLink(links, nodeId, callback) {\n    var quitFast;\n    for (var i = 0; i < links.length; ++i) {\n      var link = links[i];\n      if (link.fromId === nodeId) {\n        quitFast = callback(nodes[link.toId], link);\n        if (quitFast) {\n          return true; // Client does not need more iterations. Break now.\n        }\n      }\n    }\n  }\n\n  // we will not fire anything until users of this library explicitly call `on()`\n  // method.\n  function noop() {}\n\n  // Enter, Exit modification allows bulk graph updates without firing events.\n  function enterModificationReal() {\n    suspendEvents += 1;\n  }\n\n  function exitModificationReal() {\n    suspendEvents -= 1;\n    if (suspendEvents === 0 && changes.length > 0) {\n      graphPart.fire('changed', changes);\n      changes.length = 0;\n    }\n  }\n\n  function createNodeIterator() {\n    // Object.keys iterator is 1.3x faster than `for in` loop.\n    // See `https://github.com/anvaka/ngraph.graph/tree/bench-for-in-vs-obj-keys`\n    // branch for perf test\n    return Object.keys ? objectKeysIterator : forInIterator;\n  }\n\n  function objectKeysIterator(callback) {\n    if (typeof callback !== 'function') {\n      return;\n    }\n\n    var keys = Object.keys(nodes);\n    for (var i = 0; i < keys.length; ++i) {\n      if (callback(nodes[keys[i]])) {\n        return true; // client doesn't want to proceed. Return.\n      }\n    }\n  }\n\n  function forInIterator(callback) {\n    if (typeof callback !== 'function') {\n      return;\n    }\n    var node;\n\n    for (node in nodes) {\n      if (callback(nodes[node])) {\n        return true; // client doesn't want to proceed. Return.\n      }\n    }\n  }\n}\n\n// need this for old browsers. Should this be a separate module?\nfunction indexOfElementInArray(element, array) {\n  if (!array) return -1;\n\n  if (array.indexOf) {\n    return array.indexOf(element);\n  }\n\n  var len = array.length,\n    i;\n\n  for (i = 0; i < len; i += 1) {\n    if (array[i] === element) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\n/**\n * Internal structure to represent node;\n */\nfunction Node(id, data) {\n  this.id = id;\n  this.links = null;\n  this.data = data;\n}\n\nfunction addLinkToNode(node, link) {\n  if (node.links) {\n    node.links.push(link);\n  } else {\n    node.links = [link];\n  }\n}\n\n/**\n * Internal structure to represent links;\n */\nfunction Link(fromId, toId, data, id) {\n  this.fromId = fromId;\n  this.toId = toId;\n  this.data = data;\n  this.id = id;\n}\n\nfunction hashCode(str) {\n  var hash = 0, i, chr, len;\n  if (str.length == 0) return hash;\n  for (i = 0, len = str.length; i < len; i++) {\n    chr   = str.charCodeAt(i);\n    hash  = ((hash << 5) - hash) + chr;\n    hash |= 0; // Convert to 32bit integer\n  }\n  return hash;\n}\n\nfunction makeLinkId(fromId, toId) {\n  return fromId.toString() + '👉 ' + toId.toString();\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL25ncmFwaC5mcm9tanNvbi9ub2RlX21vZHVsZXMvbmdyYXBoLmdyYXBoL2luZGV4LmpzPzVmNDciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLG1CQUFPLENBQUMsNkRBQWU7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFlBQVk7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiIuLi9ub2RlX21vZHVsZXMvbmdyYXBoLmZyb21qc29uL25vZGVfbW9kdWxlcy9uZ3JhcGguZ3JhcGgvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlT3ZlcnZpZXcgQ29udGFpbnMgZGVmaW5pdGlvbiBvZiB0aGUgY29yZSBncmFwaCBvYmplY3QuXG4gKi9cblxuLy8gVE9ETzogbmVlZCB0byBjaGFuZ2Ugc3RvcmFnZSBsYXllcjpcbi8vIDEuIEJlIGFibGUgdG8gZ2V0IGFsbCBub2RlcyBPKDEpXG4vLyAyLiBCZSBhYmxlIHRvIGdldCBudW1iZXIgb2YgbGlua3MgTygxKVxuXG4vKipcbiAqIEBleGFtcGxlXG4gKiAgdmFyIGdyYXBoID0gcmVxdWlyZSgnbmdyYXBoLmdyYXBoJykoKTtcbiAqICBncmFwaC5hZGROb2RlKDEpOyAgICAgLy8gZ3JhcGggaGFzIG9uZSBub2RlLlxuICogIGdyYXBoLmFkZExpbmsoMiwgMyk7ICAvLyBub3cgZ3JhcGggY29udGFpbnMgdGhyZWUgbm9kZXMgYW5kIG9uZSBsaW5rLlxuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVHcmFwaDtcblxudmFyIGV2ZW50aWZ5ID0gcmVxdWlyZSgnbmdyYXBoLmV2ZW50cycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZ3JhcGhcbiAqL1xuZnVuY3Rpb24gY3JlYXRlR3JhcGgob3B0aW9ucykge1xuICAvLyBHcmFwaCBzdHJ1Y3R1cmUgaXMgbWFpbnRhaW5lZCBhcyBkaWN0aW9uYXJ5IG9mIG5vZGVzXG4gIC8vIGFuZCBhcnJheSBvZiBsaW5rcy4gRWFjaCBub2RlIGhhcyAnbGlua3MnIHByb3BlcnR5IHdoaWNoXG4gIC8vIGhvbGQgYWxsIGxpbmtzIHJlbGF0ZWQgdG8gdGhhdCBub2RlLiBBbmQgZ2VuZXJhbCBsaW5rc1xuICAvLyBhcnJheSBpcyB1c2VkIHRvIHNwZWVkIHVwIGFsbCBsaW5rcyBlbnVtZXJhdGlvbi4gVGhpcyBpcyBpbmVmZmljaWVudFxuICAvLyBpbiB0ZXJtcyBvZiBtZW1vcnksIGJ1dCBzaW1wbGlmaWVzIGNvZGluZy5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmICgndW5pcXVlTGlua0lkJyBpbiBvcHRpb25zKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgJ25ncmFwaC5ncmFwaDogU3RhcnRpbmcgZnJvbSB2ZXJzaW9uIDAuMTQgYHVuaXF1ZUxpbmtJZGAgaXMgZGVwcmVjYXRlZC5cXG4nICtcbiAgICAgICdVc2UgYG11bHRpZ3JhcGhgIG9wdGlvbiBpbnN0ZWFkXFxuJyxcbiAgICAgICdcXG4nLFxuICAgICAgJ05vdGU6IHRoZXJlIGlzIGFsc28gY2hhbmdlIGluIGRlZmF1bHQgYmVoYXZpb3I6IEZyb20gbm93IG93biBlYWNoIGdyYXBoXFxuJytcbiAgICAgICdpcyBjb25zaWRlcmVkIHRvIGJlIG5vdCBhIG11bHRpZ3JhcGggYnkgZGVmYXVsdCAoZWFjaCBlZGdlIGlzIHVuaXF1ZSkuJ1xuICAgICk7XG5cbiAgICBvcHRpb25zLm11bHRpZ3JhcGggPSBvcHRpb25zLnVuaXF1ZUxpbmtJZDtcbiAgfVxuXG4gIC8vIERlYXIgcmVhZGVyLCB0aGUgbm9uLW11bHRpZ3JhcGhzIGRvIG5vdCBndWFyYW50ZWUgdGhhdCB0aGVyZSBpcyBvbmx5XG4gIC8vIG9uZSBsaW5rIGZvciBhIGdpdmVuIHBhaXIgb2Ygbm9kZS4gV2hlbiB0aGlzIG9wdGlvbiBpcyBzZXQgdG8gZmFsc2VcbiAgLy8gd2UgY2FuIHNhdmUgc29tZSBtZW1vcnkgYW5kIENQVSAoMTglIGZhc3RlciBmb3Igbm9uLW11bHRpZ3JhcGgpO1xuICBpZiAob3B0aW9ucy5tdWx0aWdyYXBoID09PSB1bmRlZmluZWQpIG9wdGlvbnMubXVsdGlncmFwaCA9IGZhbHNlO1xuXG4gIHZhciBub2RlcyA9IHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IHt9LFxuICAgIGxpbmtzID0gW10sXG4gICAgLy8gSGFzaCBvZiBtdWx0aS1lZGdlcy4gVXNlZCB0byB0cmFjayBpZHMgb2YgZWRnZXMgYmV0d2VlbiBzYW1lIG5vZGVzXG4gICAgbXVsdGlFZGdlcyA9IHt9LFxuICAgIG5vZGVzQ291bnQgPSAwLFxuICAgIHN1c3BlbmRFdmVudHMgPSAwLFxuXG4gICAgZm9yRWFjaE5vZGUgPSBjcmVhdGVOb2RlSXRlcmF0b3IoKSxcbiAgICBjcmVhdGVMaW5rID0gb3B0aW9ucy5tdWx0aWdyYXBoID8gY3JlYXRlVW5pcXVlTGluayA6IGNyZWF0ZVNpbmdsZUxpbmssXG5cbiAgICAvLyBPdXIgZ3JhcGggQVBJIHByb3ZpZGVzIG1lYW5zIHRvIGxpc3RlbiB0byBncmFwaCBjaGFuZ2VzLiBVc2VycyBjYW4gc3Vic2NyaWJlXG4gICAgLy8gdG8gYmUgbm90aWZpZWQgYWJvdXQgY2hhbmdlcyBpbiB0aGUgZ3JhcGggYnkgdXNpbmcgYG9uYCBtZXRob2QuIEhvd2V2ZXJcbiAgICAvLyBpbiBzb21lIGNhc2VzIHRoZXkgZG9uJ3QgdXNlIGl0LiBUbyBhdm9pZCB1bm5lY2Vzc2FyeSBtZW1vcnkgY29uc3VtcHRpb25cbiAgICAvLyB3ZSB3aWxsIG5vdCByZWNvcmQgZ3JhcGggY2hhbmdlcyB1bnRpbCB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBzdWJzY3JpYmVyLlxuICAgIC8vIENvZGUgYmVsb3cgc3VwcG9ydHMgdGhpcyBvcHRpbWl6YXRpb24uXG4gICAgLy9cbiAgICAvLyBBY2N1bXVsYXRlcyBhbGwgY2hhbmdlcyBtYWRlIGR1cmluZyBncmFwaCB1cGRhdGVzLlxuICAgIC8vIEVhY2ggY2hhbmdlIGVsZW1lbnQgY29udGFpbnM6XG4gICAgLy8gIGNoYW5nZVR5cGUgLSBvbmUgb2YgdGhlIHN0cmluZ3M6ICdhZGQnLCAncmVtb3ZlJyBvciAndXBkYXRlJztcbiAgICAvLyAgbm9kZSAtIGlmIGNoYW5nZSBpcyByZWxhdGVkIHRvIG5vZGUgdGhpcyBwcm9wZXJ0eSBpcyBzZXQgdG8gY2hhbmdlZCBncmFwaCdzIG5vZGU7XG4gICAgLy8gIGxpbmsgLSBpZiBjaGFuZ2UgaXMgcmVsYXRlZCB0byBsaW5rIHRoaXMgcHJvcGVydHkgaXMgc2V0IHRvIGNoYW5nZWQgZ3JhcGgncyBsaW5rO1xuICAgIGNoYW5nZXMgPSBbXSxcbiAgICByZWNvcmRMaW5rQ2hhbmdlID0gbm9vcCxcbiAgICByZWNvcmROb2RlQ2hhbmdlID0gbm9vcCxcbiAgICBlbnRlck1vZGlmaWNhdGlvbiA9IG5vb3AsXG4gICAgZXhpdE1vZGlmaWNhdGlvbiA9IG5vb3A7XG5cbiAgLy8gdGhpcyBpcyBvdXIgcHVibGljIEFQSTpcbiAgdmFyIGdyYXBoUGFydCA9IHtcbiAgICAvKipcbiAgICAgKiBBZGRzIG5vZGUgdG8gdGhlIGdyYXBoLiBJZiBub2RlIHdpdGggZ2l2ZW4gaWQgYWxyZWFkeSBleGlzdHMgaW4gdGhlIGdyYXBoXG4gICAgICogaXRzIGRhdGEgaXMgZXh0ZW5kZWQgd2l0aCB3aGF0ZXZlciBjb21lcyBpbiAnZGF0YScgYXJndW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbm9kZUlkIHRoZSBub2RlJ3MgaWRlbnRpZmllci4gQSBzdHJpbmcgb3IgbnVtYmVyIGlzIHByZWZlcnJlZC5cbiAgICAgKiBAcGFyYW0gW2RhdGFdIGFkZGl0aW9uYWwgZGF0YSBmb3IgdGhlIG5vZGUgYmVpbmcgYWRkZWQuIElmIG5vZGUgYWxyZWFkeVxuICAgICAqICAgZXhpc3RzIGl0cyBkYXRhIG9iamVjdCBpcyBhdWdtZW50ZWQgd2l0aCB0aGUgbmV3IG9uZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge25vZGV9IFRoZSBuZXdseSBhZGRlZCBub2RlIG9yIG5vZGUgd2l0aCBnaXZlbiBpZCBpZiBpdCBhbHJlYWR5IGV4aXN0cy5cbiAgICAgKi9cbiAgICBhZGROb2RlOiBhZGROb2RlLFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGxpbmsgdG8gdGhlIGdyYXBoLiBUaGUgZnVuY3Rpb24gYWx3YXlzIGNyZWF0ZSBhIG5ld1xuICAgICAqIGxpbmsgYmV0d2VlbiB0d28gbm9kZXMuIElmIG9uZSBvZiB0aGUgbm9kZXMgZG9lcyBub3QgZXhpc3RzXG4gICAgICogYSBuZXcgbm9kZSBpcyBjcmVhdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZyb21JZCBsaW5rIHN0YXJ0IG5vZGUgaWQ7XG4gICAgICogQHBhcmFtIHRvSWQgbGluayBlbmQgbm9kZSBpZDtcbiAgICAgKiBAcGFyYW0gW2RhdGFdIGFkZGl0aW9uYWwgZGF0YSB0byBiZSBzZXQgb24gdGhlIG5ldyBsaW5rO1xuICAgICAqXG4gICAgICogQHJldHVybiB7bGlua30gVGhlIG5ld2x5IGNyZWF0ZWQgbGlua1xuICAgICAqL1xuICAgIGFkZExpbms6IGFkZExpbmssXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGxpbmsgZnJvbSB0aGUgZ3JhcGguIElmIGxpbmsgZG9lcyBub3QgZXhpc3QgZG9lcyBub3RoaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxpbmsgLSBvYmplY3QgcmV0dXJuZWQgYnkgYWRkTGluaygpIG9yIGdldExpbmtzKCkgbWV0aG9kcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgbGluayB3YXMgcmVtb3ZlZDsgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHJlbW92ZUxpbms6IHJlbW92ZUxpbmssXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIG5vZGUgd2l0aCBnaXZlbiBpZCBmcm9tIHRoZSBncmFwaC4gSWYgbm9kZSBkb2VzIG5vdCBleGlzdCBpbiB0aGUgZ3JhcGhcbiAgICAgKiBkb2VzIG5vdGhpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbm9kZUlkIG5vZGUncyBpZGVudGlmaWVyIHBhc3NlZCB0byBhZGROb2RlKCkgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIG5vZGUgd2FzIHJlbW92ZWQ7IGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICByZW1vdmVOb2RlOiByZW1vdmVOb2RlLFxuXG4gICAgLyoqXG4gICAgICogR2V0cyBub2RlIHdpdGggZ2l2ZW4gaWRlbnRpZmllci4gSWYgbm9kZSBkb2VzIG5vdCBleGlzdCB1bmRlZmluZWQgdmFsdWUgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbm9kZUlkIHJlcXVlc3RlZCBub2RlIGlkZW50aWZpZXI7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtub2RlfSBpbiB3aXRoIHJlcXVlc3RlZCBpZGVudGlmaWVyIG9yIHVuZGVmaW5lZCBpZiBubyBzdWNoIG5vZGUgZXhpc3RzLlxuICAgICAqL1xuICAgIGdldE5vZGU6IGdldE5vZGUsXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIG51bWJlciBvZiBub2RlcyBpbiB0aGlzIGdyYXBoLlxuICAgICAqXG4gICAgICogQHJldHVybiBudW1iZXIgb2Ygbm9kZXMgaW4gdGhlIGdyYXBoLlxuICAgICAqL1xuICAgIGdldE5vZGVzQ291bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBub2Rlc0NvdW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRvdGFsIG51bWJlciBvZiBsaW5rcyBpbiB0aGUgZ3JhcGguXG4gICAgICovXG4gICAgZ2V0TGlua3NDb3VudDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGxpbmtzLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgbGlua3MgKGluYm91bmQgYW5kIG91dGJvdW5kKSBmcm9tIHRoZSBub2RlIHdpdGggZ2l2ZW4gaWQuXG4gICAgICogSWYgbm9kZSB3aXRoIGdpdmVuIGlkIGlzIG5vdCBmb3VuZCBudWxsIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5vZGVJZCByZXF1ZXN0ZWQgbm9kZSBpZGVudGlmaWVyLlxuICAgICAqXG4gICAgICogQHJldHVybiBBcnJheSBvZiBsaW5rcyBmcm9tIGFuZCB0byByZXF1ZXN0ZWQgbm9kZSBpZiBzdWNoIG5vZGUgZXhpc3RzO1xuICAgICAqICAgb3RoZXJ3aXNlIG51bGwgaXMgcmV0dXJuZWQuXG4gICAgICovXG4gICAgZ2V0TGlua3M6IGdldExpbmtzLFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyBjYWxsYmFjayBvbiBlYWNoIG5vZGUgb2YgdGhlIGdyYXBoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbihub2RlKX0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gYmUgaW52b2tlZC4gVGhlIGZ1bmN0aW9uXG4gICAgICogICBpcyBwYXNzZWQgb25lIGFyZ3VtZW50OiB2aXNpdGVkIG5vZGUuXG4gICAgICovXG4gICAgZm9yRWFjaE5vZGU6IGZvckVhY2hOb2RlLFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyBjYWxsYmFjayBvbiBldmVyeSBsaW5rZWQgKGFkamFjZW50KSBub2RlIHRvIHRoZSBnaXZlbiBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbm9kZUlkIElkZW50aWZpZXIgb2YgdGhlIHJlcXVlc3RlZCBub2RlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb24obm9kZSwgbGluayl9IGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBhbGwgbGlua2VkIG5vZGVzLlxuICAgICAqICAgVGhlIGZ1bmN0aW9uIGlzIHBhc3NlZCB0d28gcGFyYW1ldGVyczogYWRqYWNlbnQgbm9kZSBhbmQgbGluayBvYmplY3QgaXRzZWxmLlxuICAgICAqIEBwYXJhbSBvcmllbnRlZCBpZiB0cnVlIGdyYXBoIHRyZWF0ZWQgYXMgb3JpZW50ZWQuXG4gICAgICovXG4gICAgZm9yRWFjaExpbmtlZE5vZGU6IGZvckVhY2hMaW5rZWROb2RlLFxuXG4gICAgLyoqXG4gICAgICogRW51bWVyYXRlcyBhbGwgbGlua3MgaW4gdGhlIGdyYXBoXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uKGxpbmspfSBjYWxsYmFjayBGdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gYWxsIGxpbmtzIGluIHRoZSBncmFwaC5cbiAgICAgKiAgIFRoZSBmdW5jdGlvbiBpcyBwYXNzZWQgb25lIHBhcmFtZXRlcjogZ3JhcGgncyBsaW5rIG9iamVjdC5cbiAgICAgKlxuICAgICAqIExpbmsgb2JqZWN0IGNvbnRhaW5zIGF0IGxlYXN0IHRoZSBmb2xsb3dpbmcgZmllbGRzOlxuICAgICAqICBmcm9tSWQgLSBub2RlIGlkIHdoZXJlIGxpbmsgc3RhcnRzO1xuICAgICAqICB0b0lkIC0gbm9kZSBpZCB3aGVyZSBsaW5rIGVuZHMsXG4gICAgICogIGRhdGEgLSBhZGRpdGlvbmFsIGRhdGEgcGFzc2VkIHRvIGdyYXBoLmFkZExpbmsoKSBtZXRob2QuXG4gICAgICovXG4gICAgZm9yRWFjaExpbms6IGZvckVhY2hMaW5rLFxuXG4gICAgLyoqXG4gICAgICogU3VzcGVuZCBhbGwgbm90aWZpY2F0aW9ucyBhYm91dCBncmFwaCBjaGFuZ2VzIHVudGlsXG4gICAgICogZW5kVXBkYXRlIGlzIGNhbGxlZC5cbiAgICAgKi9cbiAgICBiZWdpblVwZGF0ZTogZW50ZXJNb2RpZmljYXRpb24sXG5cbiAgICAvKipcbiAgICAgKiBSZXN1bWVzIGFsbCBub3RpZmljYXRpb25zIGFib3V0IGdyYXBoIGNoYW5nZXMgYW5kIGZpcmVzXG4gICAgICogZ3JhcGggJ2NoYW5nZWQnIGV2ZW50IGluIGNhc2UgdGhlcmUgYXJlIGFueSBwZW5kaW5nIGNoYW5nZXMuXG4gICAgICovXG4gICAgZW5kVXBkYXRlOiBleGl0TW9kaWZpY2F0aW9uLFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgbm9kZXMgYW5kIGxpbmtzIGZyb20gdGhlIGdyYXBoLlxuICAgICAqL1xuICAgIGNsZWFyOiBjbGVhcixcblxuICAgIC8qKlxuICAgICAqIERldGVjdHMgd2hldGhlciB0aGVyZSBpcyBhIGxpbmsgYmV0d2VlbiB0d28gbm9kZXMuXG4gICAgICogT3BlcmF0aW9uIGNvbXBsZXhpdHkgaXMgTyhuKSB3aGVyZSBuIC0gbnVtYmVyIG9mIGxpbmtzIG9mIGEgbm9kZS5cbiAgICAgKiBOT1RFOiB0aGlzIGZ1bmN0aW9uIGlzIHN5bm9uaW0gZm9yIGdldExpbmsoKVxuICAgICAqXG4gICAgICogQHJldHVybnMgbGluayBpZiB0aGVyZSBpcyBvbmUuIG51bGwgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGhhc0xpbms6IGdldExpbmssXG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3RzIHdoZXRoZXIgdGhlcmUgaXMgYSBub2RlIHdpdGggZ2l2ZW4gaWRcbiAgICAgKiBcbiAgICAgKiBPcGVyYXRpb24gY29tcGxleGl0eSBpcyBPKDEpXG4gICAgICogTk9URTogdGhpcyBmdW5jdGlvbiBpcyBzeW5vbmltIGZvciBnZXROb2RlKClcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIG5vZGUgaWYgdGhlcmUgaXMgb25lOyBGYWxzeSB2YWx1ZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaGFzTm9kZTogZ2V0Tm9kZSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgYW4gZWRnZSBiZXR3ZWVuIHR3byBub2Rlcy5cbiAgICAgKiBPcGVyYXRpb24gY29tcGxleGl0eSBpcyBPKG4pIHdoZXJlIG4gLSBudW1iZXIgb2YgbGlua3Mgb2YgYSBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZyb21JZCBsaW5rIHN0YXJ0IGlkZW50aWZpZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9JZCBsaW5rIGVuZCBpZGVudGlmaWVyXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBsaW5rIGlmIHRoZXJlIGlzIG9uZS4gbnVsbCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZ2V0TGluazogZ2V0TGlua1xuICB9O1xuXG4gIC8vIHRoaXMgd2lsbCBhZGQgYG9uKClgIGFuZCBgZmlyZSgpYCBtZXRob2RzLlxuICBldmVudGlmeShncmFwaFBhcnQpO1xuXG4gIG1vbml0b3JTdWJzY3JpYmVycygpO1xuXG4gIHJldHVybiBncmFwaFBhcnQ7XG5cbiAgZnVuY3Rpb24gbW9uaXRvclN1YnNjcmliZXJzKCkge1xuICAgIHZhciByZWFsT24gPSBncmFwaFBhcnQub247XG5cbiAgICAvLyByZXBsYWNlIHJlYWwgYG9uYCB3aXRoIG91ciB0ZW1wb3Jhcnkgb24sIHdoaWNoIHdpbGwgdHJpZ2dlciBjaGFuZ2VcbiAgICAvLyBtb2RpZmljYXRpb24gbW9uaXRvcmluZzpcbiAgICBncmFwaFBhcnQub24gPSBvbjtcblxuICAgIGZ1bmN0aW9uIG9uKCkge1xuICAgICAgLy8gbm93IGl0J3MgdGltZSB0byBzdGFydCB0cmFja2luZyBzdHVmZjpcbiAgICAgIGdyYXBoUGFydC5iZWdpblVwZGF0ZSA9IGVudGVyTW9kaWZpY2F0aW9uID0gZW50ZXJNb2RpZmljYXRpb25SZWFsO1xuICAgICAgZ3JhcGhQYXJ0LmVuZFVwZGF0ZSA9IGV4aXRNb2RpZmljYXRpb24gPSBleGl0TW9kaWZpY2F0aW9uUmVhbDtcbiAgICAgIHJlY29yZExpbmtDaGFuZ2UgPSByZWNvcmRMaW5rQ2hhbmdlUmVhbDtcbiAgICAgIHJlY29yZE5vZGVDaGFuZ2UgPSByZWNvcmROb2RlQ2hhbmdlUmVhbDtcblxuICAgICAgLy8gdGhpcyB3aWxsIHJlcGxhY2UgY3VycmVudCBgb25gIG1ldGhvZCB3aXRoIHJlYWwgcHViL3N1YiBmcm9tIGBldmVudGlmeWAuXG4gICAgICBncmFwaFBhcnQub24gPSByZWFsT247XG4gICAgICAvLyBkZWxlZ2F0ZSB0byByZWFsIGBvbmAgaGFuZGxlcjpcbiAgICAgIHJldHVybiByZWFsT24uYXBwbHkoZ3JhcGhQYXJ0LCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29yZExpbmtDaGFuZ2VSZWFsKGxpbmssIGNoYW5nZVR5cGUpIHtcbiAgICBjaGFuZ2VzLnB1c2goe1xuICAgICAgbGluazogbGluayxcbiAgICAgIGNoYW5nZVR5cGU6IGNoYW5nZVR5cGVcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29yZE5vZGVDaGFuZ2VSZWFsKG5vZGUsIGNoYW5nZVR5cGUpIHtcbiAgICBjaGFuZ2VzLnB1c2goe1xuICAgICAgbm9kZTogbm9kZSxcbiAgICAgIGNoYW5nZVR5cGU6IGNoYW5nZVR5cGVcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZE5vZGUobm9kZUlkLCBkYXRhKSB7XG4gICAgaWYgKG5vZGVJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbm9kZSBpZGVudGlmaWVyJyk7XG4gICAgfVxuXG4gICAgZW50ZXJNb2RpZmljYXRpb24oKTtcblxuICAgIHZhciBub2RlID0gZ2V0Tm9kZShub2RlSWQpO1xuICAgIGlmICghbm9kZSkge1xuICAgICAgbm9kZSA9IG5ldyBOb2RlKG5vZGVJZCwgZGF0YSk7XG4gICAgICBub2Rlc0NvdW50Kys7XG4gICAgICByZWNvcmROb2RlQ2hhbmdlKG5vZGUsICdhZGQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5kYXRhID0gZGF0YTtcbiAgICAgIHJlY29yZE5vZGVDaGFuZ2Uobm9kZSwgJ3VwZGF0ZScpO1xuICAgIH1cblxuICAgIG5vZGVzW25vZGVJZF0gPSBub2RlO1xuXG4gICAgZXhpdE1vZGlmaWNhdGlvbigpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Tm9kZShub2RlSWQpIHtcbiAgICByZXR1cm4gbm9kZXNbbm9kZUlkXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZU5vZGUobm9kZUlkKSB7XG4gICAgdmFyIG5vZGUgPSBnZXROb2RlKG5vZGVJZCk7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZW50ZXJNb2RpZmljYXRpb24oKTtcblxuICAgIHZhciBwcmV2TGlua3MgPSBub2RlLmxpbmtzO1xuICAgIGlmIChwcmV2TGlua3MpIHtcbiAgICAgIG5vZGUubGlua3MgPSBudWxsO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHByZXZMaW5rcy5sZW5ndGg7ICsraSkge1xuICAgICAgICByZW1vdmVMaW5rKHByZXZMaW5rc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVsZXRlIG5vZGVzW25vZGVJZF07XG4gICAgbm9kZXNDb3VudC0tO1xuXG4gICAgcmVjb3JkTm9kZUNoYW5nZShub2RlLCAncmVtb3ZlJyk7XG5cbiAgICBleGl0TW9kaWZpY2F0aW9uKCk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gYWRkTGluayhmcm9tSWQsIHRvSWQsIGRhdGEpIHtcbiAgICBlbnRlck1vZGlmaWNhdGlvbigpO1xuXG4gICAgdmFyIGZyb21Ob2RlID0gZ2V0Tm9kZShmcm9tSWQpIHx8IGFkZE5vZGUoZnJvbUlkKTtcbiAgICB2YXIgdG9Ob2RlID0gZ2V0Tm9kZSh0b0lkKSB8fCBhZGROb2RlKHRvSWQpO1xuXG4gICAgdmFyIGxpbmsgPSBjcmVhdGVMaW5rKGZyb21JZCwgdG9JZCwgZGF0YSk7XG5cbiAgICBsaW5rcy5wdXNoKGxpbmspO1xuXG4gICAgLy8gVE9ETzogdGhpcyBpcyBub3QgY29vbC4gT24gbGFyZ2UgZ3JhcGhzIHBvdGVudGlhbGx5IHdvdWxkIGNvbnN1bWUgbW9yZSBtZW1vcnkuXG4gICAgYWRkTGlua1RvTm9kZShmcm9tTm9kZSwgbGluayk7XG4gICAgaWYgKGZyb21JZCAhPT0gdG9JZCkge1xuICAgICAgLy8gbWFrZSBzdXJlIHdlIGFyZSBub3QgZHVwbGljYXRpbmcgbGlua3MgZm9yIHNlbGYtbG9vcHNcbiAgICAgIGFkZExpbmtUb05vZGUodG9Ob2RlLCBsaW5rKTtcbiAgICB9XG5cbiAgICByZWNvcmRMaW5rQ2hhbmdlKGxpbmssICdhZGQnKTtcblxuICAgIGV4aXRNb2RpZmljYXRpb24oKTtcblxuICAgIHJldHVybiBsaW5rO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2luZ2xlTGluayhmcm9tSWQsIHRvSWQsIGRhdGEpIHtcbiAgICB2YXIgbGlua0lkID0gbWFrZUxpbmtJZChmcm9tSWQsIHRvSWQpO1xuICAgIHJldHVybiBuZXcgTGluayhmcm9tSWQsIHRvSWQsIGRhdGEsIGxpbmtJZCk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVVbmlxdWVMaW5rKGZyb21JZCwgdG9JZCwgZGF0YSkge1xuICAgIC8vIFRPRE86IEdldCByaWQgb2YgdGhpcyBtZXRob2QuXG4gICAgdmFyIGxpbmtJZCA9IG1ha2VMaW5rSWQoZnJvbUlkLCB0b0lkKTtcbiAgICB2YXIgaXNNdWx0aUVkZ2UgPSBtdWx0aUVkZ2VzLmhhc093blByb3BlcnR5KGxpbmtJZCk7XG4gICAgaWYgKGlzTXVsdGlFZGdlIHx8IGdldExpbmsoZnJvbUlkLCB0b0lkKSkge1xuICAgICAgaWYgKCFpc011bHRpRWRnZSkge1xuICAgICAgICBtdWx0aUVkZ2VzW2xpbmtJZF0gPSAwO1xuICAgICAgfVxuICAgICAgdmFyIHN1ZmZpeCA9ICdAJyArICgrK211bHRpRWRnZXNbbGlua0lkXSk7XG4gICAgICBsaW5rSWQgPSBtYWtlTGlua0lkKGZyb21JZCArIHN1ZmZpeCwgdG9JZCArIHN1ZmZpeCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBMaW5rKGZyb21JZCwgdG9JZCwgZGF0YSwgbGlua0lkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldExpbmtzKG5vZGVJZCkge1xuICAgIHZhciBub2RlID0gZ2V0Tm9kZShub2RlSWQpO1xuICAgIHJldHVybiBub2RlID8gbm9kZS5saW5rcyA6IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVMaW5rKGxpbmspIHtcbiAgICBpZiAoIWxpbmspIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGlkeCA9IGluZGV4T2ZFbGVtZW50SW5BcnJheShsaW5rLCBsaW5rcyk7XG4gICAgaWYgKGlkeCA8IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBlbnRlck1vZGlmaWNhdGlvbigpO1xuXG4gICAgbGlua3Muc3BsaWNlKGlkeCwgMSk7XG5cbiAgICB2YXIgZnJvbU5vZGUgPSBnZXROb2RlKGxpbmsuZnJvbUlkKTtcbiAgICB2YXIgdG9Ob2RlID0gZ2V0Tm9kZShsaW5rLnRvSWQpO1xuXG4gICAgaWYgKGZyb21Ob2RlKSB7XG4gICAgICBpZHggPSBpbmRleE9mRWxlbWVudEluQXJyYXkobGluaywgZnJvbU5vZGUubGlua3MpO1xuICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIGZyb21Ob2RlLmxpbmtzLnNwbGljZShpZHgsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0b05vZGUpIHtcbiAgICAgIGlkeCA9IGluZGV4T2ZFbGVtZW50SW5BcnJheShsaW5rLCB0b05vZGUubGlua3MpO1xuICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIHRvTm9kZS5saW5rcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZWNvcmRMaW5rQ2hhbmdlKGxpbmssICdyZW1vdmUnKTtcblxuICAgIGV4aXRNb2RpZmljYXRpb24oKTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TGluayhmcm9tTm9kZUlkLCB0b05vZGVJZCkge1xuICAgIC8vIFRPRE86IFVzZSBzb3J0ZWQgbGlua3MgdG8gc3BlZWQgdGhpcyB1cFxuICAgIHZhciBub2RlID0gZ2V0Tm9kZShmcm9tTm9kZUlkKSxcbiAgICAgIGk7XG4gICAgaWYgKCFub2RlIHx8ICFub2RlLmxpbmtzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbm9kZS5saW5rcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGxpbmsgPSBub2RlLmxpbmtzW2ldO1xuICAgICAgaWYgKGxpbmsuZnJvbUlkID09PSBmcm9tTm9kZUlkICYmIGxpbmsudG9JZCA9PT0gdG9Ob2RlSWQpIHtcbiAgICAgICAgcmV0dXJuIGxpbms7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7IC8vIG5vIGxpbmsuXG4gIH1cblxuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBlbnRlck1vZGlmaWNhdGlvbigpO1xuICAgIGZvckVhY2hOb2RlKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHJlbW92ZU5vZGUobm9kZS5pZCk7XG4gICAgfSk7XG4gICAgZXhpdE1vZGlmaWNhdGlvbigpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9yRWFjaExpbmsoY2FsbGJhY2spIHtcbiAgICB2YXIgaSwgbGVuZ3RoO1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGxpbmtzLmxlbmd0aDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNhbGxiYWNrKGxpbmtzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmb3JFYWNoTGlua2VkTm9kZShub2RlSWQsIGNhbGxiYWNrLCBvcmllbnRlZCkge1xuICAgIHZhciBub2RlID0gZ2V0Tm9kZShub2RlSWQpO1xuXG4gICAgaWYgKG5vZGUgJiYgbm9kZS5saW5rcyAmJiB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChvcmllbnRlZCkge1xuICAgICAgICByZXR1cm4gZm9yRWFjaE9yaWVudGVkTGluayhub2RlLmxpbmtzLCBub2RlSWQsIGNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmb3JFYWNoTm9uT3JpZW50ZWRMaW5rKG5vZGUubGlua3MsIG5vZGVJZCwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZvckVhY2hOb25PcmllbnRlZExpbmsobGlua3MsIG5vZGVJZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgcXVpdEZhc3Q7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5rcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGxpbmsgPSBsaW5rc1tpXTtcbiAgICAgIHZhciBsaW5rZWROb2RlSWQgPSBsaW5rLmZyb21JZCA9PT0gbm9kZUlkID8gbGluay50b0lkIDogbGluay5mcm9tSWQ7XG5cbiAgICAgIHF1aXRGYXN0ID0gY2FsbGJhY2sobm9kZXNbbGlua2VkTm9kZUlkXSwgbGluayk7XG4gICAgICBpZiAocXVpdEZhc3QpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIENsaWVudCBkb2VzIG5vdCBuZWVkIG1vcmUgaXRlcmF0aW9ucy4gQnJlYWsgbm93LlxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZvckVhY2hPcmllbnRlZExpbmsobGlua3MsIG5vZGVJZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgcXVpdEZhc3Q7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5rcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGxpbmsgPSBsaW5rc1tpXTtcbiAgICAgIGlmIChsaW5rLmZyb21JZCA9PT0gbm9kZUlkKSB7XG4gICAgICAgIHF1aXRGYXN0ID0gY2FsbGJhY2sobm9kZXNbbGluay50b0lkXSwgbGluayk7XG4gICAgICAgIGlmIChxdWl0RmFzdCkge1xuICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBDbGllbnQgZG9lcyBub3QgbmVlZCBtb3JlIGl0ZXJhdGlvbnMuIEJyZWFrIG5vdy5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHdlIHdpbGwgbm90IGZpcmUgYW55dGhpbmcgdW50aWwgdXNlcnMgb2YgdGhpcyBsaWJyYXJ5IGV4cGxpY2l0bHkgY2FsbCBgb24oKWBcbiAgLy8gbWV0aG9kLlxuICBmdW5jdGlvbiBub29wKCkge31cblxuICAvLyBFbnRlciwgRXhpdCBtb2RpZmljYXRpb24gYWxsb3dzIGJ1bGsgZ3JhcGggdXBkYXRlcyB3aXRob3V0IGZpcmluZyBldmVudHMuXG4gIGZ1bmN0aW9uIGVudGVyTW9kaWZpY2F0aW9uUmVhbCgpIHtcbiAgICBzdXNwZW5kRXZlbnRzICs9IDE7XG4gIH1cblxuICBmdW5jdGlvbiBleGl0TW9kaWZpY2F0aW9uUmVhbCgpIHtcbiAgICBzdXNwZW5kRXZlbnRzIC09IDE7XG4gICAgaWYgKHN1c3BlbmRFdmVudHMgPT09IDAgJiYgY2hhbmdlcy5sZW5ndGggPiAwKSB7XG4gICAgICBncmFwaFBhcnQuZmlyZSgnY2hhbmdlZCcsIGNoYW5nZXMpO1xuICAgICAgY2hhbmdlcy5sZW5ndGggPSAwO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVJdGVyYXRvcigpIHtcbiAgICAvLyBPYmplY3Qua2V5cyBpdGVyYXRvciBpcyAxLjN4IGZhc3RlciB0aGFuIGBmb3IgaW5gIGxvb3AuXG4gICAgLy8gU2VlIGBodHRwczovL2dpdGh1Yi5jb20vYW52YWthL25ncmFwaC5ncmFwaC90cmVlL2JlbmNoLWZvci1pbi12cy1vYmota2V5c2BcbiAgICAvLyBicmFuY2ggZm9yIHBlcmYgdGVzdFxuICAgIHJldHVybiBPYmplY3Qua2V5cyA/IG9iamVjdEtleXNJdGVyYXRvciA6IGZvckluSXRlcmF0b3I7XG4gIH1cblxuICBmdW5jdGlvbiBvYmplY3RLZXlzSXRlcmF0b3IoY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhub2Rlcyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoY2FsbGJhY2sobm9kZXNba2V5c1tpXV0pKSB7XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBjbGllbnQgZG9lc24ndCB3YW50IHRvIHByb2NlZWQuIFJldHVybi5cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmb3JJbkl0ZXJhdG9yKGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbm9kZTtcblxuICAgIGZvciAobm9kZSBpbiBub2Rlcykge1xuICAgICAgaWYgKGNhbGxiYWNrKG5vZGVzW25vZGVdKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gY2xpZW50IGRvZXNuJ3Qgd2FudCB0byBwcm9jZWVkLiBSZXR1cm4uXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIG5lZWQgdGhpcyBmb3Igb2xkIGJyb3dzZXJzLiBTaG91bGQgdGhpcyBiZSBhIHNlcGFyYXRlIG1vZHVsZT9cbmZ1bmN0aW9uIGluZGV4T2ZFbGVtZW50SW5BcnJheShlbGVtZW50LCBhcnJheSkge1xuICBpZiAoIWFycmF5KSByZXR1cm4gLTE7XG5cbiAgaWYgKGFycmF5LmluZGV4T2YpIHtcbiAgICByZXR1cm4gYXJyYXkuaW5kZXhPZihlbGVtZW50KTtcbiAgfVxuXG4gIHZhciBsZW4gPSBhcnJheS5sZW5ndGgsXG4gICAgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICBpZiAoYXJyYXlbaV0gPT09IGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBJbnRlcm5hbCBzdHJ1Y3R1cmUgdG8gcmVwcmVzZW50IG5vZGU7XG4gKi9cbmZ1bmN0aW9uIE5vZGUoaWQsIGRhdGEpIHtcbiAgdGhpcy5pZCA9IGlkO1xuICB0aGlzLmxpbmtzID0gbnVsbDtcbiAgdGhpcy5kYXRhID0gZGF0YTtcbn1cblxuZnVuY3Rpb24gYWRkTGlua1RvTm9kZShub2RlLCBsaW5rKSB7XG4gIGlmIChub2RlLmxpbmtzKSB7XG4gICAgbm9kZS5saW5rcy5wdXNoKGxpbmspO1xuICB9IGVsc2Uge1xuICAgIG5vZGUubGlua3MgPSBbbGlua107XG4gIH1cbn1cblxuLyoqXG4gKiBJbnRlcm5hbCBzdHJ1Y3R1cmUgdG8gcmVwcmVzZW50IGxpbmtzO1xuICovXG5mdW5jdGlvbiBMaW5rKGZyb21JZCwgdG9JZCwgZGF0YSwgaWQpIHtcbiAgdGhpcy5mcm9tSWQgPSBmcm9tSWQ7XG4gIHRoaXMudG9JZCA9IHRvSWQ7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMuaWQgPSBpZDtcbn1cblxuZnVuY3Rpb24gaGFzaENvZGUoc3RyKSB7XG4gIHZhciBoYXNoID0gMCwgaSwgY2hyLCBsZW47XG4gIGlmIChzdHIubGVuZ3RoID09IDApIHJldHVybiBoYXNoO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBzdHIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjaHIgICA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBjaHI7XG4gICAgaGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgfVxuICByZXR1cm4gaGFzaDtcbn1cblxuZnVuY3Rpb24gbWFrZUxpbmtJZChmcm9tSWQsIHRvSWQpIHtcbiAgcmV0dXJuIGZyb21JZC50b1N0cmluZygpICsgJ/CfkYkgJyArIHRvSWQudG9TdHJpbmcoKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ngraph.fromjson/node_modules/ngraph.graph/index.js\n");

/***/ }),

/***/ "../node_modules/ngraph.graph/index.js":
/*!*********************************************!*\
  !*** ../node_modules/ngraph.graph/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @fileOverview Contains definition of the core graph object.\n */\n\n// TODO: need to change storage layer:\n// 1. Be able to get all nodes O(1)\n// 2. Be able to get number of links O(1)\n\n/**\n * @example\n *  var graph = require('ngraph.graph')();\n *  graph.addNode(1);     // graph has one node.\n *  graph.addLink(2, 3);  // now graph contains three nodes and one link.\n *\n */\nmodule.exports = createGraph;\n\nvar eventify = __webpack_require__(/*! ngraph.events */ \"../node_modules/ngraph.events/index.js\");\n\n/**\n * Creates a new graph\n */\nfunction createGraph(options) {\n  // Graph structure is maintained as dictionary of nodes\n  // and array of links. Each node has 'links' property which\n  // hold all links related to that node. And general links\n  // array is used to speed up all links enumeration. This is inefficient\n  // in terms of memory, but simplifies coding.\n  options = options || {};\n  if ('uniqueLinkId' in options) {\n    console.warn(\n      'ngraph.graph: Starting from version 0.14 `uniqueLinkId` is deprecated.\\n' +\n      'Use `multigraph` option instead\\n',\n      '\\n',\n      'Note: there is also change in default behavior: From now on each graph\\n'+\n      'is considered to be not a multigraph by default (each edge is unique).'\n    );\n\n    options.multigraph = options.uniqueLinkId;\n  }\n\n  // Dear reader, the non-multigraphs do not guarantee that there is only\n  // one link for a given pair of node. When this option is set to false\n  // we can save some memory and CPU (18% faster for non-multigraph);\n  if (options.multigraph === undefined) options.multigraph = false;\n\n  var nodes = typeof Object.create === 'function' ? Object.create(null) : {},\n    links = [],\n    // Hash of multi-edges. Used to track ids of edges between same nodes\n    multiEdges = {},\n    nodesCount = 0,\n    suspendEvents = 0,\n\n    forEachNode = createNodeIterator(),\n    createLink = options.multigraph ? createUniqueLink : createSingleLink,\n\n    // Our graph API provides means to listen to graph changes. Users can subscribe\n    // to be notified about changes in the graph by using `on` method. However\n    // in some cases they don't use it. To avoid unnecessary memory consumption\n    // we will not record graph changes until we have at least one subscriber.\n    // Code below supports this optimization.\n    //\n    // Accumulates all changes made during graph updates.\n    // Each change element contains:\n    //  changeType - one of the strings: 'add', 'remove' or 'update';\n    //  node - if change is related to node this property is set to changed graph's node;\n    //  link - if change is related to link this property is set to changed graph's link;\n    changes = [],\n    recordLinkChange = noop,\n    recordNodeChange = noop,\n    enterModification = noop,\n    exitModification = noop;\n\n  // this is our public API:\n  var graphPart = {\n    /**\n     * Adds node to the graph. If node with given id already exists in the graph\n     * its data is extended with whatever comes in 'data' argument.\n     *\n     * @param nodeId the node's identifier. A string or number is preferred.\n     * @param [data] additional data for the node being added. If node already\n     *   exists its data object is augmented with the new one.\n     *\n     * @return {node} The newly added node or node with given id if it already exists.\n     */\n    addNode: addNode,\n\n    /**\n     * Adds a link to the graph. The function always create a new\n     * link between two nodes. If one of the nodes does not exists\n     * a new node is created.\n     *\n     * @param fromId link start node id;\n     * @param toId link end node id;\n     * @param [data] additional data to be set on the new link;\n     *\n     * @return {link} The newly created link\n     */\n    addLink: addLink,\n\n    /**\n     * Removes link from the graph. If link does not exist does nothing.\n     *\n     * @param link - object returned by addLink() or getLinks() methods.\n     *\n     * @returns true if link was removed; false otherwise.\n     */\n    removeLink: removeLink,\n\n    /**\n     * Removes node with given id from the graph. If node does not exist in the graph\n     * does nothing.\n     *\n     * @param nodeId node's identifier passed to addNode() function.\n     *\n     * @returns true if node was removed; false otherwise.\n     */\n    removeNode: removeNode,\n\n    /**\n     * Gets node with given identifier. If node does not exist undefined value is returned.\n     *\n     * @param nodeId requested node identifier;\n     *\n     * @return {node} in with requested identifier or undefined if no such node exists.\n     */\n    getNode: getNode,\n\n    /**\n     * Gets number of nodes in this graph.\n     *\n     * @return number of nodes in the graph.\n     */\n    getNodesCount: function () {\n      return nodesCount;\n    },\n\n    /**\n     * Gets total number of links in the graph.\n     */\n    getLinksCount: function () {\n      return links.length;\n    },\n\n    /**\n     * Gets all links (inbound and outbound) from the node with given id.\n     * If node with given id is not found null is returned.\n     *\n     * @param nodeId requested node identifier.\n     *\n     * @return Array of links from and to requested node if such node exists;\n     *   otherwise null is returned.\n     */\n    getLinks: getLinks,\n\n    /**\n     * Invokes callback on each node of the graph.\n     *\n     * @param {Function(node)} callback Function to be invoked. The function\n     *   is passed one argument: visited node.\n     */\n    forEachNode: forEachNode,\n\n    /**\n     * Invokes callback on every linked (adjacent) node to the given one.\n     *\n     * @param nodeId Identifier of the requested node.\n     * @param {Function(node, link)} callback Function to be called on all linked nodes.\n     *   The function is passed two parameters: adjacent node and link object itself.\n     * @param oriented if true graph treated as oriented.\n     */\n    forEachLinkedNode: forEachLinkedNode,\n\n    /**\n     * Enumerates all links in the graph\n     *\n     * @param {Function(link)} callback Function to be called on all links in the graph.\n     *   The function is passed one parameter: graph's link object.\n     *\n     * Link object contains at least the following fields:\n     *  fromId - node id where link starts;\n     *  toId - node id where link ends,\n     *  data - additional data passed to graph.addLink() method.\n     */\n    forEachLink: forEachLink,\n\n    /**\n     * Suspend all notifications about graph changes until\n     * endUpdate is called.\n     */\n    beginUpdate: enterModification,\n\n    /**\n     * Resumes all notifications about graph changes and fires\n     * graph 'changed' event in case there are any pending changes.\n     */\n    endUpdate: exitModification,\n\n    /**\n     * Removes all nodes and links from the graph.\n     */\n    clear: clear,\n\n    /**\n     * Detects whether there is a link between two nodes.\n     * Operation complexity is O(n) where n - number of links of a node.\n     * NOTE: this function is synonim for getLink()\n     *\n     * @returns link if there is one. null otherwise.\n     */\n    hasLink: getLink,\n\n    /**\n     * Detects whether there is a node with given id\n     * \n     * Operation complexity is O(1)\n     * NOTE: this function is synonim for getNode()\n     *\n     * @returns node if there is one; Falsy value otherwise.\n     */\n    hasNode: getNode,\n\n    /**\n     * Gets an edge between two nodes.\n     * Operation complexity is O(n) where n - number of links of a node.\n     *\n     * @param {string} fromId link start identifier\n     * @param {string} toId link end identifier\n     *\n     * @returns link if there is one. null otherwise.\n     */\n    getLink: getLink\n  };\n\n  // this will add `on()` and `fire()` methods.\n  eventify(graphPart);\n\n  monitorSubscribers();\n\n  return graphPart;\n\n  function monitorSubscribers() {\n    var realOn = graphPart.on;\n\n    // replace real `on` with our temporary on, which will trigger change\n    // modification monitoring:\n    graphPart.on = on;\n\n    function on() {\n      // now it's time to start tracking stuff:\n      graphPart.beginUpdate = enterModification = enterModificationReal;\n      graphPart.endUpdate = exitModification = exitModificationReal;\n      recordLinkChange = recordLinkChangeReal;\n      recordNodeChange = recordNodeChangeReal;\n\n      // this will replace current `on` method with real pub/sub from `eventify`.\n      graphPart.on = realOn;\n      // delegate to real `on` handler:\n      return realOn.apply(graphPart, arguments);\n    }\n  }\n\n  function recordLinkChangeReal(link, changeType) {\n    changes.push({\n      link: link,\n      changeType: changeType\n    });\n  }\n\n  function recordNodeChangeReal(node, changeType) {\n    changes.push({\n      node: node,\n      changeType: changeType\n    });\n  }\n\n  function addNode(nodeId, data) {\n    if (nodeId === undefined) {\n      throw new Error('Invalid node identifier');\n    }\n\n    enterModification();\n\n    var node = getNode(nodeId);\n    if (!node) {\n      node = new Node(nodeId, data);\n      nodesCount++;\n      recordNodeChange(node, 'add');\n    } else {\n      node.data = data;\n      recordNodeChange(node, 'update');\n    }\n\n    nodes[nodeId] = node;\n\n    exitModification();\n    return node;\n  }\n\n  function getNode(nodeId) {\n    return nodes[nodeId];\n  }\n\n  function removeNode(nodeId) {\n    var node = getNode(nodeId);\n    if (!node) {\n      return false;\n    }\n\n    enterModification();\n\n    var prevLinks = node.links;\n    if (prevLinks) {\n      node.links = null;\n      for(var i = 0; i < prevLinks.length; ++i) {\n        removeLink(prevLinks[i]);\n      }\n    }\n\n    delete nodes[nodeId];\n    nodesCount--;\n\n    recordNodeChange(node, 'remove');\n\n    exitModification();\n\n    return true;\n  }\n\n\n  function addLink(fromId, toId, data) {\n    enterModification();\n\n    var fromNode = getNode(fromId) || addNode(fromId);\n    var toNode = getNode(toId) || addNode(toId);\n\n    var link = createLink(fromId, toId, data);\n\n    links.push(link);\n\n    // TODO: this is not cool. On large graphs potentially would consume more memory.\n    addLinkToNode(fromNode, link);\n    if (fromId !== toId) {\n      // make sure we are not duplicating links for self-loops\n      addLinkToNode(toNode, link);\n    }\n\n    recordLinkChange(link, 'add');\n\n    exitModification();\n\n    return link;\n  }\n\n  function createSingleLink(fromId, toId, data) {\n    var linkId = makeLinkId(fromId, toId);\n    return new Link(fromId, toId, data, linkId);\n  }\n\n  function createUniqueLink(fromId, toId, data) {\n    // TODO: Get rid of this method.\n    var linkId = makeLinkId(fromId, toId);\n    var isMultiEdge = multiEdges.hasOwnProperty(linkId);\n    if (isMultiEdge || getLink(fromId, toId)) {\n      if (!isMultiEdge) {\n        multiEdges[linkId] = 0;\n      }\n      var suffix = '@' + (++multiEdges[linkId]);\n      linkId = makeLinkId(fromId + suffix, toId + suffix);\n    }\n\n    return new Link(fromId, toId, data, linkId);\n  }\n\n  function getLinks(nodeId) {\n    var node = getNode(nodeId);\n    return node ? node.links : null;\n  }\n\n  function removeLink(link) {\n    if (!link) {\n      return false;\n    }\n    var idx = indexOfElementInArray(link, links);\n    if (idx < 0) {\n      return false;\n    }\n\n    enterModification();\n\n    links.splice(idx, 1);\n\n    var fromNode = getNode(link.fromId);\n    var toNode = getNode(link.toId);\n\n    if (fromNode) {\n      idx = indexOfElementInArray(link, fromNode.links);\n      if (idx >= 0) {\n        fromNode.links.splice(idx, 1);\n      }\n    }\n\n    if (toNode) {\n      idx = indexOfElementInArray(link, toNode.links);\n      if (idx >= 0) {\n        toNode.links.splice(idx, 1);\n      }\n    }\n\n    recordLinkChange(link, 'remove');\n\n    exitModification();\n\n    return true;\n  }\n\n  function getLink(fromNodeId, toNodeId) {\n    // TODO: Use sorted links to speed this up\n    var node = getNode(fromNodeId),\n      i;\n    if (!node || !node.links) {\n      return null;\n    }\n\n    for (i = 0; i < node.links.length; ++i) {\n      var link = node.links[i];\n      if (link.fromId === fromNodeId && link.toId === toNodeId) {\n        return link;\n      }\n    }\n\n    return null; // no link.\n  }\n\n  function clear() {\n    enterModification();\n    forEachNode(function(node) {\n      removeNode(node.id);\n    });\n    exitModification();\n  }\n\n  function forEachLink(callback) {\n    var i, length;\n    if (typeof callback === 'function') {\n      for (i = 0, length = links.length; i < length; ++i) {\n        callback(links[i]);\n      }\n    }\n  }\n\n  function forEachLinkedNode(nodeId, callback, oriented) {\n    var node = getNode(nodeId);\n\n    if (node && node.links && typeof callback === 'function') {\n      if (oriented) {\n        return forEachOrientedLink(node.links, nodeId, callback);\n      } else {\n        return forEachNonOrientedLink(node.links, nodeId, callback);\n      }\n    }\n  }\n\n  function forEachNonOrientedLink(links, nodeId, callback) {\n    var quitFast;\n    for (var i = 0; i < links.length; ++i) {\n      var link = links[i];\n      var linkedNodeId = link.fromId === nodeId ? link.toId : link.fromId;\n\n      quitFast = callback(nodes[linkedNodeId], link);\n      if (quitFast) {\n        return true; // Client does not need more iterations. Break now.\n      }\n    }\n  }\n\n  function forEachOrientedLink(links, nodeId, callback) {\n    var quitFast;\n    for (var i = 0; i < links.length; ++i) {\n      var link = links[i];\n      if (link.fromId === nodeId) {\n        quitFast = callback(nodes[link.toId], link);\n        if (quitFast) {\n          return true; // Client does not need more iterations. Break now.\n        }\n      }\n    }\n  }\n\n  // we will not fire anything until users of this library explicitly call `on()`\n  // method.\n  function noop() {}\n\n  // Enter, Exit modification allows bulk graph updates without firing events.\n  function enterModificationReal() {\n    suspendEvents += 1;\n  }\n\n  function exitModificationReal() {\n    suspendEvents -= 1;\n    if (suspendEvents === 0 && changes.length > 0) {\n      graphPart.fire('changed', changes);\n      changes.length = 0;\n    }\n  }\n\n  function createNodeIterator() {\n    // Object.keys iterator is 1.3x faster than `for in` loop.\n    // See `https://github.com/anvaka/ngraph.graph/tree/bench-for-in-vs-obj-keys`\n    // branch for perf test\n    return Object.keys ? objectKeysIterator : forInIterator;\n  }\n\n  function objectKeysIterator(callback) {\n    if (typeof callback !== 'function') {\n      return;\n    }\n\n    var keys = Object.keys(nodes);\n    for (var i = 0; i < keys.length; ++i) {\n      if (callback(nodes[keys[i]])) {\n        return true; // client doesn't want to proceed. Return.\n      }\n    }\n  }\n\n  function forInIterator(callback) {\n    if (typeof callback !== 'function') {\n      return;\n    }\n    var node;\n\n    for (node in nodes) {\n      if (callback(nodes[node])) {\n        return true; // client doesn't want to proceed. Return.\n      }\n    }\n  }\n}\n\n// need this for old browsers. Should this be a separate module?\nfunction indexOfElementInArray(element, array) {\n  if (!array) return -1;\n\n  if (array.indexOf) {\n    return array.indexOf(element);\n  }\n\n  var len = array.length,\n    i;\n\n  for (i = 0; i < len; i += 1) {\n    if (array[i] === element) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\n/**\n * Internal structure to represent node;\n */\nfunction Node(id, data) {\n  this.id = id;\n  this.links = null;\n  this.data = data;\n}\n\nfunction addLinkToNode(node, link) {\n  if (node.links) {\n    node.links.push(link);\n  } else {\n    node.links = [link];\n  }\n}\n\n/**\n * Internal structure to represent links;\n */\nfunction Link(fromId, toId, data, id) {\n  this.fromId = fromId;\n  this.toId = toId;\n  this.data = data;\n  this.id = id;\n}\n\nfunction hashCode(str) {\n  var hash = 0, i, chr, len;\n  if (str.length == 0) return hash;\n  for (i = 0, len = str.length; i < len; i++) {\n    chr   = str.charCodeAt(i);\n    hash  = ((hash << 5) - hash) + chr;\n    hash |= 0; // Convert to 32bit integer\n  }\n  return hash;\n}\n\nfunction makeLinkId(fromId, toId) {\n  return fromId.toString() + '👉 ' + toId.toString();\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL25ncmFwaC5ncmFwaC9pbmRleC5qcz9iNGIwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLDZEQUFlOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBSztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBSztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxZQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsU0FBUztBQUN4QztBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL25ncmFwaC5ncmFwaC9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVPdmVydmlldyBDb250YWlucyBkZWZpbml0aW9uIG9mIHRoZSBjb3JlIGdyYXBoIG9iamVjdC5cbiAqL1xuXG4vLyBUT0RPOiBuZWVkIHRvIGNoYW5nZSBzdG9yYWdlIGxheWVyOlxuLy8gMS4gQmUgYWJsZSB0byBnZXQgYWxsIG5vZGVzIE8oMSlcbi8vIDIuIEJlIGFibGUgdG8gZ2V0IG51bWJlciBvZiBsaW5rcyBPKDEpXG5cbi8qKlxuICogQGV4YW1wbGVcbiAqICB2YXIgZ3JhcGggPSByZXF1aXJlKCduZ3JhcGguZ3JhcGgnKSgpO1xuICogIGdyYXBoLmFkZE5vZGUoMSk7ICAgICAvLyBncmFwaCBoYXMgb25lIG5vZGUuXG4gKiAgZ3JhcGguYWRkTGluaygyLCAzKTsgIC8vIG5vdyBncmFwaCBjb250YWlucyB0aHJlZSBub2RlcyBhbmQgb25lIGxpbmsuXG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUdyYXBoO1xuXG52YXIgZXZlbnRpZnkgPSByZXF1aXJlKCduZ3JhcGguZXZlbnRzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBncmFwaFxuICovXG5mdW5jdGlvbiBjcmVhdGVHcmFwaChvcHRpb25zKSB7XG4gIC8vIEdyYXBoIHN0cnVjdHVyZSBpcyBtYWludGFpbmVkIGFzIGRpY3Rpb25hcnkgb2Ygbm9kZXNcbiAgLy8gYW5kIGFycmF5IG9mIGxpbmtzLiBFYWNoIG5vZGUgaGFzICdsaW5rcycgcHJvcGVydHkgd2hpY2hcbiAgLy8gaG9sZCBhbGwgbGlua3MgcmVsYXRlZCB0byB0aGF0IG5vZGUuIEFuZCBnZW5lcmFsIGxpbmtzXG4gIC8vIGFycmF5IGlzIHVzZWQgdG8gc3BlZWQgdXAgYWxsIGxpbmtzIGVudW1lcmF0aW9uLiBUaGlzIGlzIGluZWZmaWNpZW50XG4gIC8vIGluIHRlcm1zIG9mIG1lbW9yeSwgYnV0IHNpbXBsaWZpZXMgY29kaW5nLlxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKCd1bmlxdWVMaW5rSWQnIGluIG9wdGlvbnMpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICAnbmdyYXBoLmdyYXBoOiBTdGFydGluZyBmcm9tIHZlcnNpb24gMC4xNCBgdW5pcXVlTGlua0lkYCBpcyBkZXByZWNhdGVkLlxcbicgK1xuICAgICAgJ1VzZSBgbXVsdGlncmFwaGAgb3B0aW9uIGluc3RlYWRcXG4nLFxuICAgICAgJ1xcbicsXG4gICAgICAnTm90ZTogdGhlcmUgaXMgYWxzbyBjaGFuZ2UgaW4gZGVmYXVsdCBiZWhhdmlvcjogRnJvbSBub3cgb24gZWFjaCBncmFwaFxcbicrXG4gICAgICAnaXMgY29uc2lkZXJlZCB0byBiZSBub3QgYSBtdWx0aWdyYXBoIGJ5IGRlZmF1bHQgKGVhY2ggZWRnZSBpcyB1bmlxdWUpLidcbiAgICApO1xuXG4gICAgb3B0aW9ucy5tdWx0aWdyYXBoID0gb3B0aW9ucy51bmlxdWVMaW5rSWQ7XG4gIH1cblxuICAvLyBEZWFyIHJlYWRlciwgdGhlIG5vbi1tdWx0aWdyYXBocyBkbyBub3QgZ3VhcmFudGVlIHRoYXQgdGhlcmUgaXMgb25seVxuICAvLyBvbmUgbGluayBmb3IgYSBnaXZlbiBwYWlyIG9mIG5vZGUuIFdoZW4gdGhpcyBvcHRpb24gaXMgc2V0IHRvIGZhbHNlXG4gIC8vIHdlIGNhbiBzYXZlIHNvbWUgbWVtb3J5IGFuZCBDUFUgKDE4JSBmYXN0ZXIgZm9yIG5vbi1tdWx0aWdyYXBoKTtcbiAgaWYgKG9wdGlvbnMubXVsdGlncmFwaCA9PT0gdW5kZWZpbmVkKSBvcHRpb25zLm11bHRpZ3JhcGggPSBmYWxzZTtcblxuICB2YXIgbm9kZXMgPSB0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJyA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fSxcbiAgICBsaW5rcyA9IFtdLFxuICAgIC8vIEhhc2ggb2YgbXVsdGktZWRnZXMuIFVzZWQgdG8gdHJhY2sgaWRzIG9mIGVkZ2VzIGJldHdlZW4gc2FtZSBub2Rlc1xuICAgIG11bHRpRWRnZXMgPSB7fSxcbiAgICBub2Rlc0NvdW50ID0gMCxcbiAgICBzdXNwZW5kRXZlbnRzID0gMCxcblxuICAgIGZvckVhY2hOb2RlID0gY3JlYXRlTm9kZUl0ZXJhdG9yKCksXG4gICAgY3JlYXRlTGluayA9IG9wdGlvbnMubXVsdGlncmFwaCA/IGNyZWF0ZVVuaXF1ZUxpbmsgOiBjcmVhdGVTaW5nbGVMaW5rLFxuXG4gICAgLy8gT3VyIGdyYXBoIEFQSSBwcm92aWRlcyBtZWFucyB0byBsaXN0ZW4gdG8gZ3JhcGggY2hhbmdlcy4gVXNlcnMgY2FuIHN1YnNjcmliZVxuICAgIC8vIHRvIGJlIG5vdGlmaWVkIGFib3V0IGNoYW5nZXMgaW4gdGhlIGdyYXBoIGJ5IHVzaW5nIGBvbmAgbWV0aG9kLiBIb3dldmVyXG4gICAgLy8gaW4gc29tZSBjYXNlcyB0aGV5IGRvbid0IHVzZSBpdC4gVG8gYXZvaWQgdW5uZWNlc3NhcnkgbWVtb3J5IGNvbnN1bXB0aW9uXG4gICAgLy8gd2Ugd2lsbCBub3QgcmVjb3JkIGdyYXBoIGNoYW5nZXMgdW50aWwgd2UgaGF2ZSBhdCBsZWFzdCBvbmUgc3Vic2NyaWJlci5cbiAgICAvLyBDb2RlIGJlbG93IHN1cHBvcnRzIHRoaXMgb3B0aW1pemF0aW9uLlxuICAgIC8vXG4gICAgLy8gQWNjdW11bGF0ZXMgYWxsIGNoYW5nZXMgbWFkZSBkdXJpbmcgZ3JhcGggdXBkYXRlcy5cbiAgICAvLyBFYWNoIGNoYW5nZSBlbGVtZW50IGNvbnRhaW5zOlxuICAgIC8vICBjaGFuZ2VUeXBlIC0gb25lIG9mIHRoZSBzdHJpbmdzOiAnYWRkJywgJ3JlbW92ZScgb3IgJ3VwZGF0ZSc7XG4gICAgLy8gIG5vZGUgLSBpZiBjaGFuZ2UgaXMgcmVsYXRlZCB0byBub2RlIHRoaXMgcHJvcGVydHkgaXMgc2V0IHRvIGNoYW5nZWQgZ3JhcGgncyBub2RlO1xuICAgIC8vICBsaW5rIC0gaWYgY2hhbmdlIGlzIHJlbGF0ZWQgdG8gbGluayB0aGlzIHByb3BlcnR5IGlzIHNldCB0byBjaGFuZ2VkIGdyYXBoJ3MgbGluaztcbiAgICBjaGFuZ2VzID0gW10sXG4gICAgcmVjb3JkTGlua0NoYW5nZSA9IG5vb3AsXG4gICAgcmVjb3JkTm9kZUNoYW5nZSA9IG5vb3AsXG4gICAgZW50ZXJNb2RpZmljYXRpb24gPSBub29wLFxuICAgIGV4aXRNb2RpZmljYXRpb24gPSBub29wO1xuXG4gIC8vIHRoaXMgaXMgb3VyIHB1YmxpYyBBUEk6XG4gIHZhciBncmFwaFBhcnQgPSB7XG4gICAgLyoqXG4gICAgICogQWRkcyBub2RlIHRvIHRoZSBncmFwaC4gSWYgbm9kZSB3aXRoIGdpdmVuIGlkIGFscmVhZHkgZXhpc3RzIGluIHRoZSBncmFwaFxuICAgICAqIGl0cyBkYXRhIGlzIGV4dGVuZGVkIHdpdGggd2hhdGV2ZXIgY29tZXMgaW4gJ2RhdGEnIGFyZ3VtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIG5vZGVJZCB0aGUgbm9kZSdzIGlkZW50aWZpZXIuIEEgc3RyaW5nIG9yIG51bWJlciBpcyBwcmVmZXJyZWQuXG4gICAgICogQHBhcmFtIFtkYXRhXSBhZGRpdGlvbmFsIGRhdGEgZm9yIHRoZSBub2RlIGJlaW5nIGFkZGVkLiBJZiBub2RlIGFscmVhZHlcbiAgICAgKiAgIGV4aXN0cyBpdHMgZGF0YSBvYmplY3QgaXMgYXVnbWVudGVkIHdpdGggdGhlIG5ldyBvbmUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtub2RlfSBUaGUgbmV3bHkgYWRkZWQgbm9kZSBvciBub2RlIHdpdGggZ2l2ZW4gaWQgaWYgaXQgYWxyZWFkeSBleGlzdHMuXG4gICAgICovXG4gICAgYWRkTm9kZTogYWRkTm9kZSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBsaW5rIHRvIHRoZSBncmFwaC4gVGhlIGZ1bmN0aW9uIGFsd2F5cyBjcmVhdGUgYSBuZXdcbiAgICAgKiBsaW5rIGJldHdlZW4gdHdvIG5vZGVzLiBJZiBvbmUgb2YgdGhlIG5vZGVzIGRvZXMgbm90IGV4aXN0c1xuICAgICAqIGEgbmV3IG5vZGUgaXMgY3JlYXRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmcm9tSWQgbGluayBzdGFydCBub2RlIGlkO1xuICAgICAqIEBwYXJhbSB0b0lkIGxpbmsgZW5kIG5vZGUgaWQ7XG4gICAgICogQHBhcmFtIFtkYXRhXSBhZGRpdGlvbmFsIGRhdGEgdG8gYmUgc2V0IG9uIHRoZSBuZXcgbGluaztcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge2xpbmt9IFRoZSBuZXdseSBjcmVhdGVkIGxpbmtcbiAgICAgKi9cbiAgICBhZGRMaW5rOiBhZGRMaW5rLFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBsaW5rIGZyb20gdGhlIGdyYXBoLiBJZiBsaW5rIGRvZXMgbm90IGV4aXN0IGRvZXMgbm90aGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsaW5rIC0gb2JqZWN0IHJldHVybmVkIGJ5IGFkZExpbmsoKSBvciBnZXRMaW5rcygpIG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIGxpbmsgd2FzIHJlbW92ZWQ7IGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICByZW1vdmVMaW5rOiByZW1vdmVMaW5rLFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBub2RlIHdpdGggZ2l2ZW4gaWQgZnJvbSB0aGUgZ3JhcGguIElmIG5vZGUgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGdyYXBoXG4gICAgICogZG9lcyBub3RoaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5vZGVJZCBub2RlJ3MgaWRlbnRpZmllciBwYXNzZWQgdG8gYWRkTm9kZSgpIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBub2RlIHdhcyByZW1vdmVkOyBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgcmVtb3ZlTm9kZTogcmVtb3ZlTm9kZSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgbm9kZSB3aXRoIGdpdmVuIGlkZW50aWZpZXIuIElmIG5vZGUgZG9lcyBub3QgZXhpc3QgdW5kZWZpbmVkIHZhbHVlIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5vZGVJZCByZXF1ZXN0ZWQgbm9kZSBpZGVudGlmaWVyO1xuICAgICAqXG4gICAgICogQHJldHVybiB7bm9kZX0gaW4gd2l0aCByZXF1ZXN0ZWQgaWRlbnRpZmllciBvciB1bmRlZmluZWQgaWYgbm8gc3VjaCBub2RlIGV4aXN0cy5cbiAgICAgKi9cbiAgICBnZXROb2RlOiBnZXROb2RlLFxuXG4gICAgLyoqXG4gICAgICogR2V0cyBudW1iZXIgb2Ygbm9kZXMgaW4gdGhpcyBncmFwaC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gbnVtYmVyIG9mIG5vZGVzIGluIHRoZSBncmFwaC5cbiAgICAgKi9cbiAgICBnZXROb2Rlc0NvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbm9kZXNDb3VudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0b3RhbCBudW1iZXIgb2YgbGlua3MgaW4gdGhlIGdyYXBoLlxuICAgICAqL1xuICAgIGdldExpbmtzQ291bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBsaW5rcy5sZW5ndGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGxpbmtzIChpbmJvdW5kIGFuZCBvdXRib3VuZCkgZnJvbSB0aGUgbm9kZSB3aXRoIGdpdmVuIGlkLlxuICAgICAqIElmIG5vZGUgd2l0aCBnaXZlbiBpZCBpcyBub3QgZm91bmQgbnVsbCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBub2RlSWQgcmVxdWVzdGVkIG5vZGUgaWRlbnRpZmllci5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gQXJyYXkgb2YgbGlua3MgZnJvbSBhbmQgdG8gcmVxdWVzdGVkIG5vZGUgaWYgc3VjaCBub2RlIGV4aXN0cztcbiAgICAgKiAgIG90aGVyd2lzZSBudWxsIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIGdldExpbmtzOiBnZXRMaW5rcyxcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgY2FsbGJhY2sgb24gZWFjaCBub2RlIG9mIHRoZSBncmFwaC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb24obm9kZSl9IGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGJlIGludm9rZWQuIFRoZSBmdW5jdGlvblxuICAgICAqICAgaXMgcGFzc2VkIG9uZSBhcmd1bWVudDogdmlzaXRlZCBub2RlLlxuICAgICAqL1xuICAgIGZvckVhY2hOb2RlOiBmb3JFYWNoTm9kZSxcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgY2FsbGJhY2sgb24gZXZlcnkgbGlua2VkIChhZGphY2VudCkgbm9kZSB0byB0aGUgZ2l2ZW4gb25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5vZGVJZCBJZGVudGlmaWVyIG9mIHRoZSByZXF1ZXN0ZWQgbm9kZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uKG5vZGUsIGxpbmspfSBjYWxsYmFjayBGdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gYWxsIGxpbmtlZCBub2Rlcy5cbiAgICAgKiAgIFRoZSBmdW5jdGlvbiBpcyBwYXNzZWQgdHdvIHBhcmFtZXRlcnM6IGFkamFjZW50IG5vZGUgYW5kIGxpbmsgb2JqZWN0IGl0c2VsZi5cbiAgICAgKiBAcGFyYW0gb3JpZW50ZWQgaWYgdHJ1ZSBncmFwaCB0cmVhdGVkIGFzIG9yaWVudGVkLlxuICAgICAqL1xuICAgIGZvckVhY2hMaW5rZWROb2RlOiBmb3JFYWNoTGlua2VkTm9kZSxcblxuICAgIC8qKlxuICAgICAqIEVudW1lcmF0ZXMgYWxsIGxpbmtzIGluIHRoZSBncmFwaFxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbihsaW5rKX0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGFsbCBsaW5rcyBpbiB0aGUgZ3JhcGguXG4gICAgICogICBUaGUgZnVuY3Rpb24gaXMgcGFzc2VkIG9uZSBwYXJhbWV0ZXI6IGdyYXBoJ3MgbGluayBvYmplY3QuXG4gICAgICpcbiAgICAgKiBMaW5rIG9iamVjdCBjb250YWlucyBhdCBsZWFzdCB0aGUgZm9sbG93aW5nIGZpZWxkczpcbiAgICAgKiAgZnJvbUlkIC0gbm9kZSBpZCB3aGVyZSBsaW5rIHN0YXJ0cztcbiAgICAgKiAgdG9JZCAtIG5vZGUgaWQgd2hlcmUgbGluayBlbmRzLFxuICAgICAqICBkYXRhIC0gYWRkaXRpb25hbCBkYXRhIHBhc3NlZCB0byBncmFwaC5hZGRMaW5rKCkgbWV0aG9kLlxuICAgICAqL1xuICAgIGZvckVhY2hMaW5rOiBmb3JFYWNoTGluayxcblxuICAgIC8qKlxuICAgICAqIFN1c3BlbmQgYWxsIG5vdGlmaWNhdGlvbnMgYWJvdXQgZ3JhcGggY2hhbmdlcyB1bnRpbFxuICAgICAqIGVuZFVwZGF0ZSBpcyBjYWxsZWQuXG4gICAgICovXG4gICAgYmVnaW5VcGRhdGU6IGVudGVyTW9kaWZpY2F0aW9uLFxuXG4gICAgLyoqXG4gICAgICogUmVzdW1lcyBhbGwgbm90aWZpY2F0aW9ucyBhYm91dCBncmFwaCBjaGFuZ2VzIGFuZCBmaXJlc1xuICAgICAqIGdyYXBoICdjaGFuZ2VkJyBldmVudCBpbiBjYXNlIHRoZXJlIGFyZSBhbnkgcGVuZGluZyBjaGFuZ2VzLlxuICAgICAqL1xuICAgIGVuZFVwZGF0ZTogZXhpdE1vZGlmaWNhdGlvbixcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIG5vZGVzIGFuZCBsaW5rcyBmcm9tIHRoZSBncmFwaC5cbiAgICAgKi9cbiAgICBjbGVhcjogY2xlYXIsXG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3RzIHdoZXRoZXIgdGhlcmUgaXMgYSBsaW5rIGJldHdlZW4gdHdvIG5vZGVzLlxuICAgICAqIE9wZXJhdGlvbiBjb21wbGV4aXR5IGlzIE8obikgd2hlcmUgbiAtIG51bWJlciBvZiBsaW5rcyBvZiBhIG5vZGUuXG4gICAgICogTk9URTogdGhpcyBmdW5jdGlvbiBpcyBzeW5vbmltIGZvciBnZXRMaW5rKClcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGxpbmsgaWYgdGhlcmUgaXMgb25lLiBudWxsIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBoYXNMaW5rOiBnZXRMaW5rLFxuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0cyB3aGV0aGVyIHRoZXJlIGlzIGEgbm9kZSB3aXRoIGdpdmVuIGlkXG4gICAgICogXG4gICAgICogT3BlcmF0aW9uIGNvbXBsZXhpdHkgaXMgTygxKVxuICAgICAqIE5PVEU6IHRoaXMgZnVuY3Rpb24gaXMgc3lub25pbSBmb3IgZ2V0Tm9kZSgpXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBub2RlIGlmIHRoZXJlIGlzIG9uZTsgRmFsc3kgdmFsdWUgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGhhc05vZGU6IGdldE5vZGUsXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFuIGVkZ2UgYmV0d2VlbiB0d28gbm9kZXMuXG4gICAgICogT3BlcmF0aW9uIGNvbXBsZXhpdHkgaXMgTyhuKSB3aGVyZSBuIC0gbnVtYmVyIG9mIGxpbmtzIG9mIGEgbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tSWQgbGluayBzdGFydCBpZGVudGlmaWVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRvSWQgbGluayBlbmQgaWRlbnRpZmllclxuICAgICAqXG4gICAgICogQHJldHVybnMgbGluayBpZiB0aGVyZSBpcyBvbmUuIG51bGwgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGdldExpbms6IGdldExpbmtcbiAgfTtcblxuICAvLyB0aGlzIHdpbGwgYWRkIGBvbigpYCBhbmQgYGZpcmUoKWAgbWV0aG9kcy5cbiAgZXZlbnRpZnkoZ3JhcGhQYXJ0KTtcblxuICBtb25pdG9yU3Vic2NyaWJlcnMoKTtcblxuICByZXR1cm4gZ3JhcGhQYXJ0O1xuXG4gIGZ1bmN0aW9uIG1vbml0b3JTdWJzY3JpYmVycygpIHtcbiAgICB2YXIgcmVhbE9uID0gZ3JhcGhQYXJ0Lm9uO1xuXG4gICAgLy8gcmVwbGFjZSByZWFsIGBvbmAgd2l0aCBvdXIgdGVtcG9yYXJ5IG9uLCB3aGljaCB3aWxsIHRyaWdnZXIgY2hhbmdlXG4gICAgLy8gbW9kaWZpY2F0aW9uIG1vbml0b3Jpbmc6XG4gICAgZ3JhcGhQYXJ0Lm9uID0gb247XG5cbiAgICBmdW5jdGlvbiBvbigpIHtcbiAgICAgIC8vIG5vdyBpdCdzIHRpbWUgdG8gc3RhcnQgdHJhY2tpbmcgc3R1ZmY6XG4gICAgICBncmFwaFBhcnQuYmVnaW5VcGRhdGUgPSBlbnRlck1vZGlmaWNhdGlvbiA9IGVudGVyTW9kaWZpY2F0aW9uUmVhbDtcbiAgICAgIGdyYXBoUGFydC5lbmRVcGRhdGUgPSBleGl0TW9kaWZpY2F0aW9uID0gZXhpdE1vZGlmaWNhdGlvblJlYWw7XG4gICAgICByZWNvcmRMaW5rQ2hhbmdlID0gcmVjb3JkTGlua0NoYW5nZVJlYWw7XG4gICAgICByZWNvcmROb2RlQ2hhbmdlID0gcmVjb3JkTm9kZUNoYW5nZVJlYWw7XG5cbiAgICAgIC8vIHRoaXMgd2lsbCByZXBsYWNlIGN1cnJlbnQgYG9uYCBtZXRob2Qgd2l0aCByZWFsIHB1Yi9zdWIgZnJvbSBgZXZlbnRpZnlgLlxuICAgICAgZ3JhcGhQYXJ0Lm9uID0gcmVhbE9uO1xuICAgICAgLy8gZGVsZWdhdGUgdG8gcmVhbCBgb25gIGhhbmRsZXI6XG4gICAgICByZXR1cm4gcmVhbE9uLmFwcGx5KGdyYXBoUGFydCwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWNvcmRMaW5rQ2hhbmdlUmVhbChsaW5rLCBjaGFuZ2VUeXBlKSB7XG4gICAgY2hhbmdlcy5wdXNoKHtcbiAgICAgIGxpbms6IGxpbmssXG4gICAgICBjaGFuZ2VUeXBlOiBjaGFuZ2VUeXBlXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvcmROb2RlQ2hhbmdlUmVhbChub2RlLCBjaGFuZ2VUeXBlKSB7XG4gICAgY2hhbmdlcy5wdXNoKHtcbiAgICAgIG5vZGU6IG5vZGUsXG4gICAgICBjaGFuZ2VUeXBlOiBjaGFuZ2VUeXBlXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGROb2RlKG5vZGVJZCwgZGF0YSkge1xuICAgIGlmIChub2RlSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG5vZGUgaWRlbnRpZmllcicpO1xuICAgIH1cblxuICAgIGVudGVyTW9kaWZpY2F0aW9uKCk7XG5cbiAgICB2YXIgbm9kZSA9IGdldE5vZGUobm9kZUlkKTtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIG5vZGUgPSBuZXcgTm9kZShub2RlSWQsIGRhdGEpO1xuICAgICAgbm9kZXNDb3VudCsrO1xuICAgICAgcmVjb3JkTm9kZUNoYW5nZShub2RlLCAnYWRkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuZGF0YSA9IGRhdGE7XG4gICAgICByZWNvcmROb2RlQ2hhbmdlKG5vZGUsICd1cGRhdGUnKTtcbiAgICB9XG5cbiAgICBub2Rlc1tub2RlSWRdID0gbm9kZTtcblxuICAgIGV4aXRNb2RpZmljYXRpb24oKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE5vZGUobm9kZUlkKSB7XG4gICAgcmV0dXJuIG5vZGVzW25vZGVJZF07XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVOb2RlKG5vZGVJZCkge1xuICAgIHZhciBub2RlID0gZ2V0Tm9kZShub2RlSWQpO1xuICAgIGlmICghbm9kZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGVudGVyTW9kaWZpY2F0aW9uKCk7XG5cbiAgICB2YXIgcHJldkxpbmtzID0gbm9kZS5saW5rcztcbiAgICBpZiAocHJldkxpbmtzKSB7XG4gICAgICBub2RlLmxpbmtzID0gbnVsbDtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcmV2TGlua3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcmVtb3ZlTGluayhwcmV2TGlua3NbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRlbGV0ZSBub2Rlc1tub2RlSWRdO1xuICAgIG5vZGVzQ291bnQtLTtcblxuICAgIHJlY29yZE5vZGVDaGFuZ2Uobm9kZSwgJ3JlbW92ZScpO1xuXG4gICAgZXhpdE1vZGlmaWNhdGlvbigpO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGFkZExpbmsoZnJvbUlkLCB0b0lkLCBkYXRhKSB7XG4gICAgZW50ZXJNb2RpZmljYXRpb24oKTtcblxuICAgIHZhciBmcm9tTm9kZSA9IGdldE5vZGUoZnJvbUlkKSB8fCBhZGROb2RlKGZyb21JZCk7XG4gICAgdmFyIHRvTm9kZSA9IGdldE5vZGUodG9JZCkgfHwgYWRkTm9kZSh0b0lkKTtcblxuICAgIHZhciBsaW5rID0gY3JlYXRlTGluayhmcm9tSWQsIHRvSWQsIGRhdGEpO1xuXG4gICAgbGlua3MucHVzaChsaW5rKTtcblxuICAgIC8vIFRPRE86IHRoaXMgaXMgbm90IGNvb2wuIE9uIGxhcmdlIGdyYXBocyBwb3RlbnRpYWxseSB3b3VsZCBjb25zdW1lIG1vcmUgbWVtb3J5LlxuICAgIGFkZExpbmtUb05vZGUoZnJvbU5vZGUsIGxpbmspO1xuICAgIGlmIChmcm9tSWQgIT09IHRvSWQpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBhcmUgbm90IGR1cGxpY2F0aW5nIGxpbmtzIGZvciBzZWxmLWxvb3BzXG4gICAgICBhZGRMaW5rVG9Ob2RlKHRvTm9kZSwgbGluayk7XG4gICAgfVxuXG4gICAgcmVjb3JkTGlua0NoYW5nZShsaW5rLCAnYWRkJyk7XG5cbiAgICBleGl0TW9kaWZpY2F0aW9uKCk7XG5cbiAgICByZXR1cm4gbGluaztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNpbmdsZUxpbmsoZnJvbUlkLCB0b0lkLCBkYXRhKSB7XG4gICAgdmFyIGxpbmtJZCA9IG1ha2VMaW5rSWQoZnJvbUlkLCB0b0lkKTtcbiAgICByZXR1cm4gbmV3IExpbmsoZnJvbUlkLCB0b0lkLCBkYXRhLCBsaW5rSWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5pcXVlTGluayhmcm9tSWQsIHRvSWQsIGRhdGEpIHtcbiAgICAvLyBUT0RPOiBHZXQgcmlkIG9mIHRoaXMgbWV0aG9kLlxuICAgIHZhciBsaW5rSWQgPSBtYWtlTGlua0lkKGZyb21JZCwgdG9JZCk7XG4gICAgdmFyIGlzTXVsdGlFZGdlID0gbXVsdGlFZGdlcy5oYXNPd25Qcm9wZXJ0eShsaW5rSWQpO1xuICAgIGlmIChpc011bHRpRWRnZSB8fCBnZXRMaW5rKGZyb21JZCwgdG9JZCkpIHtcbiAgICAgIGlmICghaXNNdWx0aUVkZ2UpIHtcbiAgICAgICAgbXVsdGlFZGdlc1tsaW5rSWRdID0gMDtcbiAgICAgIH1cbiAgICAgIHZhciBzdWZmaXggPSAnQCcgKyAoKyttdWx0aUVkZ2VzW2xpbmtJZF0pO1xuICAgICAgbGlua0lkID0gbWFrZUxpbmtJZChmcm9tSWQgKyBzdWZmaXgsIHRvSWQgKyBzdWZmaXgpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgTGluayhmcm9tSWQsIHRvSWQsIGRhdGEsIGxpbmtJZCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRMaW5rcyhub2RlSWQpIHtcbiAgICB2YXIgbm9kZSA9IGdldE5vZGUobm9kZUlkKTtcbiAgICByZXR1cm4gbm9kZSA/IG5vZGUubGlua3MgOiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTGluayhsaW5rKSB7XG4gICAgaWYgKCFsaW5rKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBpZHggPSBpbmRleE9mRWxlbWVudEluQXJyYXkobGluaywgbGlua3MpO1xuICAgIGlmIChpZHggPCAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZW50ZXJNb2RpZmljYXRpb24oKTtcblxuICAgIGxpbmtzLnNwbGljZShpZHgsIDEpO1xuXG4gICAgdmFyIGZyb21Ob2RlID0gZ2V0Tm9kZShsaW5rLmZyb21JZCk7XG4gICAgdmFyIHRvTm9kZSA9IGdldE5vZGUobGluay50b0lkKTtcblxuICAgIGlmIChmcm9tTm9kZSkge1xuICAgICAgaWR4ID0gaW5kZXhPZkVsZW1lbnRJbkFycmF5KGxpbmssIGZyb21Ob2RlLmxpbmtzKTtcbiAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICBmcm9tTm9kZS5saW5rcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodG9Ob2RlKSB7XG4gICAgICBpZHggPSBpbmRleE9mRWxlbWVudEluQXJyYXkobGluaywgdG9Ob2RlLmxpbmtzKTtcbiAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICB0b05vZGUubGlua3Muc3BsaWNlKGlkeCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVjb3JkTGlua0NoYW5nZShsaW5rLCAncmVtb3ZlJyk7XG5cbiAgICBleGl0TW9kaWZpY2F0aW9uKCk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldExpbmsoZnJvbU5vZGVJZCwgdG9Ob2RlSWQpIHtcbiAgICAvLyBUT0RPOiBVc2Ugc29ydGVkIGxpbmtzIHRvIHNwZWVkIHRoaXMgdXBcbiAgICB2YXIgbm9kZSA9IGdldE5vZGUoZnJvbU5vZGVJZCksXG4gICAgICBpO1xuICAgIGlmICghbm9kZSB8fCAhbm9kZS5saW5rcykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IG5vZGUubGlua3MubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBsaW5rID0gbm9kZS5saW5rc1tpXTtcbiAgICAgIGlmIChsaW5rLmZyb21JZCA9PT0gZnJvbU5vZGVJZCAmJiBsaW5rLnRvSWQgPT09IHRvTm9kZUlkKSB7XG4gICAgICAgIHJldHVybiBsaW5rO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsOyAvLyBubyBsaW5rLlxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgZW50ZXJNb2RpZmljYXRpb24oKTtcbiAgICBmb3JFYWNoTm9kZShmdW5jdGlvbihub2RlKSB7XG4gICAgICByZW1vdmVOb2RlKG5vZGUuaWQpO1xuICAgIH0pO1xuICAgIGV4aXRNb2RpZmljYXRpb24oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvckVhY2hMaW5rKGNhbGxiYWNrKSB7XG4gICAgdmFyIGksIGxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBsaW5rcy5sZW5ndGg7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICBjYWxsYmFjayhsaW5rc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZm9yRWFjaExpbmtlZE5vZGUobm9kZUlkLCBjYWxsYmFjaywgb3JpZW50ZWQpIHtcbiAgICB2YXIgbm9kZSA9IGdldE5vZGUobm9kZUlkKTtcblxuICAgIGlmIChub2RlICYmIG5vZGUubGlua3MgJiYgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAob3JpZW50ZWQpIHtcbiAgICAgICAgcmV0dXJuIGZvckVhY2hPcmllbnRlZExpbmsobm9kZS5saW5rcywgbm9kZUlkLCBjYWxsYmFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZm9yRWFjaE5vbk9yaWVudGVkTGluayhub2RlLmxpbmtzLCBub2RlSWQsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmb3JFYWNoTm9uT3JpZW50ZWRMaW5rKGxpbmtzLCBub2RlSWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHF1aXRGYXN0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlua3MubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBsaW5rID0gbGlua3NbaV07XG4gICAgICB2YXIgbGlua2VkTm9kZUlkID0gbGluay5mcm9tSWQgPT09IG5vZGVJZCA/IGxpbmsudG9JZCA6IGxpbmsuZnJvbUlkO1xuXG4gICAgICBxdWl0RmFzdCA9IGNhbGxiYWNrKG5vZGVzW2xpbmtlZE5vZGVJZF0sIGxpbmspO1xuICAgICAgaWYgKHF1aXRGYXN0KSB7XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBDbGllbnQgZG9lcyBub3QgbmVlZCBtb3JlIGl0ZXJhdGlvbnMuIEJyZWFrIG5vdy5cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmb3JFYWNoT3JpZW50ZWRMaW5rKGxpbmtzLCBub2RlSWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHF1aXRGYXN0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlua3MubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBsaW5rID0gbGlua3NbaV07XG4gICAgICBpZiAobGluay5mcm9tSWQgPT09IG5vZGVJZCkge1xuICAgICAgICBxdWl0RmFzdCA9IGNhbGxiYWNrKG5vZGVzW2xpbmsudG9JZF0sIGxpbmspO1xuICAgICAgICBpZiAocXVpdEZhc3QpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gQ2xpZW50IGRvZXMgbm90IG5lZWQgbW9yZSBpdGVyYXRpb25zLiBCcmVhayBub3cuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyB3ZSB3aWxsIG5vdCBmaXJlIGFueXRoaW5nIHVudGlsIHVzZXJzIG9mIHRoaXMgbGlicmFyeSBleHBsaWNpdGx5IGNhbGwgYG9uKClgXG4gIC8vIG1ldGhvZC5cbiAgZnVuY3Rpb24gbm9vcCgpIHt9XG5cbiAgLy8gRW50ZXIsIEV4aXQgbW9kaWZpY2F0aW9uIGFsbG93cyBidWxrIGdyYXBoIHVwZGF0ZXMgd2l0aG91dCBmaXJpbmcgZXZlbnRzLlxuICBmdW5jdGlvbiBlbnRlck1vZGlmaWNhdGlvblJlYWwoKSB7XG4gICAgc3VzcGVuZEV2ZW50cyArPSAxO1xuICB9XG5cbiAgZnVuY3Rpb24gZXhpdE1vZGlmaWNhdGlvblJlYWwoKSB7XG4gICAgc3VzcGVuZEV2ZW50cyAtPSAxO1xuICAgIGlmIChzdXNwZW5kRXZlbnRzID09PSAwICYmIGNoYW5nZXMubGVuZ3RoID4gMCkge1xuICAgICAgZ3JhcGhQYXJ0LmZpcmUoJ2NoYW5nZWQnLCBjaGFuZ2VzKTtcbiAgICAgIGNoYW5nZXMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVOb2RlSXRlcmF0b3IoKSB7XG4gICAgLy8gT2JqZWN0LmtleXMgaXRlcmF0b3IgaXMgMS4zeCBmYXN0ZXIgdGhhbiBgZm9yIGluYCBsb29wLlxuICAgIC8vIFNlZSBgaHR0cHM6Ly9naXRodWIuY29tL2FudmFrYS9uZ3JhcGguZ3JhcGgvdHJlZS9iZW5jaC1mb3ItaW4tdnMtb2JqLWtleXNgXG4gICAgLy8gYnJhbmNoIGZvciBwZXJmIHRlc3RcbiAgICByZXR1cm4gT2JqZWN0LmtleXMgPyBvYmplY3RLZXlzSXRlcmF0b3IgOiBmb3JJbkl0ZXJhdG9yO1xuICB9XG5cbiAgZnVuY3Rpb24gb2JqZWN0S2V5c0l0ZXJhdG9yKGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMobm9kZXMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGNhbGxiYWNrKG5vZGVzW2tleXNbaV1dKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gY2xpZW50IGRvZXNuJ3Qgd2FudCB0byBwcm9jZWVkLiBSZXR1cm4uXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZm9ySW5JdGVyYXRvcihjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5vZGU7XG5cbiAgICBmb3IgKG5vZGUgaW4gbm9kZXMpIHtcbiAgICAgIGlmIChjYWxsYmFjayhub2Rlc1tub2RlXSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIGNsaWVudCBkb2Vzbid0IHdhbnQgdG8gcHJvY2VlZC4gUmV0dXJuLlxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBuZWVkIHRoaXMgZm9yIG9sZCBicm93c2Vycy4gU2hvdWxkIHRoaXMgYmUgYSBzZXBhcmF0ZSBtb2R1bGU/XG5mdW5jdGlvbiBpbmRleE9mRWxlbWVudEluQXJyYXkoZWxlbWVudCwgYXJyYXkpIHtcbiAgaWYgKCFhcnJheSkgcmV0dXJuIC0xO1xuXG4gIGlmIChhcnJheS5pbmRleE9mKSB7XG4gICAgcmV0dXJuIGFycmF5LmluZGV4T2YoZWxlbWVudCk7XG4gIH1cblxuICB2YXIgbGVuID0gYXJyYXkubGVuZ3RoLFxuICAgIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgaWYgKGFycmF5W2ldID09PSBlbGVtZW50KSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogSW50ZXJuYWwgc3RydWN0dXJlIHRvIHJlcHJlc2VudCBub2RlO1xuICovXG5mdW5jdGlvbiBOb2RlKGlkLCBkYXRhKSB7XG4gIHRoaXMuaWQgPSBpZDtcbiAgdGhpcy5saW5rcyA9IG51bGw7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG59XG5cbmZ1bmN0aW9uIGFkZExpbmtUb05vZGUobm9kZSwgbGluaykge1xuICBpZiAobm9kZS5saW5rcykge1xuICAgIG5vZGUubGlua3MucHVzaChsaW5rKTtcbiAgfSBlbHNlIHtcbiAgICBub2RlLmxpbmtzID0gW2xpbmtdO1xuICB9XG59XG5cbi8qKlxuICogSW50ZXJuYWwgc3RydWN0dXJlIHRvIHJlcHJlc2VudCBsaW5rcztcbiAqL1xuZnVuY3Rpb24gTGluayhmcm9tSWQsIHRvSWQsIGRhdGEsIGlkKSB7XG4gIHRoaXMuZnJvbUlkID0gZnJvbUlkO1xuICB0aGlzLnRvSWQgPSB0b0lkO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLmlkID0gaWQ7XG59XG5cbmZ1bmN0aW9uIGhhc2hDb2RlKHN0cikge1xuICB2YXIgaGFzaCA9IDAsIGksIGNociwgbGVuO1xuICBpZiAoc3RyLmxlbmd0aCA9PSAwKSByZXR1cm4gaGFzaDtcbiAgZm9yIChpID0gMCwgbGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY2hyICAgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoICA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgY2hyO1xuICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gIH1cbiAgcmV0dXJuIGhhc2g7XG59XG5cbmZ1bmN0aW9uIG1ha2VMaW5rSWQoZnJvbUlkLCB0b0lkKSB7XG4gIHJldHVybiBmcm9tSWQudG9TdHJpbmcoKSArICfwn5GJICcgKyB0b0lkLnRvU3RyaW5nKCk7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ngraph.graph/index.js\n");

/***/ }),

/***/ "../node_modules/ngraph.path/a-star/NodeHeap.js":
/*!******************************************************!*\
  !*** ../node_modules/ngraph.path/a-star/NodeHeap.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Based on https://github.com/mourner/tinyqueue\n * Copyright (c) 2017, Vladimir Agafonkin https://github.com/mourner/tinyqueue/blob/master/LICENSE\n * \n * Adapted for PathFinding needs by @anvaka\n * Copyright (c) 2017, Andrei Kashcha\n */\nmodule.exports = NodeHeap;\n\nfunction NodeHeap(data, options) {\n  if (!(this instanceof NodeHeap)) return new NodeHeap(data, options);\n\n  if (!Array.isArray(data)) {\n    // assume first argument is our config object;\n    options = data;\n    data = [];\n  }\n\n  options = options || {};\n\n  this.data = data || [];\n  this.length = this.data.length;\n  this.compare = options.compare || defaultCompare;\n  this.setNodeId = options.setNodeId || noop;\n\n  if (this.length > 0) {\n    for (var i = (this.length >> 1); i >= 0; i--) this._down(i);\n  }\n\n  if (options.setNodeId) {\n    for (var i = 0; i < this.length; ++i) {\n      this.setNodeId(this.data[i], i);\n    }\n  }\n}\n\nfunction noop() {}\n\nfunction defaultCompare(a, b) {\n  return a - b;\n}\n\nNodeHeap.prototype = {\n\n  push: function (item) {\n    this.data.push(item);\n    this.setNodeId(item, this.length);\n    this.length++;\n    this._up(this.length - 1);\n  },\n\n  pop: function () {\n    if (this.length === 0) return undefined;\n\n    var top = this.data[0];\n    this.length--;\n\n    if (this.length > 0) {\n      this.data[0] = this.data[this.length];\n      this.setNodeId(this.data[0], 0);\n      this._down(0);\n    }\n    this.data.pop();\n\n    return top;\n  },\n\n  peek: function () {\n    return this.data[0];\n  },\n\n  updateItem: function (pos) {\n    this._down(pos);\n    this._up(pos);\n  },\n\n  _up: function (pos) {\n    var data = this.data;\n    var compare = this.compare;\n    var setNodeId = this.setNodeId;\n    var item = data[pos];\n\n    while (pos > 0) {\n      var parent = (pos - 1) >> 1;\n      var current = data[parent];\n      if (compare(item, current) >= 0) break;\n        data[pos] = current;\n\n       setNodeId(current, pos);\n       pos = parent;\n    }\n\n    data[pos] = item;\n    setNodeId(item, pos);\n  },\n\n  _down: function (pos) {\n    var data = this.data;\n    var compare = this.compare;\n    var halfLength = this.length >> 1;\n    var item = data[pos];\n    var setNodeId = this.setNodeId;\n\n    while (pos < halfLength) {\n      var left = (pos << 1) + 1;\n      var right = left + 1;\n      var best = data[left];\n\n      if (right < this.length && compare(data[right], best) < 0) {\n        left = right;\n        best = data[right];\n      }\n      if (compare(best, item) >= 0) break;\n\n      data[pos] = best;\n      setNodeId(best, pos);\n      pos = left;\n    }\n\n    data[pos] = item;\n    setNodeId(item, pos);\n  }\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL25ncmFwaC5wYXRoL2Etc3Rhci9Ob2RlSGVhcC5qcz82MTMyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7O0FBRUE7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL25ncmFwaC5wYXRoL2Etc3Rhci9Ob2RlSGVhcC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL21vdXJuZXIvdGlueXF1ZXVlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcsIFZsYWRpbWlyIEFnYWZvbmtpbiBodHRwczovL2dpdGh1Yi5jb20vbW91cm5lci90aW55cXVldWUvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICogXG4gKiBBZGFwdGVkIGZvciBQYXRoRmluZGluZyBuZWVkcyBieSBAYW52YWthXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcsIEFuZHJlaSBLYXNoY2hhXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gTm9kZUhlYXA7XG5cbmZ1bmN0aW9uIE5vZGVIZWFwKGRhdGEsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE5vZGVIZWFwKSkgcmV0dXJuIG5ldyBOb2RlSGVhcChkYXRhLCBvcHRpb25zKTtcblxuICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAvLyBhc3N1bWUgZmlyc3QgYXJndW1lbnQgaXMgb3VyIGNvbmZpZyBvYmplY3Q7XG4gICAgb3B0aW9ucyA9IGRhdGE7XG4gICAgZGF0YSA9IFtdO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdGhpcy5kYXRhID0gZGF0YSB8fCBbXTtcbiAgdGhpcy5sZW5ndGggPSB0aGlzLmRhdGEubGVuZ3RoO1xuICB0aGlzLmNvbXBhcmUgPSBvcHRpb25zLmNvbXBhcmUgfHwgZGVmYXVsdENvbXBhcmU7XG4gIHRoaXMuc2V0Tm9kZUlkID0gb3B0aW9ucy5zZXROb2RlSWQgfHwgbm9vcDtcblxuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgZm9yICh2YXIgaSA9ICh0aGlzLmxlbmd0aCA+PiAxKTsgaSA+PSAwOyBpLS0pIHRoaXMuX2Rvd24oaSk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5zZXROb2RlSWQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHRoaXMuc2V0Tm9kZUlkKHRoaXMuZGF0YVtpXSwgaSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyZShhLCBiKSB7XG4gIHJldHVybiBhIC0gYjtcbn1cblxuTm9kZUhlYXAucHJvdG90eXBlID0ge1xuXG4gIHB1c2g6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgdGhpcy5kYXRhLnB1c2goaXRlbSk7XG4gICAgdGhpcy5zZXROb2RlSWQoaXRlbSwgdGhpcy5sZW5ndGgpO1xuICAgIHRoaXMubGVuZ3RoKys7XG4gICAgdGhpcy5fdXAodGhpcy5sZW5ndGggLSAxKTtcbiAgfSxcblxuICBwb3A6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgdG9wID0gdGhpcy5kYXRhWzBdO1xuICAgIHRoaXMubGVuZ3RoLS07XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmRhdGFbMF0gPSB0aGlzLmRhdGFbdGhpcy5sZW5ndGhdO1xuICAgICAgdGhpcy5zZXROb2RlSWQodGhpcy5kYXRhWzBdLCAwKTtcbiAgICAgIHRoaXMuX2Rvd24oMCk7XG4gICAgfVxuICAgIHRoaXMuZGF0YS5wb3AoKTtcblxuICAgIHJldHVybiB0b3A7XG4gIH0sXG5cbiAgcGVlazogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGFbMF07XG4gIH0sXG5cbiAgdXBkYXRlSXRlbTogZnVuY3Rpb24gKHBvcykge1xuICAgIHRoaXMuX2Rvd24ocG9zKTtcbiAgICB0aGlzLl91cChwb3MpO1xuICB9LFxuXG4gIF91cDogZnVuY3Rpb24gKHBvcykge1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHZhciBjb21wYXJlID0gdGhpcy5jb21wYXJlO1xuICAgIHZhciBzZXROb2RlSWQgPSB0aGlzLnNldE5vZGVJZDtcbiAgICB2YXIgaXRlbSA9IGRhdGFbcG9zXTtcblxuICAgIHdoaWxlIChwb3MgPiAwKSB7XG4gICAgICB2YXIgcGFyZW50ID0gKHBvcyAtIDEpID4+IDE7XG4gICAgICB2YXIgY3VycmVudCA9IGRhdGFbcGFyZW50XTtcbiAgICAgIGlmIChjb21wYXJlKGl0ZW0sIGN1cnJlbnQpID49IDApIGJyZWFrO1xuICAgICAgICBkYXRhW3Bvc10gPSBjdXJyZW50O1xuXG4gICAgICAgc2V0Tm9kZUlkKGN1cnJlbnQsIHBvcyk7XG4gICAgICAgcG9zID0gcGFyZW50O1xuICAgIH1cblxuICAgIGRhdGFbcG9zXSA9IGl0ZW07XG4gICAgc2V0Tm9kZUlkKGl0ZW0sIHBvcyk7XG4gIH0sXG5cbiAgX2Rvd246IGZ1bmN0aW9uIChwb3MpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgY29tcGFyZSA9IHRoaXMuY29tcGFyZTtcbiAgICB2YXIgaGFsZkxlbmd0aCA9IHRoaXMubGVuZ3RoID4+IDE7XG4gICAgdmFyIGl0ZW0gPSBkYXRhW3Bvc107XG4gICAgdmFyIHNldE5vZGVJZCA9IHRoaXMuc2V0Tm9kZUlkO1xuXG4gICAgd2hpbGUgKHBvcyA8IGhhbGZMZW5ndGgpIHtcbiAgICAgIHZhciBsZWZ0ID0gKHBvcyA8PCAxKSArIDE7XG4gICAgICB2YXIgcmlnaHQgPSBsZWZ0ICsgMTtcbiAgICAgIHZhciBiZXN0ID0gZGF0YVtsZWZ0XTtcblxuICAgICAgaWYgKHJpZ2h0IDwgdGhpcy5sZW5ndGggJiYgY29tcGFyZShkYXRhW3JpZ2h0XSwgYmVzdCkgPCAwKSB7XG4gICAgICAgIGxlZnQgPSByaWdodDtcbiAgICAgICAgYmVzdCA9IGRhdGFbcmlnaHRdO1xuICAgICAgfVxuICAgICAgaWYgKGNvbXBhcmUoYmVzdCwgaXRlbSkgPj0gMCkgYnJlYWs7XG5cbiAgICAgIGRhdGFbcG9zXSA9IGJlc3Q7XG4gICAgICBzZXROb2RlSWQoYmVzdCwgcG9zKTtcbiAgICAgIHBvcyA9IGxlZnQ7XG4gICAgfVxuXG4gICAgZGF0YVtwb3NdID0gaXRlbTtcbiAgICBzZXROb2RlSWQoaXRlbSwgcG9zKTtcbiAgfVxufTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ngraph.path/a-star/NodeHeap.js\n");

/***/ }),

/***/ "../node_modules/ngraph.path/a-star/a-greedy-star.js":
/*!***********************************************************!*\
  !*** ../node_modules/ngraph.path/a-star/a-greedy-star.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Performs suboptimal, greed A Star path finding.\n * This finder does not necessary finds the shortest path. The path\n * that it finds is very close to the shortest one. It is very fast though.\n */\nmodule.exports = aStarBi;\n\nvar NodeHeap = __webpack_require__(/*! ./NodeHeap */ \"../node_modules/ngraph.path/a-star/NodeHeap.js\");\nvar makeSearchStatePool = __webpack_require__(/*! ./makeSearchStatePool */ \"../node_modules/ngraph.path/a-star/makeSearchStatePool.js\");\nvar heuristics = __webpack_require__(/*! ./heuristics */ \"../node_modules/ngraph.path/a-star/heuristics.js\");\nvar defaultSettings = __webpack_require__(/*! ./defaultSettings */ \"../node_modules/ngraph.path/a-star/defaultSettings.js\");\n\nvar BY_FROM = 1;\nvar BY_TO = 2;\nvar NO_PATH = defaultSettings.NO_PATH;\n\nmodule.exports.l2 = heuristics.l2;\nmodule.exports.l1 = heuristics.l1;\n\n/**\n * Creates a new instance of pathfinder. A pathfinder has just one method:\n * `find(fromId, toId)`, it may be extended in future.\n * \n * NOTE: Algorithm implemented in this code DOES NOT find optimal path.\n * Yet the path that it finds is always near optimal, and it finds it very fast.\n * \n * @param {ngraph.graph} graph instance. See https://github.com/anvaka/ngraph.graph\n * \n * @param {Object} options that configures search\n * @param {Function(a, b)} options.heuristic - a function that returns estimated distance between\n * nodes `a` and `b`.  Defaults function returns 0, which makes this search equivalent to Dijkstra search.\n * @param {Function(a, b)} options.distance - a function that returns actual distance between two\n * nodes `a` and `b`. By default this is set to return graph-theoretical distance (always 1);\n * @param {Boolean} options.oriented - whether graph should be considered oriented or not.\n * \n * @returns {Object} A pathfinder with single method `find()`.\n */\nfunction aStarBi(graph, options) {\n  options = options || {};\n  // whether traversal should be considered over oriented graph.\n  var oriented = options.oriented;\n\n  var heuristic = options.heuristic;\n  if (!heuristic) heuristic = defaultSettings.heuristic;\n\n  var distance = options.distance;\n  if (!distance) distance = defaultSettings.distance;\n  var pool = makeSearchStatePool();\n\n  return {\n    find: find\n  };\n\n  function find(fromId, toId) {\n    // Not sure if we should return NO_PATH or throw. Throw seem to be more\n    // helpful to debug errors. So, throwing.\n    var from = graph.getNode(fromId);\n    if (!from) throw new Error('fromId is not defined in this graph: ' + fromId);\n    var to = graph.getNode(toId);\n    if (!to) throw new Error('toId is not defined in this graph: ' + toId);\n\n    if (from === to) return [from]; // trivial case.\n\n    pool.reset();\n\n    var callVisitor = oriented ? orientedVisitor : nonOrientedVisitor;\n\n    // Maps nodeId to NodeSearchState.\n    var nodeState = new Map();\n\n    var openSetFrom = new NodeHeap({\n      compare: defaultSettings.compareFScore,\n      setNodeId: defaultSettings.setHeapIndex\n    });\n\n    var openSetTo = new NodeHeap({\n      compare: defaultSettings.compareFScore,\n      setNodeId: defaultSettings.setHeapIndex\n    });\n\n\n    var startNode = pool.createNewState(from);\n    nodeState.set(fromId, startNode);\n\n    // For the first node, fScore is completely heuristic.\n    startNode.fScore = heuristic(from, to);\n    // The cost of going from start to start is zero.\n    startNode.distanceToSource = 0;\n    openSetFrom.push(startNode);\n    startNode.open = BY_FROM;\n\n    var endNode = pool.createNewState(to);\n    endNode.fScore = heuristic(to, from);\n    endNode.distanceToSource = 0;\n    openSetTo.push(endNode);\n    endNode.open = BY_TO;\n\n    // Cost of the best solution found so far. Used for accurate termination\n    var lMin = Number.POSITIVE_INFINITY;\n    var minFrom;\n    var minTo;\n\n    var currentSet = openSetFrom;\n    var currentOpener = BY_FROM;\n\n    while (openSetFrom.length > 0 && openSetTo.length > 0) {\n      if (openSetFrom.length < openSetTo.length) {\n        // we pick a set with less elements\n        currentOpener = BY_FROM;\n        currentSet = openSetFrom;\n      } else {\n        currentOpener = BY_TO;\n        currentSet = openSetTo;\n      }\n\n      var current = currentSet.pop();\n\n      // no need to visit this node anymore\n      current.closed = true;\n\n      if (current.distanceToSource > lMin) continue;\n\n      graph.forEachLinkedNode(current.node.id, callVisitor);\n\n      if (minFrom && minTo) {\n        // This is not necessary the best path, but we are so greedy that we\n        // can't resist:\n        return reconstructBiDirectionalPath(minFrom, minTo);\n      }\n    }\n\n    return NO_PATH; // No path.\n\n    function nonOrientedVisitor(otherNode, link) {\n      return visitNode(otherNode, link, current);\n    }\n\n    function orientedVisitor(otherNode, link) {\n      // For oritned graphs we need to reverse graph, when traveling\n      // backwards. So, we use non-oriented ngraph's traversal, and \n      // filter link orientation here.\n      if (currentOpener === BY_FROM) {\n        if (link.fromId === current.node.id) return visitNode(otherNode, link, current)\n      } else if (currentOpener === BY_TO) {\n        if (link.toId === current.node.id) return visitNode(otherNode, link, current);\n      }\n    }\n\n    function canExit(currentNode) {\n      var opener = currentNode.open\n      if (opener && opener !== currentOpener) {\n        return true;\n      }\n\n      return false;\n    }\n\n    function reconstructBiDirectionalPath(a, b) {\n      var pathOfNodes = [];\n      var aParent = a;\n      while(aParent) {\n        pathOfNodes.push(aParent.node);\n        aParent = aParent.parent;\n      }\n      var bParent = b;\n      while (bParent) {\n        pathOfNodes.unshift(bParent.node);\n        bParent = bParent.parent\n      }\n      return pathOfNodes;\n    }\n\n    function visitNode(otherNode, link, cameFrom) {\n      var otherSearchState = nodeState.get(otherNode.id);\n      if (!otherSearchState) {\n        otherSearchState = pool.createNewState(otherNode);\n        nodeState.set(otherNode.id, otherSearchState);\n      }\n\n      if (otherSearchState.closed) {\n        // Already processed this node.\n        return;\n      }\n\n      if (canExit(otherSearchState, cameFrom)) {\n        // this node was opened by alternative opener. The sets intersect now,\n        // we found an optimal path, that goes through *this* node. However, there\n        // is no guarantee that this is the global optimal solution path.\n\n        var potentialLMin = otherSearchState.distanceToSource + cameFrom.distanceToSource;\n        if (potentialLMin < lMin) {\n          minFrom = otherSearchState;\n          minTo = cameFrom\n          lMin = potentialLMin;\n        }\n        // we are done with this node.\n        return;\n      }\n\n      var tentativeDistance = cameFrom.distanceToSource + distance(otherSearchState.node, cameFrom.node, link);\n\n      if (tentativeDistance >= otherSearchState.distanceToSource) {\n        // This would only make our path longer. Ignore this route.\n        return;\n      }\n\n      // Choose target based on current working set:\n      var target = (currentOpener === BY_FROM) ? to : from;\n      var newFScore = tentativeDistance + heuristic(otherSearchState.node, target);\n      if (newFScore >= lMin) {\n        // this can't be optimal path, as we have already found a shorter path.\n        return;\n      }\n      otherSearchState.fScore = newFScore;\n\n      if (otherSearchState.open === 0) {\n        // Remember this node in the current set\n        currentSet.push(otherSearchState);\n        currentSet.updateItem(otherSearchState.heapIndex);\n\n        otherSearchState.open = currentOpener;\n      }\n\n      // bingo! we found shorter path:\n      otherSearchState.parent = cameFrom;\n      otherSearchState.distanceToSource = tentativeDistance;\n    }\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL25ncmFwaC5wYXRoL2Etc3Rhci9hLWdyZWVkeS1zdGFyLmpzPzcwN2QiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsbUJBQU8sQ0FBQyxrRUFBWTtBQUNuQywwQkFBMEIsbUJBQU8sQ0FBQyx3RkFBdUI7QUFDekQsaUJBQWlCLG1CQUFPLENBQUMsc0VBQWM7QUFDdkMsc0JBQXNCLG1CQUFPLENBQUMsZ0ZBQW1COztBQUVqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLGVBQWU7QUFDMUI7QUFDQSxXQUFXLGVBQWU7QUFDMUI7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DOztBQUVuQzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4uL25vZGVfbW9kdWxlcy9uZ3JhcGgucGF0aC9hLXN0YXIvYS1ncmVlZHktc3Rhci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUGVyZm9ybXMgc3Vib3B0aW1hbCwgZ3JlZWQgQSBTdGFyIHBhdGggZmluZGluZy5cbiAqIFRoaXMgZmluZGVyIGRvZXMgbm90IG5lY2Vzc2FyeSBmaW5kcyB0aGUgc2hvcnRlc3QgcGF0aC4gVGhlIHBhdGhcbiAqIHRoYXQgaXQgZmluZHMgaXMgdmVyeSBjbG9zZSB0byB0aGUgc2hvcnRlc3Qgb25lLiBJdCBpcyB2ZXJ5IGZhc3QgdGhvdWdoLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGFTdGFyQmk7XG5cbnZhciBOb2RlSGVhcCA9IHJlcXVpcmUoJy4vTm9kZUhlYXAnKTtcbnZhciBtYWtlU2VhcmNoU3RhdGVQb29sID0gcmVxdWlyZSgnLi9tYWtlU2VhcmNoU3RhdGVQb29sJyk7XG52YXIgaGV1cmlzdGljcyA9IHJlcXVpcmUoJy4vaGV1cmlzdGljcycpO1xudmFyIGRlZmF1bHRTZXR0aW5ncyA9IHJlcXVpcmUoJy4vZGVmYXVsdFNldHRpbmdzJyk7XG5cbnZhciBCWV9GUk9NID0gMTtcbnZhciBCWV9UTyA9IDI7XG52YXIgTk9fUEFUSCA9IGRlZmF1bHRTZXR0aW5ncy5OT19QQVRIO1xuXG5tb2R1bGUuZXhwb3J0cy5sMiA9IGhldXJpc3RpY3MubDI7XG5tb2R1bGUuZXhwb3J0cy5sMSA9IGhldXJpc3RpY3MubDE7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBwYXRoZmluZGVyLiBBIHBhdGhmaW5kZXIgaGFzIGp1c3Qgb25lIG1ldGhvZDpcbiAqIGBmaW5kKGZyb21JZCwgdG9JZClgLCBpdCBtYXkgYmUgZXh0ZW5kZWQgaW4gZnV0dXJlLlxuICogXG4gKiBOT1RFOiBBbGdvcml0aG0gaW1wbGVtZW50ZWQgaW4gdGhpcyBjb2RlIERPRVMgTk9UIGZpbmQgb3B0aW1hbCBwYXRoLlxuICogWWV0IHRoZSBwYXRoIHRoYXQgaXQgZmluZHMgaXMgYWx3YXlzIG5lYXIgb3B0aW1hbCwgYW5kIGl0IGZpbmRzIGl0IHZlcnkgZmFzdC5cbiAqIFxuICogQHBhcmFtIHtuZ3JhcGguZ3JhcGh9IGdyYXBoIGluc3RhbmNlLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2FudmFrYS9uZ3JhcGguZ3JhcGhcbiAqIFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdGhhdCBjb25maWd1cmVzIHNlYXJjaFxuICogQHBhcmFtIHtGdW5jdGlvbihhLCBiKX0gb3B0aW9ucy5oZXVyaXN0aWMgLSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBlc3RpbWF0ZWQgZGlzdGFuY2UgYmV0d2VlblxuICogbm9kZXMgYGFgIGFuZCBgYmAuICBEZWZhdWx0cyBmdW5jdGlvbiByZXR1cm5zIDAsIHdoaWNoIG1ha2VzIHRoaXMgc2VhcmNoIGVxdWl2YWxlbnQgdG8gRGlqa3N0cmEgc2VhcmNoLlxuICogQHBhcmFtIHtGdW5jdGlvbihhLCBiKX0gb3B0aW9ucy5kaXN0YW5jZSAtIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFjdHVhbCBkaXN0YW5jZSBiZXR3ZWVuIHR3b1xuICogbm9kZXMgYGFgIGFuZCBgYmAuIEJ5IGRlZmF1bHQgdGhpcyBpcyBzZXQgdG8gcmV0dXJuIGdyYXBoLXRoZW9yZXRpY2FsIGRpc3RhbmNlIChhbHdheXMgMSk7XG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMub3JpZW50ZWQgLSB3aGV0aGVyIGdyYXBoIHNob3VsZCBiZSBjb25zaWRlcmVkIG9yaWVudGVkIG9yIG5vdC5cbiAqIFxuICogQHJldHVybnMge09iamVjdH0gQSBwYXRoZmluZGVyIHdpdGggc2luZ2xlIG1ldGhvZCBgZmluZCgpYC5cbiAqL1xuZnVuY3Rpb24gYVN0YXJCaShncmFwaCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgLy8gd2hldGhlciB0cmF2ZXJzYWwgc2hvdWxkIGJlIGNvbnNpZGVyZWQgb3ZlciBvcmllbnRlZCBncmFwaC5cbiAgdmFyIG9yaWVudGVkID0gb3B0aW9ucy5vcmllbnRlZDtcblxuICB2YXIgaGV1cmlzdGljID0gb3B0aW9ucy5oZXVyaXN0aWM7XG4gIGlmICghaGV1cmlzdGljKSBoZXVyaXN0aWMgPSBkZWZhdWx0U2V0dGluZ3MuaGV1cmlzdGljO1xuXG4gIHZhciBkaXN0YW5jZSA9IG9wdGlvbnMuZGlzdGFuY2U7XG4gIGlmICghZGlzdGFuY2UpIGRpc3RhbmNlID0gZGVmYXVsdFNldHRpbmdzLmRpc3RhbmNlO1xuICB2YXIgcG9vbCA9IG1ha2VTZWFyY2hTdGF0ZVBvb2woKTtcblxuICByZXR1cm4ge1xuICAgIGZpbmQ6IGZpbmRcbiAgfTtcblxuICBmdW5jdGlvbiBmaW5kKGZyb21JZCwgdG9JZCkge1xuICAgIC8vIE5vdCBzdXJlIGlmIHdlIHNob3VsZCByZXR1cm4gTk9fUEFUSCBvciB0aHJvdy4gVGhyb3cgc2VlbSB0byBiZSBtb3JlXG4gICAgLy8gaGVscGZ1bCB0byBkZWJ1ZyBlcnJvcnMuIFNvLCB0aHJvd2luZy5cbiAgICB2YXIgZnJvbSA9IGdyYXBoLmdldE5vZGUoZnJvbUlkKTtcbiAgICBpZiAoIWZyb20pIHRocm93IG5ldyBFcnJvcignZnJvbUlkIGlzIG5vdCBkZWZpbmVkIGluIHRoaXMgZ3JhcGg6ICcgKyBmcm9tSWQpO1xuICAgIHZhciB0byA9IGdyYXBoLmdldE5vZGUodG9JZCk7XG4gICAgaWYgKCF0bykgdGhyb3cgbmV3IEVycm9yKCd0b0lkIGlzIG5vdCBkZWZpbmVkIGluIHRoaXMgZ3JhcGg6ICcgKyB0b0lkKTtcblxuICAgIGlmIChmcm9tID09PSB0bykgcmV0dXJuIFtmcm9tXTsgLy8gdHJpdmlhbCBjYXNlLlxuXG4gICAgcG9vbC5yZXNldCgpO1xuXG4gICAgdmFyIGNhbGxWaXNpdG9yID0gb3JpZW50ZWQgPyBvcmllbnRlZFZpc2l0b3IgOiBub25PcmllbnRlZFZpc2l0b3I7XG5cbiAgICAvLyBNYXBzIG5vZGVJZCB0byBOb2RlU2VhcmNoU3RhdGUuXG4gICAgdmFyIG5vZGVTdGF0ZSA9IG5ldyBNYXAoKTtcblxuICAgIHZhciBvcGVuU2V0RnJvbSA9IG5ldyBOb2RlSGVhcCh7XG4gICAgICBjb21wYXJlOiBkZWZhdWx0U2V0dGluZ3MuY29tcGFyZUZTY29yZSxcbiAgICAgIHNldE5vZGVJZDogZGVmYXVsdFNldHRpbmdzLnNldEhlYXBJbmRleFxuICAgIH0pO1xuXG4gICAgdmFyIG9wZW5TZXRUbyA9IG5ldyBOb2RlSGVhcCh7XG4gICAgICBjb21wYXJlOiBkZWZhdWx0U2V0dGluZ3MuY29tcGFyZUZTY29yZSxcbiAgICAgIHNldE5vZGVJZDogZGVmYXVsdFNldHRpbmdzLnNldEhlYXBJbmRleFxuICAgIH0pO1xuXG5cbiAgICB2YXIgc3RhcnROb2RlID0gcG9vbC5jcmVhdGVOZXdTdGF0ZShmcm9tKTtcbiAgICBub2RlU3RhdGUuc2V0KGZyb21JZCwgc3RhcnROb2RlKTtcblxuICAgIC8vIEZvciB0aGUgZmlyc3Qgbm9kZSwgZlNjb3JlIGlzIGNvbXBsZXRlbHkgaGV1cmlzdGljLlxuICAgIHN0YXJ0Tm9kZS5mU2NvcmUgPSBoZXVyaXN0aWMoZnJvbSwgdG8pO1xuICAgIC8vIFRoZSBjb3N0IG9mIGdvaW5nIGZyb20gc3RhcnQgdG8gc3RhcnQgaXMgemVyby5cbiAgICBzdGFydE5vZGUuZGlzdGFuY2VUb1NvdXJjZSA9IDA7XG4gICAgb3BlblNldEZyb20ucHVzaChzdGFydE5vZGUpO1xuICAgIHN0YXJ0Tm9kZS5vcGVuID0gQllfRlJPTTtcblxuICAgIHZhciBlbmROb2RlID0gcG9vbC5jcmVhdGVOZXdTdGF0ZSh0byk7XG4gICAgZW5kTm9kZS5mU2NvcmUgPSBoZXVyaXN0aWModG8sIGZyb20pO1xuICAgIGVuZE5vZGUuZGlzdGFuY2VUb1NvdXJjZSA9IDA7XG4gICAgb3BlblNldFRvLnB1c2goZW5kTm9kZSk7XG4gICAgZW5kTm9kZS5vcGVuID0gQllfVE87XG5cbiAgICAvLyBDb3N0IG9mIHRoZSBiZXN0IHNvbHV0aW9uIGZvdW5kIHNvIGZhci4gVXNlZCBmb3IgYWNjdXJhdGUgdGVybWluYXRpb25cbiAgICB2YXIgbE1pbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICB2YXIgbWluRnJvbTtcbiAgICB2YXIgbWluVG87XG5cbiAgICB2YXIgY3VycmVudFNldCA9IG9wZW5TZXRGcm9tO1xuICAgIHZhciBjdXJyZW50T3BlbmVyID0gQllfRlJPTTtcblxuICAgIHdoaWxlIChvcGVuU2V0RnJvbS5sZW5ndGggPiAwICYmIG9wZW5TZXRUby5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAob3BlblNldEZyb20ubGVuZ3RoIDwgb3BlblNldFRvLmxlbmd0aCkge1xuICAgICAgICAvLyB3ZSBwaWNrIGEgc2V0IHdpdGggbGVzcyBlbGVtZW50c1xuICAgICAgICBjdXJyZW50T3BlbmVyID0gQllfRlJPTTtcbiAgICAgICAgY3VycmVudFNldCA9IG9wZW5TZXRGcm9tO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudE9wZW5lciA9IEJZX1RPO1xuICAgICAgICBjdXJyZW50U2V0ID0gb3BlblNldFRvO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3VycmVudCA9IGN1cnJlbnRTZXQucG9wKCk7XG5cbiAgICAgIC8vIG5vIG5lZWQgdG8gdmlzaXQgdGhpcyBub2RlIGFueW1vcmVcbiAgICAgIGN1cnJlbnQuY2xvc2VkID0gdHJ1ZTtcblxuICAgICAgaWYgKGN1cnJlbnQuZGlzdGFuY2VUb1NvdXJjZSA+IGxNaW4pIGNvbnRpbnVlO1xuXG4gICAgICBncmFwaC5mb3JFYWNoTGlua2VkTm9kZShjdXJyZW50Lm5vZGUuaWQsIGNhbGxWaXNpdG9yKTtcblxuICAgICAgaWYgKG1pbkZyb20gJiYgbWluVG8pIHtcbiAgICAgICAgLy8gVGhpcyBpcyBub3QgbmVjZXNzYXJ5IHRoZSBiZXN0IHBhdGgsIGJ1dCB3ZSBhcmUgc28gZ3JlZWR5IHRoYXQgd2VcbiAgICAgICAgLy8gY2FuJ3QgcmVzaXN0OlxuICAgICAgICByZXR1cm4gcmVjb25zdHJ1Y3RCaURpcmVjdGlvbmFsUGF0aChtaW5Gcm9tLCBtaW5Ubyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIE5PX1BBVEg7IC8vIE5vIHBhdGguXG5cbiAgICBmdW5jdGlvbiBub25PcmllbnRlZFZpc2l0b3Iob3RoZXJOb2RlLCBsaW5rKSB7XG4gICAgICByZXR1cm4gdmlzaXROb2RlKG90aGVyTm9kZSwgbGluaywgY3VycmVudCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb3JpZW50ZWRWaXNpdG9yKG90aGVyTm9kZSwgbGluaykge1xuICAgICAgLy8gRm9yIG9yaXRuZWQgZ3JhcGhzIHdlIG5lZWQgdG8gcmV2ZXJzZSBncmFwaCwgd2hlbiB0cmF2ZWxpbmdcbiAgICAgIC8vIGJhY2t3YXJkcy4gU28sIHdlIHVzZSBub24tb3JpZW50ZWQgbmdyYXBoJ3MgdHJhdmVyc2FsLCBhbmQgXG4gICAgICAvLyBmaWx0ZXIgbGluayBvcmllbnRhdGlvbiBoZXJlLlxuICAgICAgaWYgKGN1cnJlbnRPcGVuZXIgPT09IEJZX0ZST00pIHtcbiAgICAgICAgaWYgKGxpbmsuZnJvbUlkID09PSBjdXJyZW50Lm5vZGUuaWQpIHJldHVybiB2aXNpdE5vZGUob3RoZXJOb2RlLCBsaW5rLCBjdXJyZW50KVxuICAgICAgfSBlbHNlIGlmIChjdXJyZW50T3BlbmVyID09PSBCWV9UTykge1xuICAgICAgICBpZiAobGluay50b0lkID09PSBjdXJyZW50Lm5vZGUuaWQpIHJldHVybiB2aXNpdE5vZGUob3RoZXJOb2RlLCBsaW5rLCBjdXJyZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5FeGl0KGN1cnJlbnROb2RlKSB7XG4gICAgICB2YXIgb3BlbmVyID0gY3VycmVudE5vZGUub3BlblxuICAgICAgaWYgKG9wZW5lciAmJiBvcGVuZXIgIT09IGN1cnJlbnRPcGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWNvbnN0cnVjdEJpRGlyZWN0aW9uYWxQYXRoKGEsIGIpIHtcbiAgICAgIHZhciBwYXRoT2ZOb2RlcyA9IFtdO1xuICAgICAgdmFyIGFQYXJlbnQgPSBhO1xuICAgICAgd2hpbGUoYVBhcmVudCkge1xuICAgICAgICBwYXRoT2ZOb2Rlcy5wdXNoKGFQYXJlbnQubm9kZSk7XG4gICAgICAgIGFQYXJlbnQgPSBhUGFyZW50LnBhcmVudDtcbiAgICAgIH1cbiAgICAgIHZhciBiUGFyZW50ID0gYjtcbiAgICAgIHdoaWxlIChiUGFyZW50KSB7XG4gICAgICAgIHBhdGhPZk5vZGVzLnVuc2hpZnQoYlBhcmVudC5ub2RlKTtcbiAgICAgICAgYlBhcmVudCA9IGJQYXJlbnQucGFyZW50XG4gICAgICB9XG4gICAgICByZXR1cm4gcGF0aE9mTm9kZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmlzaXROb2RlKG90aGVyTm9kZSwgbGluaywgY2FtZUZyb20pIHtcbiAgICAgIHZhciBvdGhlclNlYXJjaFN0YXRlID0gbm9kZVN0YXRlLmdldChvdGhlck5vZGUuaWQpO1xuICAgICAgaWYgKCFvdGhlclNlYXJjaFN0YXRlKSB7XG4gICAgICAgIG90aGVyU2VhcmNoU3RhdGUgPSBwb29sLmNyZWF0ZU5ld1N0YXRlKG90aGVyTm9kZSk7XG4gICAgICAgIG5vZGVTdGF0ZS5zZXQob3RoZXJOb2RlLmlkLCBvdGhlclNlYXJjaFN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG90aGVyU2VhcmNoU3RhdGUuY2xvc2VkKSB7XG4gICAgICAgIC8vIEFscmVhZHkgcHJvY2Vzc2VkIHRoaXMgbm9kZS5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FuRXhpdChvdGhlclNlYXJjaFN0YXRlLCBjYW1lRnJvbSkpIHtcbiAgICAgICAgLy8gdGhpcyBub2RlIHdhcyBvcGVuZWQgYnkgYWx0ZXJuYXRpdmUgb3BlbmVyLiBUaGUgc2V0cyBpbnRlcnNlY3Qgbm93LFxuICAgICAgICAvLyB3ZSBmb3VuZCBhbiBvcHRpbWFsIHBhdGgsIHRoYXQgZ29lcyB0aHJvdWdoICp0aGlzKiBub2RlLiBIb3dldmVyLCB0aGVyZVxuICAgICAgICAvLyBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGlzIGlzIHRoZSBnbG9iYWwgb3B0aW1hbCBzb2x1dGlvbiBwYXRoLlxuXG4gICAgICAgIHZhciBwb3RlbnRpYWxMTWluID0gb3RoZXJTZWFyY2hTdGF0ZS5kaXN0YW5jZVRvU291cmNlICsgY2FtZUZyb20uZGlzdGFuY2VUb1NvdXJjZTtcbiAgICAgICAgaWYgKHBvdGVudGlhbExNaW4gPCBsTWluKSB7XG4gICAgICAgICAgbWluRnJvbSA9IG90aGVyU2VhcmNoU3RhdGU7XG4gICAgICAgICAgbWluVG8gPSBjYW1lRnJvbVxuICAgICAgICAgIGxNaW4gPSBwb3RlbnRpYWxMTWluO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIGFyZSBkb25lIHdpdGggdGhpcyBub2RlLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0ZW50YXRpdmVEaXN0YW5jZSA9IGNhbWVGcm9tLmRpc3RhbmNlVG9Tb3VyY2UgKyBkaXN0YW5jZShvdGhlclNlYXJjaFN0YXRlLm5vZGUsIGNhbWVGcm9tLm5vZGUsIGxpbmspO1xuXG4gICAgICBpZiAodGVudGF0aXZlRGlzdGFuY2UgPj0gb3RoZXJTZWFyY2hTdGF0ZS5kaXN0YW5jZVRvU291cmNlKSB7XG4gICAgICAgIC8vIFRoaXMgd291bGQgb25seSBtYWtlIG91ciBwYXRoIGxvbmdlci4gSWdub3JlIHRoaXMgcm91dGUuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hvb3NlIHRhcmdldCBiYXNlZCBvbiBjdXJyZW50IHdvcmtpbmcgc2V0OlxuICAgICAgdmFyIHRhcmdldCA9IChjdXJyZW50T3BlbmVyID09PSBCWV9GUk9NKSA/IHRvIDogZnJvbTtcbiAgICAgIHZhciBuZXdGU2NvcmUgPSB0ZW50YXRpdmVEaXN0YW5jZSArIGhldXJpc3RpYyhvdGhlclNlYXJjaFN0YXRlLm5vZGUsIHRhcmdldCk7XG4gICAgICBpZiAobmV3RlNjb3JlID49IGxNaW4pIHtcbiAgICAgICAgLy8gdGhpcyBjYW4ndCBiZSBvcHRpbWFsIHBhdGgsIGFzIHdlIGhhdmUgYWxyZWFkeSBmb3VuZCBhIHNob3J0ZXIgcGF0aC5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgb3RoZXJTZWFyY2hTdGF0ZS5mU2NvcmUgPSBuZXdGU2NvcmU7XG5cbiAgICAgIGlmIChvdGhlclNlYXJjaFN0YXRlLm9wZW4gPT09IDApIHtcbiAgICAgICAgLy8gUmVtZW1iZXIgdGhpcyBub2RlIGluIHRoZSBjdXJyZW50IHNldFxuICAgICAgICBjdXJyZW50U2V0LnB1c2gob3RoZXJTZWFyY2hTdGF0ZSk7XG4gICAgICAgIGN1cnJlbnRTZXQudXBkYXRlSXRlbShvdGhlclNlYXJjaFN0YXRlLmhlYXBJbmRleCk7XG5cbiAgICAgICAgb3RoZXJTZWFyY2hTdGF0ZS5vcGVuID0gY3VycmVudE9wZW5lcjtcbiAgICAgIH1cblxuICAgICAgLy8gYmluZ28hIHdlIGZvdW5kIHNob3J0ZXIgcGF0aDpcbiAgICAgIG90aGVyU2VhcmNoU3RhdGUucGFyZW50ID0gY2FtZUZyb207XG4gICAgICBvdGhlclNlYXJjaFN0YXRlLmRpc3RhbmNlVG9Tb3VyY2UgPSB0ZW50YXRpdmVEaXN0YW5jZTtcbiAgICB9XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ngraph.path/a-star/a-greedy-star.js\n");

/***/ }),

/***/ "../node_modules/ngraph.path/a-star/a-star.js":
/*!****************************************************!*\
  !*** ../node_modules/ngraph.path/a-star/a-star.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Performs a uni-directional A Star search on graph.\n * \n * We will try to minimize f(n) = g(n) + h(n), where\n * g(n) is actual distance from source node to `n`, and\n * h(n) is heuristic distance from `n` to target node.\n */\nmodule.exports = aStarPathSearch;\n\nvar NodeHeap = __webpack_require__(/*! ./NodeHeap */ \"../node_modules/ngraph.path/a-star/NodeHeap.js\");\nvar makeSearchStatePool = __webpack_require__(/*! ./makeSearchStatePool */ \"../node_modules/ngraph.path/a-star/makeSearchStatePool.js\");\nvar heuristics = __webpack_require__(/*! ./heuristics */ \"../node_modules/ngraph.path/a-star/heuristics.js\");\nvar defaultSettings = __webpack_require__(/*! ./defaultSettings.js */ \"../node_modules/ngraph.path/a-star/defaultSettings.js\");\n\nvar NO_PATH = defaultSettings.NO_PATH;\n\nmodule.exports.l2 = heuristics.l2;\nmodule.exports.l1 = heuristics.l1;\n\n/**\n * Creates a new instance of pathfinder. A pathfinder has just one method:\n * `find(fromId, toId)`, it may be extended in future.\n * \n * @param {ngraph.graph} graph instance. See https://github.com/anvaka/ngraph.graph\n * @param {Object} options that configures search\n * @param {Function(a, b)} options.heuristic - a function that returns estimated distance between\n * nodes `a` and `b`. This function should never overestimate actual distance between two\n * nodes (otherwise the found path will not be the shortest). Defaults function returns 0,\n * which makes this search equivalent to Dijkstra search.\n * @param {Function(a, b)} options.distance - a function that returns actual distance between two\n * nodes `a` and `b`. By default this is set to return graph-theoretical distance (always 1);\n * @param {Boolean} options.oriented - whether graph should be considered oriented or not.\n * \n * @returns {Object} A pathfinder with single method `find()`.\n */\nfunction aStarPathSearch(graph, options) {\n  options = options || {};\n  // whether traversal should be considered over oriented graph.\n  var oriented = options.oriented;\n\n  var heuristic = options.heuristic;\n  if (!heuristic) heuristic = defaultSettings.heuristic;\n\n  var distance = options.distance;\n  if (!distance) distance = defaultSettings.distance;\n  var pool = makeSearchStatePool();\n\n  return {\n    /**\n     * Finds a path between node `fromId` and `toId`.\n     * @returns {Array} of nodes between `toId` and `fromId`. Empty array is returned\n     * if no path is found.\n     */\n    find: find\n  };\n\n  function find(fromId, toId) {\n    var from = graph.getNode(fromId);\n    if (!from) throw new Error('fromId is not defined in this graph: ' + fromId);\n    var to = graph.getNode(toId);\n    if (!to) throw new Error('toId is not defined in this graph: ' + toId);\n    pool.reset();\n\n    // Maps nodeId to NodeSearchState.\n    var nodeState = new Map();\n\n    // the nodes that we still need to evaluate\n    var openSet = new NodeHeap({\n      compare: defaultSettings.compareFScore,\n      setNodeId: defaultSettings.setHeapIndex\n    });\n\n    var startNode = pool.createNewState(from);\n    nodeState.set(fromId, startNode);\n\n    // For the first node, fScore is completely heuristic.\n    startNode.fScore = heuristic(from, to);\n\n    // The cost of going from start to start is zero.\n    startNode.distanceToSource = 0;\n    openSet.push(startNode);\n    startNode.open = 1;\n\n    var cameFrom;\n\n    while (openSet.length > 0) {\n      cameFrom = openSet.pop();\n      if (goalReached(cameFrom, to)) return reconstructPath(cameFrom);\n\n      // no need to visit this node anymore\n      cameFrom.closed = true;\n      graph.forEachLinkedNode(cameFrom.node.id, visitNeighbour, oriented);\n    }\n\n    // If we got here, then there is no path.\n    return NO_PATH;\n\n    function visitNeighbour(otherNode, link) {\n      var otherSearchState = nodeState.get(otherNode.id);\n      if (!otherSearchState) {\n        otherSearchState = pool.createNewState(otherNode);\n        nodeState.set(otherNode.id, otherSearchState);\n      }\n\n      if (otherSearchState.closed) {\n        // Already processed this node.\n        return;\n      }\n      if (otherSearchState.open === 0) {\n        // Remember this node.\n        openSet.push(otherSearchState);\n        otherSearchState.open = 1;\n      }\n\n      var tentativeDistance = cameFrom.distanceToSource + distance(otherNode, cameFrom.node, link);\n      if (tentativeDistance >= otherSearchState.distanceToSource) {\n        // This would only make our path longer. Ignore this route.\n        return;\n      }\n\n      // bingo! we found shorter path:\n      otherSearchState.parent = cameFrom;\n      otherSearchState.distanceToSource = tentativeDistance;\n      otherSearchState.fScore = tentativeDistance + heuristic(otherSearchState.node, to);\n\n      openSet.updateItem(otherSearchState.heapIndex);\n    }\n  }\n}\n\nfunction goalReached(searchState, targetNode) {\n  return searchState.node === targetNode;\n}\n\nfunction reconstructPath(searchState) {\n  var path = [searchState.node];\n  var parent = searchState.parent;\n\n  while (parent) {\n    path.push(parent.node);\n    parent = parent.parent;\n  }\n\n  return path;\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL25ncmFwaC5wYXRoL2Etc3Rhci9hLXN0YXIuanM/NWNlOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsbUJBQU8sQ0FBQyxrRUFBWTtBQUNuQywwQkFBMEIsbUJBQU8sQ0FBQyx3RkFBdUI7QUFDekQsaUJBQWlCLG1CQUFPLENBQUMsc0VBQWM7QUFDdkMsc0JBQXNCLG1CQUFPLENBQUMsbUZBQXNCOztBQUVwRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsT0FBTztBQUNsQixXQUFXLGVBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwiZmlsZSI6Ii4uL25vZGVfbW9kdWxlcy9uZ3JhcGgucGF0aC9hLXN0YXIvYS1zdGFyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQZXJmb3JtcyBhIHVuaS1kaXJlY3Rpb25hbCBBIFN0YXIgc2VhcmNoIG9uIGdyYXBoLlxuICogXG4gKiBXZSB3aWxsIHRyeSB0byBtaW5pbWl6ZSBmKG4pID0gZyhuKSArIGgobiksIHdoZXJlXG4gKiBnKG4pIGlzIGFjdHVhbCBkaXN0YW5jZSBmcm9tIHNvdXJjZSBub2RlIHRvIGBuYCwgYW5kXG4gKiBoKG4pIGlzIGhldXJpc3RpYyBkaXN0YW5jZSBmcm9tIGBuYCB0byB0YXJnZXQgbm9kZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBhU3RhclBhdGhTZWFyY2g7XG5cbnZhciBOb2RlSGVhcCA9IHJlcXVpcmUoJy4vTm9kZUhlYXAnKTtcbnZhciBtYWtlU2VhcmNoU3RhdGVQb29sID0gcmVxdWlyZSgnLi9tYWtlU2VhcmNoU3RhdGVQb29sJyk7XG52YXIgaGV1cmlzdGljcyA9IHJlcXVpcmUoJy4vaGV1cmlzdGljcycpO1xudmFyIGRlZmF1bHRTZXR0aW5ncyA9IHJlcXVpcmUoJy4vZGVmYXVsdFNldHRpbmdzLmpzJyk7XG5cbnZhciBOT19QQVRIID0gZGVmYXVsdFNldHRpbmdzLk5PX1BBVEg7XG5cbm1vZHVsZS5leHBvcnRzLmwyID0gaGV1cmlzdGljcy5sMjtcbm1vZHVsZS5leHBvcnRzLmwxID0gaGV1cmlzdGljcy5sMTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHBhdGhmaW5kZXIuIEEgcGF0aGZpbmRlciBoYXMganVzdCBvbmUgbWV0aG9kOlxuICogYGZpbmQoZnJvbUlkLCB0b0lkKWAsIGl0IG1heSBiZSBleHRlbmRlZCBpbiBmdXR1cmUuXG4gKiBcbiAqIEBwYXJhbSB7bmdyYXBoLmdyYXBofSBncmFwaCBpbnN0YW5jZS4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbnZha2EvbmdyYXBoLmdyYXBoXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGF0IGNvbmZpZ3VyZXMgc2VhcmNoXG4gKiBAcGFyYW0ge0Z1bmN0aW9uKGEsIGIpfSBvcHRpb25zLmhldXJpc3RpYyAtIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGVzdGltYXRlZCBkaXN0YW5jZSBiZXR3ZWVuXG4gKiBub2RlcyBgYWAgYW5kIGBiYC4gVGhpcyBmdW5jdGlvbiBzaG91bGQgbmV2ZXIgb3ZlcmVzdGltYXRlIGFjdHVhbCBkaXN0YW5jZSBiZXR3ZWVuIHR3b1xuICogbm9kZXMgKG90aGVyd2lzZSB0aGUgZm91bmQgcGF0aCB3aWxsIG5vdCBiZSB0aGUgc2hvcnRlc3QpLiBEZWZhdWx0cyBmdW5jdGlvbiByZXR1cm5zIDAsXG4gKiB3aGljaCBtYWtlcyB0aGlzIHNlYXJjaCBlcXVpdmFsZW50IHRvIERpamtzdHJhIHNlYXJjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb24oYSwgYil9IG9wdGlvbnMuZGlzdGFuY2UgLSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhY3R1YWwgZGlzdGFuY2UgYmV0d2VlbiB0d29cbiAqIG5vZGVzIGBhYCBhbmQgYGJgLiBCeSBkZWZhdWx0IHRoaXMgaXMgc2V0IHRvIHJldHVybiBncmFwaC10aGVvcmV0aWNhbCBkaXN0YW5jZSAoYWx3YXlzIDEpO1xuICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLm9yaWVudGVkIC0gd2hldGhlciBncmFwaCBzaG91bGQgYmUgY29uc2lkZXJlZCBvcmllbnRlZCBvciBub3QuXG4gKiBcbiAqIEByZXR1cm5zIHtPYmplY3R9IEEgcGF0aGZpbmRlciB3aXRoIHNpbmdsZSBtZXRob2QgYGZpbmQoKWAuXG4gKi9cbmZ1bmN0aW9uIGFTdGFyUGF0aFNlYXJjaChncmFwaCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgLy8gd2hldGhlciB0cmF2ZXJzYWwgc2hvdWxkIGJlIGNvbnNpZGVyZWQgb3ZlciBvcmllbnRlZCBncmFwaC5cbiAgdmFyIG9yaWVudGVkID0gb3B0aW9ucy5vcmllbnRlZDtcblxuICB2YXIgaGV1cmlzdGljID0gb3B0aW9ucy5oZXVyaXN0aWM7XG4gIGlmICghaGV1cmlzdGljKSBoZXVyaXN0aWMgPSBkZWZhdWx0U2V0dGluZ3MuaGV1cmlzdGljO1xuXG4gIHZhciBkaXN0YW5jZSA9IG9wdGlvbnMuZGlzdGFuY2U7XG4gIGlmICghZGlzdGFuY2UpIGRpc3RhbmNlID0gZGVmYXVsdFNldHRpbmdzLmRpc3RhbmNlO1xuICB2YXIgcG9vbCA9IG1ha2VTZWFyY2hTdGF0ZVBvb2woKTtcblxuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIEZpbmRzIGEgcGF0aCBiZXR3ZWVuIG5vZGUgYGZyb21JZGAgYW5kIGB0b0lkYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IG9mIG5vZGVzIGJldHdlZW4gYHRvSWRgIGFuZCBgZnJvbUlkYC4gRW1wdHkgYXJyYXkgaXMgcmV0dXJuZWRcbiAgICAgKiBpZiBubyBwYXRoIGlzIGZvdW5kLlxuICAgICAqL1xuICAgIGZpbmQ6IGZpbmRcbiAgfTtcblxuICBmdW5jdGlvbiBmaW5kKGZyb21JZCwgdG9JZCkge1xuICAgIHZhciBmcm9tID0gZ3JhcGguZ2V0Tm9kZShmcm9tSWQpO1xuICAgIGlmICghZnJvbSkgdGhyb3cgbmV3IEVycm9yKCdmcm9tSWQgaXMgbm90IGRlZmluZWQgaW4gdGhpcyBncmFwaDogJyArIGZyb21JZCk7XG4gICAgdmFyIHRvID0gZ3JhcGguZ2V0Tm9kZSh0b0lkKTtcbiAgICBpZiAoIXRvKSB0aHJvdyBuZXcgRXJyb3IoJ3RvSWQgaXMgbm90IGRlZmluZWQgaW4gdGhpcyBncmFwaDogJyArIHRvSWQpO1xuICAgIHBvb2wucmVzZXQoKTtcblxuICAgIC8vIE1hcHMgbm9kZUlkIHRvIE5vZGVTZWFyY2hTdGF0ZS5cbiAgICB2YXIgbm9kZVN0YXRlID0gbmV3IE1hcCgpO1xuXG4gICAgLy8gdGhlIG5vZGVzIHRoYXQgd2Ugc3RpbGwgbmVlZCB0byBldmFsdWF0ZVxuICAgIHZhciBvcGVuU2V0ID0gbmV3IE5vZGVIZWFwKHtcbiAgICAgIGNvbXBhcmU6IGRlZmF1bHRTZXR0aW5ncy5jb21wYXJlRlNjb3JlLFxuICAgICAgc2V0Tm9kZUlkOiBkZWZhdWx0U2V0dGluZ3Muc2V0SGVhcEluZGV4XG4gICAgfSk7XG5cbiAgICB2YXIgc3RhcnROb2RlID0gcG9vbC5jcmVhdGVOZXdTdGF0ZShmcm9tKTtcbiAgICBub2RlU3RhdGUuc2V0KGZyb21JZCwgc3RhcnROb2RlKTtcblxuICAgIC8vIEZvciB0aGUgZmlyc3Qgbm9kZSwgZlNjb3JlIGlzIGNvbXBsZXRlbHkgaGV1cmlzdGljLlxuICAgIHN0YXJ0Tm9kZS5mU2NvcmUgPSBoZXVyaXN0aWMoZnJvbSwgdG8pO1xuXG4gICAgLy8gVGhlIGNvc3Qgb2YgZ29pbmcgZnJvbSBzdGFydCB0byBzdGFydCBpcyB6ZXJvLlxuICAgIHN0YXJ0Tm9kZS5kaXN0YW5jZVRvU291cmNlID0gMDtcbiAgICBvcGVuU2V0LnB1c2goc3RhcnROb2RlKTtcbiAgICBzdGFydE5vZGUub3BlbiA9IDE7XG5cbiAgICB2YXIgY2FtZUZyb207XG5cbiAgICB3aGlsZSAob3BlblNldC5sZW5ndGggPiAwKSB7XG4gICAgICBjYW1lRnJvbSA9IG9wZW5TZXQucG9wKCk7XG4gICAgICBpZiAoZ29hbFJlYWNoZWQoY2FtZUZyb20sIHRvKSkgcmV0dXJuIHJlY29uc3RydWN0UGF0aChjYW1lRnJvbSk7XG5cbiAgICAgIC8vIG5vIG5lZWQgdG8gdmlzaXQgdGhpcyBub2RlIGFueW1vcmVcbiAgICAgIGNhbWVGcm9tLmNsb3NlZCA9IHRydWU7XG4gICAgICBncmFwaC5mb3JFYWNoTGlua2VkTm9kZShjYW1lRnJvbS5ub2RlLmlkLCB2aXNpdE5laWdoYm91ciwgb3JpZW50ZWQpO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGdvdCBoZXJlLCB0aGVuIHRoZXJlIGlzIG5vIHBhdGguXG4gICAgcmV0dXJuIE5PX1BBVEg7XG5cbiAgICBmdW5jdGlvbiB2aXNpdE5laWdoYm91cihvdGhlck5vZGUsIGxpbmspIHtcbiAgICAgIHZhciBvdGhlclNlYXJjaFN0YXRlID0gbm9kZVN0YXRlLmdldChvdGhlck5vZGUuaWQpO1xuICAgICAgaWYgKCFvdGhlclNlYXJjaFN0YXRlKSB7XG4gICAgICAgIG90aGVyU2VhcmNoU3RhdGUgPSBwb29sLmNyZWF0ZU5ld1N0YXRlKG90aGVyTm9kZSk7XG4gICAgICAgIG5vZGVTdGF0ZS5zZXQob3RoZXJOb2RlLmlkLCBvdGhlclNlYXJjaFN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG90aGVyU2VhcmNoU3RhdGUuY2xvc2VkKSB7XG4gICAgICAgIC8vIEFscmVhZHkgcHJvY2Vzc2VkIHRoaXMgbm9kZS5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG90aGVyU2VhcmNoU3RhdGUub3BlbiA9PT0gMCkge1xuICAgICAgICAvLyBSZW1lbWJlciB0aGlzIG5vZGUuXG4gICAgICAgIG9wZW5TZXQucHVzaChvdGhlclNlYXJjaFN0YXRlKTtcbiAgICAgICAgb3RoZXJTZWFyY2hTdGF0ZS5vcGVuID0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRlbnRhdGl2ZURpc3RhbmNlID0gY2FtZUZyb20uZGlzdGFuY2VUb1NvdXJjZSArIGRpc3RhbmNlKG90aGVyTm9kZSwgY2FtZUZyb20ubm9kZSwgbGluayk7XG4gICAgICBpZiAodGVudGF0aXZlRGlzdGFuY2UgPj0gb3RoZXJTZWFyY2hTdGF0ZS5kaXN0YW5jZVRvU291cmNlKSB7XG4gICAgICAgIC8vIFRoaXMgd291bGQgb25seSBtYWtlIG91ciBwYXRoIGxvbmdlci4gSWdub3JlIHRoaXMgcm91dGUuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gYmluZ28hIHdlIGZvdW5kIHNob3J0ZXIgcGF0aDpcbiAgICAgIG90aGVyU2VhcmNoU3RhdGUucGFyZW50ID0gY2FtZUZyb207XG4gICAgICBvdGhlclNlYXJjaFN0YXRlLmRpc3RhbmNlVG9Tb3VyY2UgPSB0ZW50YXRpdmVEaXN0YW5jZTtcbiAgICAgIG90aGVyU2VhcmNoU3RhdGUuZlNjb3JlID0gdGVudGF0aXZlRGlzdGFuY2UgKyBoZXVyaXN0aWMob3RoZXJTZWFyY2hTdGF0ZS5ub2RlLCB0byk7XG5cbiAgICAgIG9wZW5TZXQudXBkYXRlSXRlbShvdGhlclNlYXJjaFN0YXRlLmhlYXBJbmRleCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdvYWxSZWFjaGVkKHNlYXJjaFN0YXRlLCB0YXJnZXROb2RlKSB7XG4gIHJldHVybiBzZWFyY2hTdGF0ZS5ub2RlID09PSB0YXJnZXROb2RlO1xufVxuXG5mdW5jdGlvbiByZWNvbnN0cnVjdFBhdGgoc2VhcmNoU3RhdGUpIHtcbiAgdmFyIHBhdGggPSBbc2VhcmNoU3RhdGUubm9kZV07XG4gIHZhciBwYXJlbnQgPSBzZWFyY2hTdGF0ZS5wYXJlbnQ7XG5cbiAgd2hpbGUgKHBhcmVudCkge1xuICAgIHBhdGgucHVzaChwYXJlbnQubm9kZSk7XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgfVxuXG4gIHJldHVybiBwYXRoO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ngraph.path/a-star/a-star.js\n");

/***/ }),

/***/ "../node_modules/ngraph.path/a-star/defaultSettings.js":
/*!*************************************************************!*\
  !*** ../node_modules/ngraph.path/a-star/defaultSettings.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// We reuse instance of array, but we trie to freeze it as well,\n// so that consumers don't modify it. Maybe it's a bad idea.\nvar NO_PATH = [];\nif (typeof Object.freeze === 'function') Object.freeze(NO_PATH);\n\nmodule.exports = {\n  // Path search settings\n  heuristic: blindHeuristic,\n  distance: constantDistance,\n  compareFScore: compareFScore,\n  NO_PATH: NO_PATH,\n\n  // heap settings\n  setHeapIndex: setHeapIndex,\n\n  // nba:\n  setH1: setH1,\n  setH2: setH2,\n  compareF1Score: compareF1Score,\n  compareF2Score: compareF2Score,\n}\n\nfunction blindHeuristic(/* a, b */) {\n  // blind heuristic makes this search equal to plain Dijkstra path search.\n  return 0;\n}\n\nfunction constantDistance(/* a, b */) {\n  return 1;\n}\n\nfunction compareFScore(a, b) {\n  var result = a.fScore - b.fScore;\n  // TODO: Can I improve speed with smarter ties-breaking?\n  // I tried distanceToSource, but it didn't seem to have much effect\n  return result;\n}\n\nfunction setHeapIndex(nodeSearchState, heapIndex) {\n  nodeSearchState.heapIndex = heapIndex;\n}\n\nfunction compareF1Score(a, b) {\n  return a.f1 - b.f1;\n}\n\nfunction compareF2Score(a, b) {\n  return a.f2 - b.f2;\n}\n\nfunction setH1(node, heapIndex) {\n  node.h1 = heapIndex;\n}\n\nfunction setH2(node, heapIndex) {\n  node.h2 = heapIndex;\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL25ncmFwaC5wYXRoL2Etc3Rhci9kZWZhdWx0U2V0dGluZ3MuanM/OTg5MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6Ii4uL25vZGVfbW9kdWxlcy9uZ3JhcGgucGF0aC9hLXN0YXIvZGVmYXVsdFNldHRpbmdzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gV2UgcmV1c2UgaW5zdGFuY2Ugb2YgYXJyYXksIGJ1dCB3ZSB0cmllIHRvIGZyZWV6ZSBpdCBhcyB3ZWxsLFxuLy8gc28gdGhhdCBjb25zdW1lcnMgZG9uJ3QgbW9kaWZ5IGl0LiBNYXliZSBpdCdzIGEgYmFkIGlkZWEuXG52YXIgTk9fUEFUSCA9IFtdO1xuaWYgKHR5cGVvZiBPYmplY3QuZnJlZXplID09PSAnZnVuY3Rpb24nKSBPYmplY3QuZnJlZXplKE5PX1BBVEgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gUGF0aCBzZWFyY2ggc2V0dGluZ3NcbiAgaGV1cmlzdGljOiBibGluZEhldXJpc3RpYyxcbiAgZGlzdGFuY2U6IGNvbnN0YW50RGlzdGFuY2UsXG4gIGNvbXBhcmVGU2NvcmU6IGNvbXBhcmVGU2NvcmUsXG4gIE5PX1BBVEg6IE5PX1BBVEgsXG5cbiAgLy8gaGVhcCBzZXR0aW5nc1xuICBzZXRIZWFwSW5kZXg6IHNldEhlYXBJbmRleCxcblxuICAvLyBuYmE6XG4gIHNldEgxOiBzZXRIMSxcbiAgc2V0SDI6IHNldEgyLFxuICBjb21wYXJlRjFTY29yZTogY29tcGFyZUYxU2NvcmUsXG4gIGNvbXBhcmVGMlNjb3JlOiBjb21wYXJlRjJTY29yZSxcbn1cblxuZnVuY3Rpb24gYmxpbmRIZXVyaXN0aWMoLyogYSwgYiAqLykge1xuICAvLyBibGluZCBoZXVyaXN0aWMgbWFrZXMgdGhpcyBzZWFyY2ggZXF1YWwgdG8gcGxhaW4gRGlqa3N0cmEgcGF0aCBzZWFyY2guXG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjb25zdGFudERpc3RhbmNlKC8qIGEsIGIgKi8pIHtcbiAgcmV0dXJuIDE7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVGU2NvcmUoYSwgYikge1xuICB2YXIgcmVzdWx0ID0gYS5mU2NvcmUgLSBiLmZTY29yZTtcbiAgLy8gVE9ETzogQ2FuIEkgaW1wcm92ZSBzcGVlZCB3aXRoIHNtYXJ0ZXIgdGllcy1icmVha2luZz9cbiAgLy8gSSB0cmllZCBkaXN0YW5jZVRvU291cmNlLCBidXQgaXQgZGlkbid0IHNlZW0gdG8gaGF2ZSBtdWNoIGVmZmVjdFxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBzZXRIZWFwSW5kZXgobm9kZVNlYXJjaFN0YXRlLCBoZWFwSW5kZXgpIHtcbiAgbm9kZVNlYXJjaFN0YXRlLmhlYXBJbmRleCA9IGhlYXBJbmRleDtcbn1cblxuZnVuY3Rpb24gY29tcGFyZUYxU2NvcmUoYSwgYikge1xuICByZXR1cm4gYS5mMSAtIGIuZjE7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVGMlNjb3JlKGEsIGIpIHtcbiAgcmV0dXJuIGEuZjIgLSBiLmYyO1xufVxuXG5mdW5jdGlvbiBzZXRIMShub2RlLCBoZWFwSW5kZXgpIHtcbiAgbm9kZS5oMSA9IGhlYXBJbmRleDtcbn1cblxuZnVuY3Rpb24gc2V0SDIobm9kZSwgaGVhcEluZGV4KSB7XG4gIG5vZGUuaDIgPSBoZWFwSW5kZXg7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ngraph.path/a-star/defaultSettings.js\n");

/***/ }),

/***/ "../node_modules/ngraph.path/a-star/heuristics.js":
/*!********************************************************!*\
  !*** ../node_modules/ngraph.path/a-star/heuristics.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = {\n  l2: l2,\n  l1: l1\n};\n\n/**\n * Euclid distance (l2 norm);\n * \n * @param {*} a \n * @param {*} b \n */\nfunction l2(a, b) {\n  var dx = a.x - b.x;\n  var dy = a.y - b.y;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\n/**\n * Manhattan distance (l1 norm);\n * @param {*} a \n * @param {*} b \n */\nfunction l1(a, b) {\n  var dx = a.x - b.x;\n  var dy = a.y - b.y;\n  return Math.abs(dx) + Math.abs(dy);\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL25ncmFwaC5wYXRoL2Etc3Rhci9oZXVyaXN0aWNzLmpzP2U5YTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsV0FBVyxFQUFFO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL25ncmFwaC5wYXRoL2Etc3Rhci9oZXVyaXN0aWNzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGwyOiBsMixcbiAgbDE6IGwxXG59O1xuXG4vKipcbiAqIEV1Y2xpZCBkaXN0YW5jZSAobDIgbm9ybSk7XG4gKiBcbiAqIEBwYXJhbSB7Kn0gYSBcbiAqIEBwYXJhbSB7Kn0gYiBcbiAqL1xuZnVuY3Rpb24gbDIoYSwgYikge1xuICB2YXIgZHggPSBhLnggLSBiLng7XG4gIHZhciBkeSA9IGEueSAtIGIueTtcbiAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG59XG5cbi8qKlxuICogTWFuaGF0dGFuIGRpc3RhbmNlIChsMSBub3JtKTtcbiAqIEBwYXJhbSB7Kn0gYSBcbiAqIEBwYXJhbSB7Kn0gYiBcbiAqL1xuZnVuY3Rpb24gbDEoYSwgYikge1xuICB2YXIgZHggPSBhLnggLSBiLng7XG4gIHZhciBkeSA9IGEueSAtIGIueTtcbiAgcmV0dXJuIE1hdGguYWJzKGR4KSArIE1hdGguYWJzKGR5KTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ngraph.path/a-star/heuristics.js\n");

/***/ }),

/***/ "../node_modules/ngraph.path/a-star/makeSearchStatePool.js":
/*!*****************************************************************!*\
  !*** ../node_modules/ngraph.path/a-star/makeSearchStatePool.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * This class represents a single search node in the exploration tree for\n * A* algorithm.\n * \n * @param {Object} node  original node in the graph\n */\nfunction NodeSearchState(node) {\n  this.node = node;\n\n  // How we came to this node?\n  this.parent = null;\n\n  this.closed = false;\n  this.open = 0;\n\n  this.distanceToSource = Number.POSITIVE_INFINITY;\n  // the f(n) = g(n) + h(n) value\n  this.fScore = Number.POSITIVE_INFINITY;\n\n  // used to reconstruct heap when fScore is updated.\n  this.heapIndex = -1;\n};\n\nfunction makeSearchStatePool() {\n  var currentInCache = 0;\n  var nodeCache = [];\n\n  return {\n    createNewState: createNewState,\n    reset: reset\n  };\n\n  function reset() {\n    currentInCache = 0;\n  }\n\n  function createNewState(node) {\n    var cached = nodeCache[currentInCache];\n    if (cached) {\n      // TODO: This almost duplicates constructor code. Not sure if\n      // it would impact performance if I move this code into a function\n      cached.node = node;\n      // How we came to this node?\n      cached.parent = null;\n\n      cached.closed = false;\n      cached.open = 0;\n\n      cached.distanceToSource = Number.POSITIVE_INFINITY;\n      // the f(n) = g(n) + h(n) value\n      cached.fScore = Number.POSITIVE_INFINITY;\n\n      // used to reconstruct heap when fScore is updated.\n      cached.heapIndex = -1;\n\n    } else {\n      cached = new NodeSearchState(node);\n      nodeCache[currentInCache] = cached;\n    }\n    currentInCache++;\n    return cached;\n  }\n}\nmodule.exports = makeSearchStatePool;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL25ncmFwaC5wYXRoL2Etc3Rhci9tYWtlU2VhcmNoU3RhdGVQb29sLmpzP2YzZGEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4uL25vZGVfbW9kdWxlcy9uZ3JhcGgucGF0aC9hLXN0YXIvbWFrZVNlYXJjaFN0YXRlUG9vbC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhpcyBjbGFzcyByZXByZXNlbnRzIGEgc2luZ2xlIHNlYXJjaCBub2RlIGluIHRoZSBleHBsb3JhdGlvbiB0cmVlIGZvclxuICogQSogYWxnb3JpdGhtLlxuICogXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZSAgb3JpZ2luYWwgbm9kZSBpbiB0aGUgZ3JhcGhcbiAqL1xuZnVuY3Rpb24gTm9kZVNlYXJjaFN0YXRlKG5vZGUpIHtcbiAgdGhpcy5ub2RlID0gbm9kZTtcblxuICAvLyBIb3cgd2UgY2FtZSB0byB0aGlzIG5vZGU/XG4gIHRoaXMucGFyZW50ID0gbnVsbDtcblxuICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICB0aGlzLm9wZW4gPSAwO1xuXG4gIHRoaXMuZGlzdGFuY2VUb1NvdXJjZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgLy8gdGhlIGYobikgPSBnKG4pICsgaChuKSB2YWx1ZVxuICB0aGlzLmZTY29yZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblxuICAvLyB1c2VkIHRvIHJlY29uc3RydWN0IGhlYXAgd2hlbiBmU2NvcmUgaXMgdXBkYXRlZC5cbiAgdGhpcy5oZWFwSW5kZXggPSAtMTtcbn07XG5cbmZ1bmN0aW9uIG1ha2VTZWFyY2hTdGF0ZVBvb2woKSB7XG4gIHZhciBjdXJyZW50SW5DYWNoZSA9IDA7XG4gIHZhciBub2RlQ2FjaGUgPSBbXTtcblxuICByZXR1cm4ge1xuICAgIGNyZWF0ZU5ld1N0YXRlOiBjcmVhdGVOZXdTdGF0ZSxcbiAgICByZXNldDogcmVzZXRcbiAgfTtcblxuICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBjdXJyZW50SW5DYWNoZSA9IDA7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVOZXdTdGF0ZShub2RlKSB7XG4gICAgdmFyIGNhY2hlZCA9IG5vZGVDYWNoZVtjdXJyZW50SW5DYWNoZV07XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgLy8gVE9ETzogVGhpcyBhbG1vc3QgZHVwbGljYXRlcyBjb25zdHJ1Y3RvciBjb2RlLiBOb3Qgc3VyZSBpZlxuICAgICAgLy8gaXQgd291bGQgaW1wYWN0IHBlcmZvcm1hbmNlIGlmIEkgbW92ZSB0aGlzIGNvZGUgaW50byBhIGZ1bmN0aW9uXG4gICAgICBjYWNoZWQubm9kZSA9IG5vZGU7XG4gICAgICAvLyBIb3cgd2UgY2FtZSB0byB0aGlzIG5vZGU/XG4gICAgICBjYWNoZWQucGFyZW50ID0gbnVsbDtcblxuICAgICAgY2FjaGVkLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgY2FjaGVkLm9wZW4gPSAwO1xuXG4gICAgICBjYWNoZWQuZGlzdGFuY2VUb1NvdXJjZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgIC8vIHRoZSBmKG4pID0gZyhuKSArIGgobikgdmFsdWVcbiAgICAgIGNhY2hlZC5mU2NvcmUgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cbiAgICAgIC8vIHVzZWQgdG8gcmVjb25zdHJ1Y3QgaGVhcCB3aGVuIGZTY29yZSBpcyB1cGRhdGVkLlxuICAgICAgY2FjaGVkLmhlYXBJbmRleCA9IC0xO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIGNhY2hlZCA9IG5ldyBOb2RlU2VhcmNoU3RhdGUobm9kZSk7XG4gICAgICBub2RlQ2FjaGVbY3VycmVudEluQ2FjaGVdID0gY2FjaGVkO1xuICAgIH1cbiAgICBjdXJyZW50SW5DYWNoZSsrO1xuICAgIHJldHVybiBjYWNoZWQ7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gbWFrZVNlYXJjaFN0YXRlUG9vbDsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ngraph.path/a-star/makeSearchStatePool.js\n");

/***/ }),

/***/ "../node_modules/ngraph.path/a-star/nba/index.js":
/*!*******************************************************!*\
  !*** ../node_modules/ngraph.path/a-star/nba/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = nba;\n\nvar NodeHeap = __webpack_require__(/*! ../NodeHeap */ \"../node_modules/ngraph.path/a-star/NodeHeap.js\");\nvar heuristics = __webpack_require__(/*! ../heuristics */ \"../node_modules/ngraph.path/a-star/heuristics.js\");\nvar defaultSettings = __webpack_require__(/*! ../defaultSettings.js */ \"../node_modules/ngraph.path/a-star/defaultSettings.js\");\nvar makeNBASearchStatePool = __webpack_require__(/*! ./makeNBASearchStatePool.js */ \"../node_modules/ngraph.path/a-star/nba/makeNBASearchStatePool.js\");\n\nvar NO_PATH = defaultSettings.NO_PATH;\n\nmodule.exports.l2 = heuristics.l2;\nmodule.exports.l1 = heuristics.l1;\n\n/**\n * Creates a new instance of pathfinder. A pathfinder has just one method:\n * `find(fromId, toId)`.\n * \n * This is implementation of the NBA* algorithm described in \n * \n *  \"Yet another bidirectional algorithm for shortest paths\" paper by Wim Pijls and Henk Post\n * \n * The paper is available here: https://repub.eur.nl/pub/16100/ei2009-10.pdf\n * \n * @param {ngraph.graph} graph instance. See https://github.com/anvaka/ngraph.graph\n * @param {Object} options that configures search\n * @param {Function(a, b)} options.heuristic - a function that returns estimated distance between\n * nodes `a` and `b`. This function should never overestimate actual distance between two\n * nodes (otherwise the found path will not be the shortest). Defaults function returns 0,\n * which makes this search equivalent to Dijkstra search.\n * @param {Function(a, b)} options.distance - a function that returns actual distance between two\n * nodes `a` and `b`. By default this is set to return graph-theoretical distance (always 1);\n * \n * @returns {Object} A pathfinder with single method `find()`.\n */\nfunction nba(graph, options) {\n  options = options || {};\n  // whether traversal should be considered over oriented graph.\n  var oriented = options.oriented;\n  var quitFast = options.quitFast;\n\n  var heuristic = options.heuristic;\n  if (!heuristic) heuristic = defaultSettings.heuristic;\n\n  var distance = options.distance;\n  if (!distance) distance = defaultSettings.distance;\n\n  // During stress tests I noticed that garbage collection was one of the heaviest\n  // contributors to the algorithm's speed. So I'm using an object pool to recycle nodes.\n  var pool = makeNBASearchStatePool();\n\n  return {\n    /**\n     * Finds a path between node `fromId` and `toId`.\n     * @returns {Array} of nodes between `toId` and `fromId`. Empty array is returned\n     * if no path is found.\n     */\n    find: find\n  };\n\n  function find(fromId, toId) {\n    // I must apologize for the code duplication. This was the easiest way for me to\n    // implement the algorithm fast.\n    var from = graph.getNode(fromId);\n    if (!from) throw new Error('fromId is not defined in this graph: ' + fromId);\n    var to = graph.getNode(toId);\n    if (!to) throw new Error('toId is not defined in this graph: ' + toId);\n\n    pool.reset();\n\n    // I must also apologize for somewhat cryptic names. The NBA* is bi-directional\n    // search algorithm, which means it runs two searches in parallel. One is called\n    // forward search and it runs from source node to target, while the other one\n    // (backward search) runs from target to source.\n\n    // Everywhere where you see `1` it means it's for the forward search. `2` is for \n    // backward search.\n\n    // For oriented graph path finding, we need to reverse the graph, so that\n    // backward search visits correct link. Obviously we don't want to duplicate\n    // the graph, instead we always traverse the graph as non-oriented, and filter\n    // edges in `visitN1Oriented/visitN2Oritented`\n    var forwardVisitor = oriented ? visitN1Oriented : visitN1;\n    var reverseVisitor = oriented ? visitN2Oriented : visitN2;\n\n    // Maps nodeId to NBASearchState.\n    var nodeState = new Map();\n\n    // These two heaps store nodes by their underestimated values.\n    var open1Set = new NodeHeap({\n      compare: defaultSettings.compareF1Score,\n      setNodeId: defaultSettings.setH1\n    });\n    var open2Set = new NodeHeap({\n      compare: defaultSettings.compareF2Score,\n      setNodeId: defaultSettings.setH2\n    });\n\n    // This is where both searches will meet.\n    var minNode;\n\n    // The smallest path length seen so far is stored here:\n    var lMin = Number.POSITIVE_INFINITY;\n\n    // We start by putting start/end nodes to the corresponding heaps\n    // If variable names like `f1`, `g1` are too confusing, please refer\n    // to makeNBASearchStatePool.js file, which has detailed description.\n    var startNode = pool.createNewState(from);\n    nodeState.set(fromId, startNode); \n    startNode.g1 = 0;\n    var f1 = heuristic(from, to);\n    startNode.f1 = f1;\n    open1Set.push(startNode);\n\n    var endNode = pool.createNewState(to);\n    nodeState.set(toId, endNode);\n    endNode.g2 = 0;\n    var f2 = f1; // they should agree originally\n    endNode.f2 = f2;\n    open2Set.push(endNode)\n\n    // the `cameFrom` variable is accessed by both searches, so that we can store parents.\n    var cameFrom;\n\n    // this is the main algorithm loop:\n    while (open2Set.length && open1Set.length) {\n      if (open1Set.length < open2Set.length) {\n        forwardSearch();\n      } else {\n        reverseSearch();\n      }\n\n      if (quitFast && minNode) break;\n    }\n\n    var path = reconstructPath(minNode);\n    return path; // the public API is over\n\n    function forwardSearch() {\n      cameFrom = open1Set.pop();\n      if (cameFrom.closed) {\n        return;\n      }\n\n      cameFrom.closed = true;\n\n      if (cameFrom.f1 < lMin && (cameFrom.g1 + f2 - heuristic(from, cameFrom.node)) < lMin) {\n        graph.forEachLinkedNode(cameFrom.node.id, forwardVisitor);\n      }\n\n      if (open1Set.length > 0) {\n        // this will be used in reverse search\n        f1 = open1Set.peek().f1;\n      } \n    }\n\n    function reverseSearch() {\n      cameFrom = open2Set.pop();\n      if (cameFrom.closed) {\n        return;\n      }\n      cameFrom.closed = true;\n\n      if (cameFrom.f2 < lMin && (cameFrom.g2 + f1 - heuristic(cameFrom.node, to)) < lMin) {\n        graph.forEachLinkedNode(cameFrom.node.id, reverseVisitor);\n      }\n\n      if (open2Set.length > 0) {\n        // this will be used in forward search\n        f2 = open2Set.peek().f2;\n      }\n    }\n\n    function visitN1(otherNode, link) {\n      var otherSearchState = nodeState.get(otherNode.id);\n      if (!otherSearchState) {\n        otherSearchState = pool.createNewState(otherNode);\n        nodeState.set(otherNode.id, otherSearchState);\n      }\n\n      if (otherSearchState.closed) return;\n\n      var tentativeDistance = cameFrom.g1 + distance(cameFrom.node, otherNode, link);\n\n      if (tentativeDistance < otherSearchState.g1) {\n        otherSearchState.g1 = tentativeDistance;\n        otherSearchState.f1 = tentativeDistance + heuristic(otherSearchState.node, to);\n        otherSearchState.p1 = cameFrom;\n        if (otherSearchState.h1 < 0) {\n          open1Set.push(otherSearchState);\n        } else {\n          open1Set.updateItem(otherSearchState.h1);\n        }\n      }\n      var potentialMin = otherSearchState.g1 + otherSearchState.g2;\n      if (potentialMin < lMin) { \n        lMin = potentialMin;\n        minNode = otherSearchState;\n      }\n    }\n\n    function visitN2(otherNode, link) {\n      var otherSearchState = nodeState.get(otherNode.id);\n      if (!otherSearchState) {\n        otherSearchState = pool.createNewState(otherNode);\n        nodeState.set(otherNode.id, otherSearchState);\n      }\n\n      if (otherSearchState.closed) return;\n\n      var tentativeDistance = cameFrom.g2 + distance(cameFrom.node, otherNode, link);\n\n      if (tentativeDistance < otherSearchState.g2) {\n        otherSearchState.g2 = tentativeDistance;\n        otherSearchState.f2 = tentativeDistance + heuristic(from, otherSearchState.node);\n        otherSearchState.p2 = cameFrom;\n        if (otherSearchState.h2 < 0) {\n          open2Set.push(otherSearchState);\n        } else {\n          open2Set.updateItem(otherSearchState.h2);\n        }\n      }\n      var potentialMin = otherSearchState.g1 + otherSearchState.g2;\n      if (potentialMin < lMin) {\n        lMin = potentialMin;\n        minNode = otherSearchState;\n      }\n    }\n\n    function visitN2Oriented(otherNode, link) {\n      // we are going backwards, graph needs to be reversed. \n      if (link.toId === cameFrom.node.id) return visitN2(otherNode, link);\n    }\n    function visitN1Oriented(otherNode, link) {\n      // this is forward direction, so we should be coming FROM:\n      if (link.fromId === cameFrom.node.id) return visitN1(otherNode, link);\n    }\n  }\n}\n\nfunction reconstructPath(searchState) {\n  if (!searchState) return NO_PATH;\n\n  var path = [searchState.node];\n  var parent = searchState.p1;\n\n  while (parent) {\n    path.push(parent.node);\n    parent = parent.p1;\n  }\n\n  var child = searchState.p2;\n\n  while (child) {\n    path.unshift(child.node);\n    child = child.p2;\n  }\n  return path;\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL25ncmFwaC5wYXRoL2Etc3Rhci9uYmEvaW5kZXguanM/YTA0YiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSxlQUFlLG1CQUFPLENBQUMsbUVBQWE7QUFDcEMsaUJBQWlCLG1CQUFPLENBQUMsdUVBQWU7QUFDeEMsc0JBQXNCLG1CQUFPLENBQUMsb0ZBQXVCO0FBQ3JELDZCQUE2QixtQkFBTyxDQUFDLHFHQUE2Qjs7QUFFbEU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLE9BQU87QUFDbEIsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL25ncmFwaC5wYXRoL2Etc3Rhci9uYmEvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IG5iYTtcblxudmFyIE5vZGVIZWFwID0gcmVxdWlyZSgnLi4vTm9kZUhlYXAnKTtcbnZhciBoZXVyaXN0aWNzID0gcmVxdWlyZSgnLi4vaGV1cmlzdGljcycpO1xudmFyIGRlZmF1bHRTZXR0aW5ncyA9IHJlcXVpcmUoJy4uL2RlZmF1bHRTZXR0aW5ncy5qcycpO1xudmFyIG1ha2VOQkFTZWFyY2hTdGF0ZVBvb2wgPSByZXF1aXJlKCcuL21ha2VOQkFTZWFyY2hTdGF0ZVBvb2wuanMnKTtcblxudmFyIE5PX1BBVEggPSBkZWZhdWx0U2V0dGluZ3MuTk9fUEFUSDtcblxubW9kdWxlLmV4cG9ydHMubDIgPSBoZXVyaXN0aWNzLmwyO1xubW9kdWxlLmV4cG9ydHMubDEgPSBoZXVyaXN0aWNzLmwxO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgcGF0aGZpbmRlci4gQSBwYXRoZmluZGVyIGhhcyBqdXN0IG9uZSBtZXRob2Q6XG4gKiBgZmluZChmcm9tSWQsIHRvSWQpYC5cbiAqIFxuICogVGhpcyBpcyBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgTkJBKiBhbGdvcml0aG0gZGVzY3JpYmVkIGluIFxuICogXG4gKiAgXCJZZXQgYW5vdGhlciBiaWRpcmVjdGlvbmFsIGFsZ29yaXRobSBmb3Igc2hvcnRlc3QgcGF0aHNcIiBwYXBlciBieSBXaW0gUGlqbHMgYW5kIEhlbmsgUG9zdFxuICogXG4gKiBUaGUgcGFwZXIgaXMgYXZhaWxhYmxlIGhlcmU6IGh0dHBzOi8vcmVwdWIuZXVyLm5sL3B1Yi8xNjEwMC9laTIwMDktMTAucGRmXG4gKiBcbiAqIEBwYXJhbSB7bmdyYXBoLmdyYXBofSBncmFwaCBpbnN0YW5jZS4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbnZha2EvbmdyYXBoLmdyYXBoXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGF0IGNvbmZpZ3VyZXMgc2VhcmNoXG4gKiBAcGFyYW0ge0Z1bmN0aW9uKGEsIGIpfSBvcHRpb25zLmhldXJpc3RpYyAtIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGVzdGltYXRlZCBkaXN0YW5jZSBiZXR3ZWVuXG4gKiBub2RlcyBgYWAgYW5kIGBiYC4gVGhpcyBmdW5jdGlvbiBzaG91bGQgbmV2ZXIgb3ZlcmVzdGltYXRlIGFjdHVhbCBkaXN0YW5jZSBiZXR3ZWVuIHR3b1xuICogbm9kZXMgKG90aGVyd2lzZSB0aGUgZm91bmQgcGF0aCB3aWxsIG5vdCBiZSB0aGUgc2hvcnRlc3QpLiBEZWZhdWx0cyBmdW5jdGlvbiByZXR1cm5zIDAsXG4gKiB3aGljaCBtYWtlcyB0aGlzIHNlYXJjaCBlcXVpdmFsZW50IHRvIERpamtzdHJhIHNlYXJjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb24oYSwgYil9IG9wdGlvbnMuZGlzdGFuY2UgLSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhY3R1YWwgZGlzdGFuY2UgYmV0d2VlbiB0d29cbiAqIG5vZGVzIGBhYCBhbmQgYGJgLiBCeSBkZWZhdWx0IHRoaXMgaXMgc2V0IHRvIHJldHVybiBncmFwaC10aGVvcmV0aWNhbCBkaXN0YW5jZSAoYWx3YXlzIDEpO1xuICogXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBIHBhdGhmaW5kZXIgd2l0aCBzaW5nbGUgbWV0aG9kIGBmaW5kKClgLlxuICovXG5mdW5jdGlvbiBuYmEoZ3JhcGgsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIC8vIHdoZXRoZXIgdHJhdmVyc2FsIHNob3VsZCBiZSBjb25zaWRlcmVkIG92ZXIgb3JpZW50ZWQgZ3JhcGguXG4gIHZhciBvcmllbnRlZCA9IG9wdGlvbnMub3JpZW50ZWQ7XG4gIHZhciBxdWl0RmFzdCA9IG9wdGlvbnMucXVpdEZhc3Q7XG5cbiAgdmFyIGhldXJpc3RpYyA9IG9wdGlvbnMuaGV1cmlzdGljO1xuICBpZiAoIWhldXJpc3RpYykgaGV1cmlzdGljID0gZGVmYXVsdFNldHRpbmdzLmhldXJpc3RpYztcblxuICB2YXIgZGlzdGFuY2UgPSBvcHRpb25zLmRpc3RhbmNlO1xuICBpZiAoIWRpc3RhbmNlKSBkaXN0YW5jZSA9IGRlZmF1bHRTZXR0aW5ncy5kaXN0YW5jZTtcblxuICAvLyBEdXJpbmcgc3RyZXNzIHRlc3RzIEkgbm90aWNlZCB0aGF0IGdhcmJhZ2UgY29sbGVjdGlvbiB3YXMgb25lIG9mIHRoZSBoZWF2aWVzdFxuICAvLyBjb250cmlidXRvcnMgdG8gdGhlIGFsZ29yaXRobSdzIHNwZWVkLiBTbyBJJ20gdXNpbmcgYW4gb2JqZWN0IHBvb2wgdG8gcmVjeWNsZSBub2Rlcy5cbiAgdmFyIHBvb2wgPSBtYWtlTkJBU2VhcmNoU3RhdGVQb29sKCk7XG5cbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBGaW5kcyBhIHBhdGggYmV0d2VlbiBub2RlIGBmcm9tSWRgIGFuZCBgdG9JZGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBvZiBub2RlcyBiZXR3ZWVuIGB0b0lkYCBhbmQgYGZyb21JZGAuIEVtcHR5IGFycmF5IGlzIHJldHVybmVkXG4gICAgICogaWYgbm8gcGF0aCBpcyBmb3VuZC5cbiAgICAgKi9cbiAgICBmaW5kOiBmaW5kXG4gIH07XG5cbiAgZnVuY3Rpb24gZmluZChmcm9tSWQsIHRvSWQpIHtcbiAgICAvLyBJIG11c3QgYXBvbG9naXplIGZvciB0aGUgY29kZSBkdXBsaWNhdGlvbi4gVGhpcyB3YXMgdGhlIGVhc2llc3Qgd2F5IGZvciBtZSB0b1xuICAgIC8vIGltcGxlbWVudCB0aGUgYWxnb3JpdGhtIGZhc3QuXG4gICAgdmFyIGZyb20gPSBncmFwaC5nZXROb2RlKGZyb21JZCk7XG4gICAgaWYgKCFmcm9tKSB0aHJvdyBuZXcgRXJyb3IoJ2Zyb21JZCBpcyBub3QgZGVmaW5lZCBpbiB0aGlzIGdyYXBoOiAnICsgZnJvbUlkKTtcbiAgICB2YXIgdG8gPSBncmFwaC5nZXROb2RlKHRvSWQpO1xuICAgIGlmICghdG8pIHRocm93IG5ldyBFcnJvcigndG9JZCBpcyBub3QgZGVmaW5lZCBpbiB0aGlzIGdyYXBoOiAnICsgdG9JZCk7XG5cbiAgICBwb29sLnJlc2V0KCk7XG5cbiAgICAvLyBJIG11c3QgYWxzbyBhcG9sb2dpemUgZm9yIHNvbWV3aGF0IGNyeXB0aWMgbmFtZXMuIFRoZSBOQkEqIGlzIGJpLWRpcmVjdGlvbmFsXG4gICAgLy8gc2VhcmNoIGFsZ29yaXRobSwgd2hpY2ggbWVhbnMgaXQgcnVucyB0d28gc2VhcmNoZXMgaW4gcGFyYWxsZWwuIE9uZSBpcyBjYWxsZWRcbiAgICAvLyBmb3J3YXJkIHNlYXJjaCBhbmQgaXQgcnVucyBmcm9tIHNvdXJjZSBub2RlIHRvIHRhcmdldCwgd2hpbGUgdGhlIG90aGVyIG9uZVxuICAgIC8vIChiYWNrd2FyZCBzZWFyY2gpIHJ1bnMgZnJvbSB0YXJnZXQgdG8gc291cmNlLlxuXG4gICAgLy8gRXZlcnl3aGVyZSB3aGVyZSB5b3Ugc2VlIGAxYCBpdCBtZWFucyBpdCdzIGZvciB0aGUgZm9yd2FyZCBzZWFyY2guIGAyYCBpcyBmb3IgXG4gICAgLy8gYmFja3dhcmQgc2VhcmNoLlxuXG4gICAgLy8gRm9yIG9yaWVudGVkIGdyYXBoIHBhdGggZmluZGluZywgd2UgbmVlZCB0byByZXZlcnNlIHRoZSBncmFwaCwgc28gdGhhdFxuICAgIC8vIGJhY2t3YXJkIHNlYXJjaCB2aXNpdHMgY29ycmVjdCBsaW5rLiBPYnZpb3VzbHkgd2UgZG9uJ3Qgd2FudCB0byBkdXBsaWNhdGVcbiAgICAvLyB0aGUgZ3JhcGgsIGluc3RlYWQgd2UgYWx3YXlzIHRyYXZlcnNlIHRoZSBncmFwaCBhcyBub24tb3JpZW50ZWQsIGFuZCBmaWx0ZXJcbiAgICAvLyBlZGdlcyBpbiBgdmlzaXROMU9yaWVudGVkL3Zpc2l0TjJPcml0ZW50ZWRgXG4gICAgdmFyIGZvcndhcmRWaXNpdG9yID0gb3JpZW50ZWQgPyB2aXNpdE4xT3JpZW50ZWQgOiB2aXNpdE4xO1xuICAgIHZhciByZXZlcnNlVmlzaXRvciA9IG9yaWVudGVkID8gdmlzaXROMk9yaWVudGVkIDogdmlzaXROMjtcblxuICAgIC8vIE1hcHMgbm9kZUlkIHRvIE5CQVNlYXJjaFN0YXRlLlxuICAgIHZhciBub2RlU3RhdGUgPSBuZXcgTWFwKCk7XG5cbiAgICAvLyBUaGVzZSB0d28gaGVhcHMgc3RvcmUgbm9kZXMgYnkgdGhlaXIgdW5kZXJlc3RpbWF0ZWQgdmFsdWVzLlxuICAgIHZhciBvcGVuMVNldCA9IG5ldyBOb2RlSGVhcCh7XG4gICAgICBjb21wYXJlOiBkZWZhdWx0U2V0dGluZ3MuY29tcGFyZUYxU2NvcmUsXG4gICAgICBzZXROb2RlSWQ6IGRlZmF1bHRTZXR0aW5ncy5zZXRIMVxuICAgIH0pO1xuICAgIHZhciBvcGVuMlNldCA9IG5ldyBOb2RlSGVhcCh7XG4gICAgICBjb21wYXJlOiBkZWZhdWx0U2V0dGluZ3MuY29tcGFyZUYyU2NvcmUsXG4gICAgICBzZXROb2RlSWQ6IGRlZmF1bHRTZXR0aW5ncy5zZXRIMlxuICAgIH0pO1xuXG4gICAgLy8gVGhpcyBpcyB3aGVyZSBib3RoIHNlYXJjaGVzIHdpbGwgbWVldC5cbiAgICB2YXIgbWluTm9kZTtcblxuICAgIC8vIFRoZSBzbWFsbGVzdCBwYXRoIGxlbmd0aCBzZWVuIHNvIGZhciBpcyBzdG9yZWQgaGVyZTpcbiAgICB2YXIgbE1pbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblxuICAgIC8vIFdlIHN0YXJ0IGJ5IHB1dHRpbmcgc3RhcnQvZW5kIG5vZGVzIHRvIHRoZSBjb3JyZXNwb25kaW5nIGhlYXBzXG4gICAgLy8gSWYgdmFyaWFibGUgbmFtZXMgbGlrZSBgZjFgLCBgZzFgIGFyZSB0b28gY29uZnVzaW5nLCBwbGVhc2UgcmVmZXJcbiAgICAvLyB0byBtYWtlTkJBU2VhcmNoU3RhdGVQb29sLmpzIGZpbGUsIHdoaWNoIGhhcyBkZXRhaWxlZCBkZXNjcmlwdGlvbi5cbiAgICB2YXIgc3RhcnROb2RlID0gcG9vbC5jcmVhdGVOZXdTdGF0ZShmcm9tKTtcbiAgICBub2RlU3RhdGUuc2V0KGZyb21JZCwgc3RhcnROb2RlKTsgXG4gICAgc3RhcnROb2RlLmcxID0gMDtcbiAgICB2YXIgZjEgPSBoZXVyaXN0aWMoZnJvbSwgdG8pO1xuICAgIHN0YXJ0Tm9kZS5mMSA9IGYxO1xuICAgIG9wZW4xU2V0LnB1c2goc3RhcnROb2RlKTtcblxuICAgIHZhciBlbmROb2RlID0gcG9vbC5jcmVhdGVOZXdTdGF0ZSh0byk7XG4gICAgbm9kZVN0YXRlLnNldCh0b0lkLCBlbmROb2RlKTtcbiAgICBlbmROb2RlLmcyID0gMDtcbiAgICB2YXIgZjIgPSBmMTsgLy8gdGhleSBzaG91bGQgYWdyZWUgb3JpZ2luYWxseVxuICAgIGVuZE5vZGUuZjIgPSBmMjtcbiAgICBvcGVuMlNldC5wdXNoKGVuZE5vZGUpXG5cbiAgICAvLyB0aGUgYGNhbWVGcm9tYCB2YXJpYWJsZSBpcyBhY2Nlc3NlZCBieSBib3RoIHNlYXJjaGVzLCBzbyB0aGF0IHdlIGNhbiBzdG9yZSBwYXJlbnRzLlxuICAgIHZhciBjYW1lRnJvbTtcblxuICAgIC8vIHRoaXMgaXMgdGhlIG1haW4gYWxnb3JpdGhtIGxvb3A6XG4gICAgd2hpbGUgKG9wZW4yU2V0Lmxlbmd0aCAmJiBvcGVuMVNldC5sZW5ndGgpIHtcbiAgICAgIGlmIChvcGVuMVNldC5sZW5ndGggPCBvcGVuMlNldC5sZW5ndGgpIHtcbiAgICAgICAgZm9yd2FyZFNlYXJjaCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV2ZXJzZVNlYXJjaCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocXVpdEZhc3QgJiYgbWluTm9kZSkgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIHBhdGggPSByZWNvbnN0cnVjdFBhdGgobWluTm9kZSk7XG4gICAgcmV0dXJuIHBhdGg7IC8vIHRoZSBwdWJsaWMgQVBJIGlzIG92ZXJcblxuICAgIGZ1bmN0aW9uIGZvcndhcmRTZWFyY2goKSB7XG4gICAgICBjYW1lRnJvbSA9IG9wZW4xU2V0LnBvcCgpO1xuICAgICAgaWYgKGNhbWVGcm9tLmNsb3NlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNhbWVGcm9tLmNsb3NlZCA9IHRydWU7XG5cbiAgICAgIGlmIChjYW1lRnJvbS5mMSA8IGxNaW4gJiYgKGNhbWVGcm9tLmcxICsgZjIgLSBoZXVyaXN0aWMoZnJvbSwgY2FtZUZyb20ubm9kZSkpIDwgbE1pbikge1xuICAgICAgICBncmFwaC5mb3JFYWNoTGlua2VkTm9kZShjYW1lRnJvbS5ub2RlLmlkLCBmb3J3YXJkVmlzaXRvcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcGVuMVNldC5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIHRoaXMgd2lsbCBiZSB1c2VkIGluIHJldmVyc2Ugc2VhcmNoXG4gICAgICAgIGYxID0gb3BlbjFTZXQucGVlaygpLmYxO1xuICAgICAgfSBcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXZlcnNlU2VhcmNoKCkge1xuICAgICAgY2FtZUZyb20gPSBvcGVuMlNldC5wb3AoKTtcbiAgICAgIGlmIChjYW1lRnJvbS5jbG9zZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2FtZUZyb20uY2xvc2VkID0gdHJ1ZTtcblxuICAgICAgaWYgKGNhbWVGcm9tLmYyIDwgbE1pbiAmJiAoY2FtZUZyb20uZzIgKyBmMSAtIGhldXJpc3RpYyhjYW1lRnJvbS5ub2RlLCB0bykpIDwgbE1pbikge1xuICAgICAgICBncmFwaC5mb3JFYWNoTGlua2VkTm9kZShjYW1lRnJvbS5ub2RlLmlkLCByZXZlcnNlVmlzaXRvcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcGVuMlNldC5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIHRoaXMgd2lsbCBiZSB1c2VkIGluIGZvcndhcmQgc2VhcmNoXG4gICAgICAgIGYyID0gb3BlbjJTZXQucGVlaygpLmYyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZpc2l0TjEob3RoZXJOb2RlLCBsaW5rKSB7XG4gICAgICB2YXIgb3RoZXJTZWFyY2hTdGF0ZSA9IG5vZGVTdGF0ZS5nZXQob3RoZXJOb2RlLmlkKTtcbiAgICAgIGlmICghb3RoZXJTZWFyY2hTdGF0ZSkge1xuICAgICAgICBvdGhlclNlYXJjaFN0YXRlID0gcG9vbC5jcmVhdGVOZXdTdGF0ZShvdGhlck5vZGUpO1xuICAgICAgICBub2RlU3RhdGUuc2V0KG90aGVyTm9kZS5pZCwgb3RoZXJTZWFyY2hTdGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvdGhlclNlYXJjaFN0YXRlLmNsb3NlZCkgcmV0dXJuO1xuXG4gICAgICB2YXIgdGVudGF0aXZlRGlzdGFuY2UgPSBjYW1lRnJvbS5nMSArIGRpc3RhbmNlKGNhbWVGcm9tLm5vZGUsIG90aGVyTm9kZSwgbGluayk7XG5cbiAgICAgIGlmICh0ZW50YXRpdmVEaXN0YW5jZSA8IG90aGVyU2VhcmNoU3RhdGUuZzEpIHtcbiAgICAgICAgb3RoZXJTZWFyY2hTdGF0ZS5nMSA9IHRlbnRhdGl2ZURpc3RhbmNlO1xuICAgICAgICBvdGhlclNlYXJjaFN0YXRlLmYxID0gdGVudGF0aXZlRGlzdGFuY2UgKyBoZXVyaXN0aWMob3RoZXJTZWFyY2hTdGF0ZS5ub2RlLCB0byk7XG4gICAgICAgIG90aGVyU2VhcmNoU3RhdGUucDEgPSBjYW1lRnJvbTtcbiAgICAgICAgaWYgKG90aGVyU2VhcmNoU3RhdGUuaDEgPCAwKSB7XG4gICAgICAgICAgb3BlbjFTZXQucHVzaChvdGhlclNlYXJjaFN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcGVuMVNldC51cGRhdGVJdGVtKG90aGVyU2VhcmNoU3RhdGUuaDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgcG90ZW50aWFsTWluID0gb3RoZXJTZWFyY2hTdGF0ZS5nMSArIG90aGVyU2VhcmNoU3RhdGUuZzI7XG4gICAgICBpZiAocG90ZW50aWFsTWluIDwgbE1pbikgeyBcbiAgICAgICAgbE1pbiA9IHBvdGVudGlhbE1pbjtcbiAgICAgICAgbWluTm9kZSA9IG90aGVyU2VhcmNoU3RhdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmlzaXROMihvdGhlck5vZGUsIGxpbmspIHtcbiAgICAgIHZhciBvdGhlclNlYXJjaFN0YXRlID0gbm9kZVN0YXRlLmdldChvdGhlck5vZGUuaWQpO1xuICAgICAgaWYgKCFvdGhlclNlYXJjaFN0YXRlKSB7XG4gICAgICAgIG90aGVyU2VhcmNoU3RhdGUgPSBwb29sLmNyZWF0ZU5ld1N0YXRlKG90aGVyTm9kZSk7XG4gICAgICAgIG5vZGVTdGF0ZS5zZXQob3RoZXJOb2RlLmlkLCBvdGhlclNlYXJjaFN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG90aGVyU2VhcmNoU3RhdGUuY2xvc2VkKSByZXR1cm47XG5cbiAgICAgIHZhciB0ZW50YXRpdmVEaXN0YW5jZSA9IGNhbWVGcm9tLmcyICsgZGlzdGFuY2UoY2FtZUZyb20ubm9kZSwgb3RoZXJOb2RlLCBsaW5rKTtcblxuICAgICAgaWYgKHRlbnRhdGl2ZURpc3RhbmNlIDwgb3RoZXJTZWFyY2hTdGF0ZS5nMikge1xuICAgICAgICBvdGhlclNlYXJjaFN0YXRlLmcyID0gdGVudGF0aXZlRGlzdGFuY2U7XG4gICAgICAgIG90aGVyU2VhcmNoU3RhdGUuZjIgPSB0ZW50YXRpdmVEaXN0YW5jZSArIGhldXJpc3RpYyhmcm9tLCBvdGhlclNlYXJjaFN0YXRlLm5vZGUpO1xuICAgICAgICBvdGhlclNlYXJjaFN0YXRlLnAyID0gY2FtZUZyb207XG4gICAgICAgIGlmIChvdGhlclNlYXJjaFN0YXRlLmgyIDwgMCkge1xuICAgICAgICAgIG9wZW4yU2V0LnB1c2gob3RoZXJTZWFyY2hTdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3BlbjJTZXQudXBkYXRlSXRlbShvdGhlclNlYXJjaFN0YXRlLmgyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHBvdGVudGlhbE1pbiA9IG90aGVyU2VhcmNoU3RhdGUuZzEgKyBvdGhlclNlYXJjaFN0YXRlLmcyO1xuICAgICAgaWYgKHBvdGVudGlhbE1pbiA8IGxNaW4pIHtcbiAgICAgICAgbE1pbiA9IHBvdGVudGlhbE1pbjtcbiAgICAgICAgbWluTm9kZSA9IG90aGVyU2VhcmNoU3RhdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmlzaXROMk9yaWVudGVkKG90aGVyTm9kZSwgbGluaykge1xuICAgICAgLy8gd2UgYXJlIGdvaW5nIGJhY2t3YXJkcywgZ3JhcGggbmVlZHMgdG8gYmUgcmV2ZXJzZWQuIFxuICAgICAgaWYgKGxpbmsudG9JZCA9PT0gY2FtZUZyb20ubm9kZS5pZCkgcmV0dXJuIHZpc2l0TjIob3RoZXJOb2RlLCBsaW5rKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmlzaXROMU9yaWVudGVkKG90aGVyTm9kZSwgbGluaykge1xuICAgICAgLy8gdGhpcyBpcyBmb3J3YXJkIGRpcmVjdGlvbiwgc28gd2Ugc2hvdWxkIGJlIGNvbWluZyBGUk9NOlxuICAgICAgaWYgKGxpbmsuZnJvbUlkID09PSBjYW1lRnJvbS5ub2RlLmlkKSByZXR1cm4gdmlzaXROMShvdGhlck5vZGUsIGxpbmspO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvbnN0cnVjdFBhdGgoc2VhcmNoU3RhdGUpIHtcbiAgaWYgKCFzZWFyY2hTdGF0ZSkgcmV0dXJuIE5PX1BBVEg7XG5cbiAgdmFyIHBhdGggPSBbc2VhcmNoU3RhdGUubm9kZV07XG4gIHZhciBwYXJlbnQgPSBzZWFyY2hTdGF0ZS5wMTtcblxuICB3aGlsZSAocGFyZW50KSB7XG4gICAgcGF0aC5wdXNoKHBhcmVudC5ub2RlKTtcbiAgICBwYXJlbnQgPSBwYXJlbnQucDE7XG4gIH1cblxuICB2YXIgY2hpbGQgPSBzZWFyY2hTdGF0ZS5wMjtcblxuICB3aGlsZSAoY2hpbGQpIHtcbiAgICBwYXRoLnVuc2hpZnQoY2hpbGQubm9kZSk7XG4gICAgY2hpbGQgPSBjaGlsZC5wMjtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ngraph.path/a-star/nba/index.js\n");

/***/ }),

/***/ "../node_modules/ngraph.path/a-star/nba/makeNBASearchStatePool.js":
/*!************************************************************************!*\
  !*** ../node_modules/ngraph.path/a-star/nba/makeNBASearchStatePool.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = makeNBASearchStatePool;\n\n/**\n * Creates new instance of NBASearchState. The instance stores information\n * about search state, and is used by NBA* algorithm.\n *\n * @param {Object} node - original graph node\n */\nfunction NBASearchState(node) {\n  /**\n   * Original graph node.\n   */\n  this.node = node;\n\n  /**\n   * Parent of this node in forward search\n   */\n  this.p1 = null;\n\n  /**\n   * Parent of this node in reverse search\n   */\n  this.p2 = null;\n\n  /**\n   * If this is set to true, then the node was already processed\n   * and we should not touch it anymore.\n   */\n  this.closed = false;\n\n  /**\n   * Actual distance from this node to its parent in forward search\n   */\n  this.g1 = Number.POSITIVE_INFINITY;\n\n  /**\n   * Actual distance from this node to its parent in reverse search\n   */\n  this.g2 = Number.POSITIVE_INFINITY;\n\n\n  /**\n   * Underestimated distance from this node to the path-finding source.\n   */\n  this.f1 = Number.POSITIVE_INFINITY;\n\n  /**\n   * Underestimated distance from this node to the path-finding target.\n   */\n  this.f2 = Number.POSITIVE_INFINITY;\n\n  // used to reconstruct heap when fScore is updated. TODO: do I need them both?\n\n  /**\n   * Index of this node in the forward heap.\n   */\n  this.h1 = -1;\n\n  /**\n   * Index of this node in the reverse heap.\n   */\n  this.h2 = -1;\n}\n\n/**\n * As path-finding is memory-intensive process, we want to reduce pressure on\n * garbage collector. This class helps us to recycle path-finding nodes and significantly\n * reduces the search time (~20% faster than without it).\n */\nfunction makeNBASearchStatePool() {\n  var currentInCache = 0;\n  var nodeCache = [];\n\n  return {\n    /**\n     * Creates a new NBASearchState instance\n     */\n    createNewState: createNewState,\n\n    /**\n     * Marks all created instances available for recycling.\n     */\n    reset: reset\n  };\n\n  function reset() {\n    currentInCache = 0;\n  }\n\n  function createNewState(node) {\n    var cached = nodeCache[currentInCache];\n    if (cached) {\n      // TODO: This almost duplicates constructor code. Not sure if\n      // it would impact performance if I move this code into a function\n      cached.node = node;\n\n      // How we came to this node?\n      cached.p1 = null;\n      cached.p2 = null;\n\n      cached.closed = false;\n\n      cached.g1 = Number.POSITIVE_INFINITY;\n      cached.g2 = Number.POSITIVE_INFINITY;\n      cached.f1 = Number.POSITIVE_INFINITY;\n      cached.f2 = Number.POSITIVE_INFINITY;\n\n      // used to reconstruct heap when fScore is updated.\n      cached.h1 = -1;\n      cached.h2 = -1;\n    } else {\n      cached = new NBASearchState(node);\n      nodeCache[currentInCache] = cached;\n    }\n    currentInCache++;\n    return cached;\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL25ncmFwaC5wYXRoL2Etc3Rhci9uYmEvbWFrZU5CQVNlYXJjaFN0YXRlUG9vbC5qcz9lYjJiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuLi9ub2RlX21vZHVsZXMvbmdyYXBoLnBhdGgvYS1zdGFyL25iYS9tYWtlTkJBU2VhcmNoU3RhdGVQb29sLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBtYWtlTkJBU2VhcmNoU3RhdGVQb29sO1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIE5CQVNlYXJjaFN0YXRlLiBUaGUgaW5zdGFuY2Ugc3RvcmVzIGluZm9ybWF0aW9uXG4gKiBhYm91dCBzZWFyY2ggc3RhdGUsIGFuZCBpcyB1c2VkIGJ5IE5CQSogYWxnb3JpdGhtLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIC0gb3JpZ2luYWwgZ3JhcGggbm9kZVxuICovXG5mdW5jdGlvbiBOQkFTZWFyY2hTdGF0ZShub2RlKSB7XG4gIC8qKlxuICAgKiBPcmlnaW5hbCBncmFwaCBub2RlLlxuICAgKi9cbiAgdGhpcy5ub2RlID0gbm9kZTtcblxuICAvKipcbiAgICogUGFyZW50IG9mIHRoaXMgbm9kZSBpbiBmb3J3YXJkIHNlYXJjaFxuICAgKi9cbiAgdGhpcy5wMSA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFBhcmVudCBvZiB0aGlzIG5vZGUgaW4gcmV2ZXJzZSBzZWFyY2hcbiAgICovXG4gIHRoaXMucDIgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBJZiB0aGlzIGlzIHNldCB0byB0cnVlLCB0aGVuIHRoZSBub2RlIHdhcyBhbHJlYWR5IHByb2Nlc3NlZFxuICAgKiBhbmQgd2Ugc2hvdWxkIG5vdCB0b3VjaCBpdCBhbnltb3JlLlxuICAgKi9cbiAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcblxuICAvKipcbiAgICogQWN0dWFsIGRpc3RhbmNlIGZyb20gdGhpcyBub2RlIHRvIGl0cyBwYXJlbnQgaW4gZm9yd2FyZCBzZWFyY2hcbiAgICovXG4gIHRoaXMuZzEgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cbiAgLyoqXG4gICAqIEFjdHVhbCBkaXN0YW5jZSBmcm9tIHRoaXMgbm9kZSB0byBpdHMgcGFyZW50IGluIHJldmVyc2Ugc2VhcmNoXG4gICAqL1xuICB0aGlzLmcyID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXG5cbiAgLyoqXG4gICAqIFVuZGVyZXN0aW1hdGVkIGRpc3RhbmNlIGZyb20gdGhpcyBub2RlIHRvIHRoZSBwYXRoLWZpbmRpbmcgc291cmNlLlxuICAgKi9cbiAgdGhpcy5mMSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblxuICAvKipcbiAgICogVW5kZXJlc3RpbWF0ZWQgZGlzdGFuY2UgZnJvbSB0aGlzIG5vZGUgdG8gdGhlIHBhdGgtZmluZGluZyB0YXJnZXQuXG4gICAqL1xuICB0aGlzLmYyID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXG4gIC8vIHVzZWQgdG8gcmVjb25zdHJ1Y3QgaGVhcCB3aGVuIGZTY29yZSBpcyB1cGRhdGVkLiBUT0RPOiBkbyBJIG5lZWQgdGhlbSBib3RoP1xuXG4gIC8qKlxuICAgKiBJbmRleCBvZiB0aGlzIG5vZGUgaW4gdGhlIGZvcndhcmQgaGVhcC5cbiAgICovXG4gIHRoaXMuaDEgPSAtMTtcblxuICAvKipcbiAgICogSW5kZXggb2YgdGhpcyBub2RlIGluIHRoZSByZXZlcnNlIGhlYXAuXG4gICAqL1xuICB0aGlzLmgyID0gLTE7XG59XG5cbi8qKlxuICogQXMgcGF0aC1maW5kaW5nIGlzIG1lbW9yeS1pbnRlbnNpdmUgcHJvY2Vzcywgd2Ugd2FudCB0byByZWR1Y2UgcHJlc3N1cmUgb25cbiAqIGdhcmJhZ2UgY29sbGVjdG9yLiBUaGlzIGNsYXNzIGhlbHBzIHVzIHRvIHJlY3ljbGUgcGF0aC1maW5kaW5nIG5vZGVzIGFuZCBzaWduaWZpY2FudGx5XG4gKiByZWR1Y2VzIHRoZSBzZWFyY2ggdGltZSAofjIwJSBmYXN0ZXIgdGhhbiB3aXRob3V0IGl0KS5cbiAqL1xuZnVuY3Rpb24gbWFrZU5CQVNlYXJjaFN0YXRlUG9vbCgpIHtcbiAgdmFyIGN1cnJlbnRJbkNhY2hlID0gMDtcbiAgdmFyIG5vZGVDYWNoZSA9IFtdO1xuXG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBOQkFTZWFyY2hTdGF0ZSBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNyZWF0ZU5ld1N0YXRlOiBjcmVhdGVOZXdTdGF0ZSxcblxuICAgIC8qKlxuICAgICAqIE1hcmtzIGFsbCBjcmVhdGVkIGluc3RhbmNlcyBhdmFpbGFibGUgZm9yIHJlY3ljbGluZy5cbiAgICAgKi9cbiAgICByZXNldDogcmVzZXRcbiAgfTtcblxuICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBjdXJyZW50SW5DYWNoZSA9IDA7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVOZXdTdGF0ZShub2RlKSB7XG4gICAgdmFyIGNhY2hlZCA9IG5vZGVDYWNoZVtjdXJyZW50SW5DYWNoZV07XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgLy8gVE9ETzogVGhpcyBhbG1vc3QgZHVwbGljYXRlcyBjb25zdHJ1Y3RvciBjb2RlLiBOb3Qgc3VyZSBpZlxuICAgICAgLy8gaXQgd291bGQgaW1wYWN0IHBlcmZvcm1hbmNlIGlmIEkgbW92ZSB0aGlzIGNvZGUgaW50byBhIGZ1bmN0aW9uXG4gICAgICBjYWNoZWQubm9kZSA9IG5vZGU7XG5cbiAgICAgIC8vIEhvdyB3ZSBjYW1lIHRvIHRoaXMgbm9kZT9cbiAgICAgIGNhY2hlZC5wMSA9IG51bGw7XG4gICAgICBjYWNoZWQucDIgPSBudWxsO1xuXG4gICAgICBjYWNoZWQuY2xvc2VkID0gZmFsc2U7XG5cbiAgICAgIGNhY2hlZC5nMSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgIGNhY2hlZC5nMiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgIGNhY2hlZC5mMSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgIGNhY2hlZC5mMiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblxuICAgICAgLy8gdXNlZCB0byByZWNvbnN0cnVjdCBoZWFwIHdoZW4gZlNjb3JlIGlzIHVwZGF0ZWQuXG4gICAgICBjYWNoZWQuaDEgPSAtMTtcbiAgICAgIGNhY2hlZC5oMiA9IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWNoZWQgPSBuZXcgTkJBU2VhcmNoU3RhdGUobm9kZSk7XG4gICAgICBub2RlQ2FjaGVbY3VycmVudEluQ2FjaGVdID0gY2FjaGVkO1xuICAgIH1cbiAgICBjdXJyZW50SW5DYWNoZSsrO1xuICAgIHJldHVybiBjYWNoZWQ7XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/ngraph.path/a-star/nba/makeNBASearchStatePool.js\n");

/***/ }),

/***/ "../node_modules/ngraph.path/index.js":
/*!********************************************!*\
  !*** ../node_modules/ngraph.path/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = {\n  aStar: __webpack_require__(/*! ./a-star/a-star.js */ \"../node_modules/ngraph.path/a-star/a-star.js\"),\n  aGreedy: __webpack_require__(/*! ./a-star/a-greedy-star */ \"../node_modules/ngraph.path/a-star/a-greedy-star.js\"),\n  nba: __webpack_require__(/*! ./a-star/nba/index.js */ \"../node_modules/ngraph.path/a-star/nba/index.js\"),\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL25ncmFwaC5wYXRoL2luZGV4LmpzPzI2YmIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxTQUFTLG1CQUFPLENBQUMsd0VBQW9CO0FBQ3JDLFdBQVcsbUJBQU8sQ0FBQyxtRkFBd0I7QUFDM0MsT0FBTyxtQkFBTyxDQUFDLDhFQUF1QjtBQUN0QyIsImZpbGUiOiIuLi9ub2RlX21vZHVsZXMvbmdyYXBoLnBhdGgvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgYVN0YXI6IHJlcXVpcmUoJy4vYS1zdGFyL2Etc3Rhci5qcycpLFxuICBhR3JlZWR5OiByZXF1aXJlKCcuL2Etc3Rhci9hLWdyZWVkeS1zdGFyJyksXG4gIG5iYTogcmVxdWlyZSgnLi9hLXN0YXIvbmJhL2luZGV4LmpzJyksXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/ngraph.path/index.js\n");

/***/ }),

/***/ "../src/Edge.js":
/*!**********************!*\
  !*** ../src/Edge.js ***!
  \**********************/
/*! exports provided: Edge */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Edge\", function() { return Edge; });\nclass Edge {\n  constructor (p1, p2) {\n    this.p1 = p1\n    this.p2 = p2\n\n    p1.edges.push(this)\n    p2.edges.push(this)\n  }\n\n  getOtherPointInEdge (point) {\n    return this.p1.isPointEqual(point) ? this.p2 : this.p1\n  }\n\n  areEdgesEqual (otherEdge) {\n    if (this.p1.isPointEqual(otherEdge.p1) && this.p2.isPointEqual(otherEdge.p2)) return true\n    if (this.p1.isPointEqual(otherEdge.p2) && this.p2.isPointEqual(otherEdge.p1)) return true\n    return false\n  }\n\n  containsPoint (point) {\n    if (this.p1.isPointEqual(point) || this.p2.isPointEqual(point)) return true\n    return false\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL0VkZ2UuanM/ZDE1ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi4vc3JjL0VkZ2UuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY2xhc3MgRWRnZSB7XG4gIGNvbnN0cnVjdG9yIChwMSwgcDIpIHtcbiAgICB0aGlzLnAxID0gcDFcbiAgICB0aGlzLnAyID0gcDJcblxuICAgIHAxLmVkZ2VzLnB1c2godGhpcylcbiAgICBwMi5lZGdlcy5wdXNoKHRoaXMpXG4gIH1cblxuICBnZXRPdGhlclBvaW50SW5FZGdlIChwb2ludCkge1xuICAgIHJldHVybiB0aGlzLnAxLmlzUG9pbnRFcXVhbChwb2ludCkgPyB0aGlzLnAyIDogdGhpcy5wMVxuICB9XG5cbiAgYXJlRWRnZXNFcXVhbCAob3RoZXJFZGdlKSB7XG4gICAgaWYgKHRoaXMucDEuaXNQb2ludEVxdWFsKG90aGVyRWRnZS5wMSkgJiYgdGhpcy5wMi5pc1BvaW50RXF1YWwob3RoZXJFZGdlLnAyKSkgcmV0dXJuIHRydWVcbiAgICBpZiAodGhpcy5wMS5pc1BvaW50RXF1YWwob3RoZXJFZGdlLnAyKSAmJiB0aGlzLnAyLmlzUG9pbnRFcXVhbChvdGhlckVkZ2UucDEpKSByZXR1cm4gdHJ1ZVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgY29udGFpbnNQb2ludCAocG9pbnQpIHtcbiAgICBpZiAodGhpcy5wMS5pc1BvaW50RXF1YWwocG9pbnQpIHx8IHRoaXMucDIuaXNQb2ludEVxdWFsKHBvaW50KSkgcmV0dXJuIHRydWVcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../src/Edge.js\n");

/***/ }),

/***/ "../src/EdgeKey.js":
/*!*************************!*\
  !*** ../src/EdgeKey.js ***!
  \*************************/
/*! exports provided: EdgeKey */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EdgeKey\", function() { return EdgeKey; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"../src/utils.js\");\n\n\nclass EdgeKey {\n\n  constructor (p1, p2, edge) {\n    this.p1 = p1\n    this.p2 = p2\n    this.edge = edge\n  }\n\n  isLessThanOtherEdgeKey (otherEdgeKey) {\n    if (this.matchesOtherKey(otherEdgeKey)) return false\n    if (!Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"edgeIntersect\"])(this.p1, this.p2, otherEdgeKey.edge)) return true\n    const selfDistance = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"pointEdgeDistance\"])(this.p1, this.p2, this.edge)\n    const otherDistance = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"pointEdgeDistance\"])(this.p1, this.p2, otherEdgeKey.edge)\n    if (selfDistance > otherDistance) return false\n    if (selfDistance < otherDistance) return true\n    if (selfDistance === otherDistance) {\n      let samePoint = null\n      if (otherEdgeKey.edge.containsPoint(this.edge.p1)) samePoint = this.edge.p1\n      // else if (otherEdgeKey.edge.containsPoint(this.edge.p2)) samePoint = this.edge.p2\n      else samePoint = this.edge.p2\n      const aslf = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"angle2\"])(this.p1, this.p2, this.edge.getOtherPointInEdge(samePoint))\n      const aot = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"angle2\"])(this.p1, this.p2, otherEdgeKey.edge.getOtherPointInEdge(samePoint))\n      if (aslf < aot) return true\n      return false\n    }\n  }\n\n  matchesOtherKey (otherKey) {\n    return this.edge.areEdgesEqual(otherKey.edge)\n  }\n\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL0VkZ2VLZXkuanM/MjQzYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBa0U7O0FBRTNEOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsNERBQWE7QUFDdEIseUJBQXlCLGdFQUFpQjtBQUMxQywwQkFBMEIsZ0VBQWlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFEQUFNO0FBQ3pCLGtCQUFrQixxREFBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi4vc3JjL0VkZ2VLZXkuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBlZGdlSW50ZXJzZWN0LCBwb2ludEVkZ2VEaXN0YW5jZSwgYW5nbGUyIH0gZnJvbSAnLi91dGlscydcblxuZXhwb3J0IGNsYXNzIEVkZ2VLZXkge1xuXG4gIGNvbnN0cnVjdG9yIChwMSwgcDIsIGVkZ2UpIHtcbiAgICB0aGlzLnAxID0gcDFcbiAgICB0aGlzLnAyID0gcDJcbiAgICB0aGlzLmVkZ2UgPSBlZGdlXG4gIH1cblxuICBpc0xlc3NUaGFuT3RoZXJFZGdlS2V5IChvdGhlckVkZ2VLZXkpIHtcbiAgICBpZiAodGhpcy5tYXRjaGVzT3RoZXJLZXkob3RoZXJFZGdlS2V5KSkgcmV0dXJuIGZhbHNlXG4gICAgaWYgKCFlZGdlSW50ZXJzZWN0KHRoaXMucDEsIHRoaXMucDIsIG90aGVyRWRnZUtleS5lZGdlKSkgcmV0dXJuIHRydWVcbiAgICBjb25zdCBzZWxmRGlzdGFuY2UgPSBwb2ludEVkZ2VEaXN0YW5jZSh0aGlzLnAxLCB0aGlzLnAyLCB0aGlzLmVkZ2UpXG4gICAgY29uc3Qgb3RoZXJEaXN0YW5jZSA9IHBvaW50RWRnZURpc3RhbmNlKHRoaXMucDEsIHRoaXMucDIsIG90aGVyRWRnZUtleS5lZGdlKVxuICAgIGlmIChzZWxmRGlzdGFuY2UgPiBvdGhlckRpc3RhbmNlKSByZXR1cm4gZmFsc2VcbiAgICBpZiAoc2VsZkRpc3RhbmNlIDwgb3RoZXJEaXN0YW5jZSkgcmV0dXJuIHRydWVcbiAgICBpZiAoc2VsZkRpc3RhbmNlID09PSBvdGhlckRpc3RhbmNlKSB7XG4gICAgICBsZXQgc2FtZVBvaW50ID0gbnVsbFxuICAgICAgaWYgKG90aGVyRWRnZUtleS5lZGdlLmNvbnRhaW5zUG9pbnQodGhpcy5lZGdlLnAxKSkgc2FtZVBvaW50ID0gdGhpcy5lZGdlLnAxXG4gICAgICAvLyBlbHNlIGlmIChvdGhlckVkZ2VLZXkuZWRnZS5jb250YWluc1BvaW50KHRoaXMuZWRnZS5wMikpIHNhbWVQb2ludCA9IHRoaXMuZWRnZS5wMlxuICAgICAgZWxzZSBzYW1lUG9pbnQgPSB0aGlzLmVkZ2UucDJcbiAgICAgIGNvbnN0IGFzbGYgPSBhbmdsZTIodGhpcy5wMSwgdGhpcy5wMiwgdGhpcy5lZGdlLmdldE90aGVyUG9pbnRJbkVkZ2Uoc2FtZVBvaW50KSlcbiAgICAgIGNvbnN0IGFvdCA9IGFuZ2xlMih0aGlzLnAxLCB0aGlzLnAyLCBvdGhlckVkZ2VLZXkuZWRnZS5nZXRPdGhlclBvaW50SW5FZGdlKHNhbWVQb2ludCkpXG4gICAgICBpZiAoYXNsZiA8IGFvdCkgcmV0dXJuIHRydWVcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIG1hdGNoZXNPdGhlcktleSAob3RoZXJLZXkpIHtcbiAgICByZXR1cm4gdGhpcy5lZGdlLmFyZUVkZ2VzRXF1YWwob3RoZXJLZXkuZWRnZSlcbiAgfVxuXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../src/EdgeKey.js\n");

/***/ }),

/***/ "../src/EdgeKeys.js":
/*!**************************!*\
  !*** ../src/EdgeKeys.js ***!
  \**************************/
/*! exports provided: EdgeKeys */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EdgeKeys\", function() { return EdgeKeys; });\nclass EdgeKeys {\n\n  constructor () {\n    this.keys = []\n  }\n\n  findKeyPosition (edgekey, p) {\n    let lo = 0\n    let hi = this.keys.length\n    while (lo < hi) {\n      const mid = Math.floor((lo + hi) / 2)\n      if (edgekey.isLessThanOtherEdgeKey(this.keys[mid])) hi = mid\n      else lo = mid + 1\n    }\n    return lo\n  }\n\n  addKey (edgekey, p) {\n    const lo = this.findKeyPosition(edgekey)\n    this.keys.splice(lo, 0, edgekey)\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL0VkZ2VLZXlzLmpzPzA3NmEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4uL3NyYy9FZGdlS2V5cy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjbGFzcyBFZGdlS2V5cyB7XG5cbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMua2V5cyA9IFtdXG4gIH1cblxuICBmaW5kS2V5UG9zaXRpb24gKGVkZ2VrZXksIHApIHtcbiAgICBsZXQgbG8gPSAwXG4gICAgbGV0IGhpID0gdGhpcy5rZXlzLmxlbmd0aFxuICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICBjb25zdCBtaWQgPSBNYXRoLmZsb29yKChsbyArIGhpKSAvIDIpXG4gICAgICBpZiAoZWRnZWtleS5pc0xlc3NUaGFuT3RoZXJFZGdlS2V5KHRoaXMua2V5c1ttaWRdKSkgaGkgPSBtaWRcbiAgICAgIGVsc2UgbG8gPSBtaWQgKyAxXG4gICAgfVxuICAgIHJldHVybiBsb1xuICB9XG5cbiAgYWRkS2V5IChlZGdla2V5LCBwKSB7XG4gICAgY29uc3QgbG8gPSB0aGlzLmZpbmRLZXlQb3NpdGlvbihlZGdla2V5KVxuICAgIHRoaXMua2V5cy5zcGxpY2UobG8sIDAsIGVkZ2VrZXkpXG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../src/EdgeKeys.js\n");

/***/ }),

/***/ "../src/Point.js":
/*!***********************!*\
  !*** ../src/Point.js ***!
  \***********************/
/*! exports provided: Point */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Point\", function() { return Point; });\n// import { pi1, pi2 } from './utils'\nconst pi1 = Math.PI * 3 / 2\nconst pi2 = Math.PI / 2\n\nclass Point {\n\n  constructor (coords, polygonID) {\n    if (polygonID === null) polygonID = -1\n    this.x = coords[0]\n    this.y = coords[1]\n    this.polygonID = polygonID\n    this.edges = []\n    this.prevPoint = null\n    this.nextPoint = null\n  }\n\n  isPointEqual (otherPoint) {\n    return this.x === otherPoint.x && this.y === otherPoint.y\n  }\n\n  angleToPoint (otherPoint) {\n    if (this.isPointEqual(otherPoint)) return 0\n    const dx = otherPoint.x - this.x\n    const dy = otherPoint.y - this.y\n    if (dx === 0) dy < 1 ? pi1 : pi2\n    if (dy === 0) dx < 0 ? Math.PI : 0\n    if (dx < 0) return Math.PI + Math.atan(dy / dx)\n    if (dy < 0) return 2 * Math.PI + Math.atan(dy / dx)\n    return Math.atan(dy / dx)\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL1BvaW50LmpzP2JlNzIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBLFdBQVcsV0FBVztBQUN0QjtBQUNBOztBQUVPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuLi9zcmMvUG9pbnQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBpbXBvcnQgeyBwaTEsIHBpMiB9IGZyb20gJy4vdXRpbHMnXG5jb25zdCBwaTEgPSBNYXRoLlBJICogMyAvIDJcbmNvbnN0IHBpMiA9IE1hdGguUEkgLyAyXG5cbmV4cG9ydCBjbGFzcyBQb2ludCB7XG5cbiAgY29uc3RydWN0b3IgKGNvb3JkcywgcG9seWdvbklEKSB7XG4gICAgaWYgKHBvbHlnb25JRCA9PT0gbnVsbCkgcG9seWdvbklEID0gLTFcbiAgICB0aGlzLnggPSBjb29yZHNbMF1cbiAgICB0aGlzLnkgPSBjb29yZHNbMV1cbiAgICB0aGlzLnBvbHlnb25JRCA9IHBvbHlnb25JRFxuICAgIHRoaXMuZWRnZXMgPSBbXVxuICAgIHRoaXMucHJldlBvaW50ID0gbnVsbFxuICAgIHRoaXMubmV4dFBvaW50ID0gbnVsbFxuICB9XG5cbiAgaXNQb2ludEVxdWFsIChvdGhlclBvaW50KSB7XG4gICAgcmV0dXJuIHRoaXMueCA9PT0gb3RoZXJQb2ludC54ICYmIHRoaXMueSA9PT0gb3RoZXJQb2ludC55XG4gIH1cblxuICBhbmdsZVRvUG9pbnQgKG90aGVyUG9pbnQpIHtcbiAgICBpZiAodGhpcy5pc1BvaW50RXF1YWwob3RoZXJQb2ludCkpIHJldHVybiAwXG4gICAgY29uc3QgZHggPSBvdGhlclBvaW50LnggLSB0aGlzLnhcbiAgICBjb25zdCBkeSA9IG90aGVyUG9pbnQueSAtIHRoaXMueVxuICAgIGlmIChkeCA9PT0gMCkgZHkgPCAxID8gcGkxIDogcGkyXG4gICAgaWYgKGR5ID09PSAwKSBkeCA8IDAgPyBNYXRoLlBJIDogMFxuICAgIGlmIChkeCA8IDApIHJldHVybiBNYXRoLlBJICsgTWF0aC5hdGFuKGR5IC8gZHgpXG4gICAgaWYgKGR5IDwgMCkgcmV0dXJuIDIgKiBNYXRoLlBJICsgTWF0aC5hdGFuKGR5IC8gZHgpXG4gICAgcmV0dXJuIE1hdGguYXRhbihkeSAvIGR4KVxuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../src/Point.js\n");

/***/ }),

/***/ "../src/createGraphFromGeoJson.js":
/*!****************************************!*\
  !*** ../src/createGraphFromGeoJson.js ***!
  \****************************************/
/*! exports provided: loadPoints, restoreOriginalPointsAndEdges, getVisibleNodes, addStartingAndEndingNodes, getObstructingEdge, isVisible, createGraphFromGeoJson */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadPoints\", function() { return loadPoints; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"restoreOriginalPointsAndEdges\", function() { return restoreOriginalPointsAndEdges; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getVisibleNodes\", function() { return getVisibleNodes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addStartingAndEndingNodes\", function() { return addStartingAndEndingNodes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getObstructingEdge\", function() { return getObstructingEdge; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isVisible\", function() { return isVisible; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createGraphFromGeoJson\", function() { return createGraphFromGeoJson; });\n/* harmony import */ var ngraph_graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ngraph.graph */ \"../node_modules/ngraph.graph/index.js\");\n/* harmony import */ var ngraph_graph__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ngraph_graph__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _EdgeKeys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EdgeKeys */ \"../src/EdgeKeys.js\");\n/* harmony import */ var _EdgeKey__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EdgeKey */ \"../src/EdgeKey.js\");\n/* harmony import */ var _Point__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Point */ \"../src/Point.js\");\n/* harmony import */ var _setupStructure__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./setupStructure */ \"../src/setupStructure.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils */ \"../src/utils.js\");\n/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./debug */ \"../src/debug.js\");\n/* harmony import */ var _Edge__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Edge */ \"../src/Edge.js\");\n\n\n\n\n\n\n //eslint-disable-line\n\n\n\nconst points = []\nconst edges = []\nconst polygons = []\nvar originalPointsLength = 0\nvar originalEdgesLength = 0\n\nfunction loadPoints (geojson) {\n  Object(_setupStructure__WEBPACK_IMPORTED_MODULE_4__[\"setupStructure\"])(geojson, edges, points, polygons)\n  originalPointsLength = points.length\n  originalEdgesLength = edges.length\n}\n\nfunction restoreOriginalPointsAndEdges() {\n  while(points.length > originalPointsLength) {\n    points.pop()\n  }\n\n  while(edges.length > originalEdgesLength) {\n    edges.pop()\n  }\n}\n\n// add start and end to nodes and check for visibility\nfunction getVisibleNodes (pt1, start, end) {\n  if(start != null && end != null){\n    // edges.push(new Edge(points[points.length-1], start))\n    edges.push(new _Edge__WEBPACK_IMPORTED_MODULE_7__[\"Edge\"](start, end))\n    // edges.push(new Edge(end, points[0]))\n\n    // start.prevPoint = points[points.length-1]\n    // start.nextPoint = end\n    start.polygonID = -1\n\n    // end.prevPoint = start\n    // end.nextPoint = points[0]\n    end.polygonID = -1\n\n    points.push(start)\n    points.push(end)\n  }\n\n  const g = ngraph_graph__WEBPACK_IMPORTED_MODULE_0___default()()\n  const pointsLen = points.length\n  const clonedPoints = clonePoints()\n\n  for (var i = 0; i < pointsLen; i++) {\n    const p = points[i]\n    if (!p.isPointEqual(pt1)) continue\n\n    const prevPoint = p.prevPoint\n    const nextPoint = p.nextPoint\n\n    sortPoints(p, clonedPoints)\n    // _renderSortedPoints(p, clonedPoints)\n\n    const openEdges = new _EdgeKeys__WEBPACK_IMPORTED_MODULE_1__[\"EdgeKeys\"]()\n    const pointInf = new _Point__WEBPACK_IMPORTED_MODULE_3__[\"Point\"]([_utils__WEBPACK_IMPORTED_MODULE_5__[\"INF\"], p.y], null)\n    for (let ii = 0; ii < pointsLen; ii++) {\n      const e = edges[ii]\n      if (typeof e != 'undefined' && e.containsPoint(p)) continue\n      if (typeof e != 'undefined' && Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"edgeIntersect\"])(p, pointInf, e)) {\n        if (Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"onSegment\"])(p, e.p1, pointInf) || Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"onSegment\"])(p, e.p2, pointInf)) continue\n        openEdges.addKey(new _EdgeKey__WEBPACK_IMPORTED_MODULE_2__[\"EdgeKey\"](p, pointInf, e))\n      }\n    }\n    // // _renderOpenEdges(p, openEdges.keys)\n\n    const visible = []\n    if(prevPoint) visible.push(prevPoint)\n    if(nextPoint) visible.push(nextPoint)\n    let prev = null\n    let prevVisible = null\n\n    for (let ii = 0; ii < pointsLen; ii++) {\n      const p2 = clonedPoints[ii]\n      // if (!p2.isPointEqual(pt2)) continue\n      if (p2.isPointEqual(p)) continue\n      if (p.angleToPoint(p2) > Math.pi) break\n\n      if (openEdges.keys.length > 0) {\n        for (let iii = 0; iii < p2.edges.length; iii++) {\n          const e = p2.edges[iii]\n          if (Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"ccw\"])(p, p2, e.getOtherPointInEdge(p2)) === -1) {\n            const k = new _EdgeKey__WEBPACK_IMPORTED_MODULE_2__[\"EdgeKey\"](p, p2, e)\n            const index = openEdges.findKeyPosition(k) - 1\n            if (index !== -1 && openEdges.keys[index].matchesOtherKey(k)) {\n              openEdges.keys.splice(index, 1)\n            }\n          }\n        }\n      }\n\n      let isVisible = false\n      if (prev === null || Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"ccw\"])(p, prev, p2) !== 0 || !Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"onSegment\"])(p, prev, p2)) {\n        if (openEdges.keys.length === 0) {\n          isVisible = true\n        } else if (!Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"edgeIntersect\"])(p, p2, openEdges.keys[0].edge)) {\n          isVisible = true\n        }\n      } else if (!prevVisible) {\n        isVisible = false\n      } else {\n        isVisible = true\n        for (let iii = 0; iii < openEdges.keys.length; iii++) {\n          const e = openEdges.keys[iii]\n          if (!e.edge.containsPoint(prev) && Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"edgeIntersect\"])(prev, p2, e.edge)) {\n            isVisible = false\n            break\n          }\n        }\n        if (isVisible && edgeInPolygon(prev, p2)) isVisible = false\n      }\n\n      const isInAdjacentPoints = (prevPoint != null && p2.isPointEqual(prevPoint)) || (nextPoint != null && p2.isPointEqual(nextPoint))\n      if (isVisible && !isInAdjacentPoints) isVisible = !edgeInPolygon(p, p2)\n\n      if (isVisible) visible.push(p2)\n      \n\n      for (let iii = 0; iii < p2.edges.length; iii++) {\n        const e = p2.edges[iii]\n        if (!e.containsPoint(p) && Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"ccw\"])(p, p2, e.getOtherPointInEdge(p2)) === 1) {\n          const k = new _EdgeKey__WEBPACK_IMPORTED_MODULE_2__[\"EdgeKey\"](p, p2, e)\n          openEdges.addKey(k)\n        }\n      }\n\n      prev = p2\n      prevVisible = isVisible\n    }\n\n    return visible;\n\n    // const nodeId = createNodeId(p)\n    // g.addNode(nodeId, { x: p.x, y: p.y })\n\n    // for (var ii = 0; ii < visible.length; ii++) {\n    //   const otherNodeId = createNodeId(visible[ii])\n    //   g.addNode(otherNodeId, { x: visible[ii].x, y: visible[ii].y })\n    //   g.addLink(nodeId, otherNodeId)\n    // }\n  }\n  // return g\n}\n\nfunction addStartingAndEndingNodes (start, end) {\n  // edges.push(new Edge(points[points.length-1], start))\n  edges.push(new _Edge__WEBPACK_IMPORTED_MODULE_7__[\"Edge\"](start, end))\n  // edges.push(new Edge(end, points[0]))\n\n  // start.prevPoint = points[points.length-1]\n  // start.nextPoint = end\n  start.polygonID = -1\n\n  // end.prevPoint = start\n  // end.nextPoint = points[0]\n  end.polygonID = -1\n\n  points.push(start)\n  points.push(end)\n}\n\n\n\nfunction getObstructingEdge (pt1, pt2, polygonPoints) {\n  const g = ngraph_graph__WEBPACK_IMPORTED_MODULE_0___default()()\n  var points = polygonPoints.slice(0)\n  points.push(pt1)\n  points.push(pt2)\n  const pointsLen = points.length\n  const clonedPoints = points.slice(0)\n\n\n  for (var i = 0; i < pointsLen; i++) {\n    const p = points[i]\n    if (!p.isPointEqual(pt1)) continue\n\n    const prevPoint = p.prevPoint\n    const nextPoint = p.nextPoint\n\n    sortPoints(p, clonedPoints)\n    // _renderSortedPoints(p, clonedPoints)\n\n    const openEdges = new _EdgeKeys__WEBPACK_IMPORTED_MODULE_1__[\"EdgeKeys\"]()\n    const pointInf = new _Point__WEBPACK_IMPORTED_MODULE_3__[\"Point\"]([_utils__WEBPACK_IMPORTED_MODULE_5__[\"INF\"], p.y], null)\n    for (let ii = 0; ii < pointsLen; ii++) {\n      const e = edges[ii]\n      if (typeof e != 'undefined' && e.containsPoint(p)) continue\n      if (typeof e != 'undefined' && Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"edgeIntersect\"])(p, pointInf, e)) {\n        if (Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"onSegment\"])(p, e.p1, pointInf) || Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"onSegment\"])(p, e.p2, pointInf)) continue\n        openEdges.addKey(new _EdgeKey__WEBPACK_IMPORTED_MODULE_2__[\"EdgeKey\"](p, pointInf, e))\n      }\n    }\n    // // _renderOpenEdges(p, openEdges.keys)\n\n    const visible = []\n    visible.push(prevPoint)\n    visible.push(nextPoint)\n    let prev = null\n    let prevVisible = null\n\n    for (let ii = 0; ii < pointsLen; ii++) {\n      const p2 = clonedPoints[ii]\n      // if (!p2.isPointEqual(pt2)) continue\n\n      if (p2.isPointEqual(p)) continue\n      if (p.angleToPoint(p2) > Math.pi) break\n\n      if (openEdges.keys.length > 0) {\n        for (let iii = 0; iii < p2.edges.length; iii++) {\n          const e = p2.edges[iii]\n          if (Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"ccw\"])(p, p2, e.getOtherPointInEdge(p2)) === -1) {\n            const k = new _EdgeKey__WEBPACK_IMPORTED_MODULE_2__[\"EdgeKey\"](p, p2, e)\n            const index = openEdges.findKeyPosition(k) - 1\n            if (index !== -1 && openEdges.keys[index].matchesOtherKey(k)) {\n              openEdges.keys.splice(index, 1)\n            }\n          }\n        }\n      }\n\n      if (p2.isPointEqual(pt2))\n        pt2 = pt2\n      let isVisible = false\n      if (prev === null || Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"ccw\"])(p, prev, p2) !== 0 || !Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"onSegment\"])(p, prev, p2)) {\n        if (openEdges.keys.length === 0) {\n          isVisible = true\n        } else if (!Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"edgeIntersect\"])(p, p2, openEdges.keys[0].edge)) {\n          isVisible = true\n        }\n      } else if (!prevVisible) {\n        isVisible = false\n      } else {\n        isVisible = true\n        for (let iii = 0; iii < openEdges.keys.length; iii++) {\n          const e = openEdges.keys[iii]\n          if (!e.edge.containsPoint(prev) && Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"edgeIntersect\"])(prev, p2, e.edge)) {\n            isVisible = false\n            break\n          }\n        }\n        if (isVisible && edgeInPolygon(prev, p2)) isVisible = false\n      }\n\n      const isInAdjacentPoints = (prevPoint != null && p2.isPointEqual(prevPoint)) || (nextPoint != null && p2.isPointEqual(nextPoint))\n      if (isVisible && !isInAdjacentPoints) isVisible = !edgeInPolygon(p, p2)\n\n      // if same polygon visisble\n      if (p.polygonID == p2.polygonID && p.polygonID != -1)\n        isVisible = true\n\n      // if (isVisible) visible.push(p2)\n      if (p2.isPointEqual(pt2))\n       return isVisible ? null : openEdges.keys[0].edge;\n      \n\n      for (let iii = 0; iii < p2.edges.length; iii++) {\n        const e = p2.edges[iii]\n        if (!e.containsPoint(p) && Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"ccw\"])(p, p2, e.getOtherPointInEdge(p2)) === 1) {\n          const k = new _EdgeKey__WEBPACK_IMPORTED_MODULE_2__[\"EdgeKey\"](p, p2, e)\n          openEdges.addKey(k)\n        }\n      }\n\n      prev = p2\n      prevVisible = isVisible\n    }\n\n    // const nodeId = createNodeId(p)\n    // g.addNode(nodeId, { x: p.x, y: p.y })\n\n    // for (var ii = 0; ii < visible.length; ii++) {\n    //   const otherNodeId = createNodeId(visible[ii])\n    //   g.addNode(otherNodeId, { x: visible[ii].x, y: visible[ii].y })\n    //   g.addLink(nodeId, otherNodeId)\n    // }\n  }\n  // return g\n}\n\n// export function getObstructingEdge (pt1, pt2) {\n//   const g = createGraph()\n//   const pointsLen = points.length\n//   const clonedPoints = clonePoints()\n\n//   for (var i = 0; i < pointsLen; i++) {\n//     const p = points[i]\n//     if (!p.isPointEqual(pt1)) continue\n\n//     const prevPoint = p.prevPoint\n//     const nextPoint = p.nextPoint\n\n//     sortPoints(p, clonedPoints)\n//     // _renderSortedPoints(p, clonedPoints)\n\n//     const openEdges = new EdgeKeys()\n//     const pointInf = new Point([INF, p.y], null)\n//     for (let ii = 0; ii < pointsLen; ii++) {\n//       const e = edges[ii]\n//       if (typeof e != 'undefined' && e.containsPoint(p)) continue\n//       if (typeof e != 'undefined' && edgeIntersect(p, pointInf, e)) {\n//         if (onSegment(p, e.p1, pointInf) || onSegment(p, e.p2, pointInf)) continue\n//         openEdges.addKey(new EdgeKey(p, pointInf, e))\n//       }\n//     }\n//     // // _renderOpenEdges(p, openEdges.keys)\n\n//     const visible = []\n//     visible.push(prevPoint)\n//     visible.push(nextPoint)\n//     let prev = null\n//     let prevVisible = null\n\n//     for (let ii = 0; ii < pointsLen; ii++) {\n//       const p2 = clonedPoints[ii]\n//       // if (!p2.isPointEqual(pt2)) continue\n\n//       if (p2.isPointEqual(p)) continue\n//       if (p.angleToPoint(p2) > Math.pi) break\n\n//       if (openEdges.keys.length > 0) {\n//         for (let iii = 0; iii < p2.edges.length; iii++) {\n//           const e = p2.edges[iii]\n//           if (ccw(p, p2, e.getOtherPointInEdge(p2)) === -1) {\n//             const k = new EdgeKey(p, p2, e)\n//             const index = openEdges.findKeyPosition(k) - 1\n//             if (index !== -1 && openEdges.keys[index].matchesOtherKey(k)) {\n//               openEdges.keys.splice(index, 1)\n//             }\n//           }\n//         }\n//       }\n\n//       if (p2.isPointEqual(pt2))\n//         pt2 = pt2\n//       let isVisible = false\n//       if (prev === null || ccw(p, prev, p2) !== 0 || !onSegment(p, prev, p2)) {\n//         if (openEdges.keys.length === 0) {\n//           isVisible = true\n//         } else if (!edgeIntersect(p, p2, openEdges.keys[0].edge)) {\n//           isVisible = true\n//         }\n//       } else if (!prevVisible) {\n//         isVisible = false\n//       } else {\n//         isVisible = true\n//         for (let iii = 0; iii < openEdges.keys.length; iii++) {\n//           const e = openEdges.keys[iii]\n//           if (!e.edge.containsPoint(prev) && edgeIntersect(prev, p2, e.edge)) {\n//             isVisible = false\n//             break\n//           }\n//         }\n//         if (isVisible && edgeInPolygon(prev, p2)) isVisible = false\n//       }\n\n//       const isInAdjacentPoints = (prevPoint != null && p2.isPointEqual(prevPoint)) || (nextPoint != null && p2.isPointEqual(nextPoint))\n//       if (isVisible && !isInAdjacentPoints) isVisible = !edgeInPolygon(p, p2)\n\n//       // if same polygon visisble\n//       if (p.polygonID == p2.polygonID && p.polygonID != -1)\n//         isVisible = true\n\n//       // if (isVisible) visible.push(p2)\n//       if (p2.isPointEqual(pt2))\n//        return isVisible ? null : openEdges.keys[0].edge;\n      \n\n//       for (let iii = 0; iii < p2.edges.length; iii++) {\n//         const e = p2.edges[iii]\n//         if (!e.containsPoint(p) && ccw(p, p2, e.getOtherPointInEdge(p2)) === 1) {\n//           const k = new EdgeKey(p, p2, e)\n//           openEdges.addKey(k)\n//         }\n//       }\n\n//       prev = p2\n//       prevVisible = isVisible\n//     }\n\n//     // const nodeId = createNodeId(p)\n//     // g.addNode(nodeId, { x: p.x, y: p.y })\n\n//     // for (var ii = 0; ii < visible.length; ii++) {\n//     //   const otherNodeId = createNodeId(visible[ii])\n//     //   g.addNode(otherNodeId, { x: visible[ii].x, y: visible[ii].y })\n//     //   g.addLink(nodeId, otherNodeId)\n//     // }\n//   }\n//   // return g\n// }\n\nfunction isVisible (pt1, pt2) {\n  const g = ngraph_graph__WEBPACK_IMPORTED_MODULE_0___default()()\n  const pointsLen = points.length\n  const clonedPoints = clonePoints()\n\n  for (var i = 0; i < pointsLen; i++) {\n    const p = points[i]\n    if (!p.isPointEqual(pt1)) continue\n\n    const prevPoint = p.prevPoint\n    const nextPoint = p.nextPoint\n\n    sortPoints(p, clonedPoints)\n    // _renderSortedPoints(p, clonedPoints)\n\n    const openEdges = new _EdgeKeys__WEBPACK_IMPORTED_MODULE_1__[\"EdgeKeys\"]()\n    const pointInf = new _Point__WEBPACK_IMPORTED_MODULE_3__[\"Point\"]([_utils__WEBPACK_IMPORTED_MODULE_5__[\"INF\"], p.y], null)\n    for (let ii = 0; ii < pointsLen; ii++) {\n      const e = edges[ii]\n      if (typeof e != 'undefined' && e.containsPoint(p)) continue\n      if (typeof e != 'undefined' && Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"edgeIntersect\"])(p, pointInf, e)) {\n        if (Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"onSegment\"])(p, e.p1, pointInf) || Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"onSegment\"])(p, e.p2, pointInf)) continue\n        openEdges.addKey(new _EdgeKey__WEBPACK_IMPORTED_MODULE_2__[\"EdgeKey\"](p, pointInf, e))\n      }\n    }\n    // // _renderOpenEdges(p, openEdges.keys)\n\n    const visible = []\n    visible.push(prevPoint)\n    visible.push(nextPoint)\n    let prev = null\n    let prevVisible = null\n\n    for (let ii = 0; ii < pointsLen; ii++) {\n      const p2 = clonedPoints[ii]\n      // if (!p2.isPointEqual(pt2)) continue\n\n      if (p2.isPointEqual(p)) continue\n      if (p.angleToPoint(p2) > Math.pi) break\n\n      if (openEdges.keys.length > 0) {\n        for (let iii = 0; iii < p2.edges.length; iii++) {\n          const e = p2.edges[iii]\n          if (Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"ccw\"])(p, p2, e.getOtherPointInEdge(p2)) === -1) {\n            const k = new _EdgeKey__WEBPACK_IMPORTED_MODULE_2__[\"EdgeKey\"](p, p2, e)\n            const index = openEdges.findKeyPosition(k) - 1\n            if (index !== -1 && openEdges.keys[index].matchesOtherKey(k)) {\n              openEdges.keys.splice(index, 1)\n            }\n          }\n        }\n      }\n\n      if (p2.isPointEqual(pt2))\n        pt2 = pt2\n      let isVisible = false\n      if (prev === null || Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"ccw\"])(p, prev, p2) !== 0 || !Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"onSegment\"])(p, prev, p2)) {\n        if (openEdges.keys.length === 0) {\n          isVisible = true\n        } else if (!Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"edgeIntersect\"])(p, p2, openEdges.keys[0].edge)) {\n          isVisible = true\n        }\n      } else if (!prevVisible) {\n        isVisible = false\n      } else {\n        isVisible = true\n        for (let iii = 0; iii < openEdges.keys.length; iii++) {\n          const e = openEdges.keys[iii]\n          if (!e.edge.containsPoint(prev) && Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"edgeIntersect\"])(prev, p2, e.edge)) {\n            isVisible = false\n            break\n          }\n        }\n        if (isVisible && edgeInPolygon(prev, p2)) isVisible = false\n      }\n\n      const isInAdjacentPoints = (prevPoint != null && p2.isPointEqual(prevPoint)) || (nextPoint != null && p2.isPointEqual(nextPoint))\n      if (isVisible && !isInAdjacentPoints) isVisible = !edgeInPolygon(p, p2)\n\n      // if (isVisible) visible.push(p2)\n      if (p2.isPointEqual(pt2)) return isVisible;\n      \n\n      for (let iii = 0; iii < p2.edges.length; iii++) {\n        const e = p2.edges[iii]\n        if (!e.containsPoint(p) && Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"ccw\"])(p, p2, e.getOtherPointInEdge(p2)) === 1) {\n          const k = new _EdgeKey__WEBPACK_IMPORTED_MODULE_2__[\"EdgeKey\"](p, p2, e)\n          openEdges.addKey(k)\n        }\n      }\n\n      prev = p2\n      prevVisible = isVisible\n    }\n\n    // const nodeId = createNodeId(p)\n    // g.addNode(nodeId, { x: p.x, y: p.y })\n\n    // for (var ii = 0; ii < visible.length; ii++) {\n    //   const otherNodeId = createNodeId(visible[ii])\n    //   g.addNode(otherNodeId, { x: visible[ii].x, y: visible[ii].y })\n    //   g.addLink(nodeId, otherNodeId)\n    // }\n  }\n  // return g\n}\n\nfunction createGraphFromGeoJson (geojson) {\n\n  Object(_setupStructure__WEBPACK_IMPORTED_MODULE_4__[\"setupStructure\"])(geojson, edges, points, polygons)\n\n  return processGraph()\n}\n\n  function processGraph () {\n    const g = ngraph_graph__WEBPACK_IMPORTED_MODULE_0___default()()\n    const pointsLen = points.length\n    const clonedPoints = clonePoints()\n\n    for (var i = 0; i < pointsLen; i++) {\n      const p = points[i]\n      const prevPoint = p.prevPoint\n      const nextPoint = p.nextPoint\n\n      // sortPoints(p, clonedPoints)\n      // _renderSortedPoints(p, clonedPoints)\n\n      // const openEdges = new EdgeKeys()\n      // const pointInf = new Point([INF, p.y], null)\n      // for (let ii = 0; ii < pointsLen; ii++) {\n      //   const e = edges[ii]\n      //   if (e.containsPoint(p)) continue\n      //   if (edgeIntersect(p, pointInf, e)) {\n      //     if (onSegment(p, e.p1, pointInf) || onSegment(p, e.p2, pointInf)) continue\n      //     openEdges.addKey(new EdgeKey(p, pointInf, e))\n      //   }\n      // }\n      // // _renderOpenEdges(p, openEdges.keys)\n\n      const visible = []\n      if(i == 0)\n        visible.push(prevPoint)\n\n      visible.push(nextPoint)\n      let prev = null\n      let prevVisible = null\n\n      // for (let ii = 0; ii < pointsLen; ii++) {\n      //   const p2 = clonedPoints[ii]\n      //   if (p2.isPointEqual(p)) continue\n      //   if (p.angleToPoint(p2) > Math.pi) break\n\n      //   if (openEdges.keys.length > 0) {\n      //     for (let iii = 0; iii < p2.edges.length; iii++) {\n      //       const e = p2.edges[iii]\n      //       if (ccw(p, p2, e.getOtherPointInEdge(p2)) === -1) {\n      //         const k = new EdgeKey(p, p2, e)\n      //         const index = openEdges.findKeyPosition(k) - 1\n      //         if (index !== -1 && openEdges.keys[index].matchesOtherKey(k)) {\n      //           openEdges.keys.splice(index, 1)\n      //         }\n      //       }\n      //     }\n      //   }\n\n      //   let isVisible = false\n      //   if (prev === null || ccw(p, prev, p2) !== 0 || !onSegment(p, prev, p2)) {\n      //     if (openEdges.keys.length === 0) {\n      //       isVisible = true\n      //     } else if (!edgeIntersect(p, p2, openEdges.keys[0].edge)) {\n      //       isVisible = true\n      //     }\n      //   } else if (!prevVisible) {\n      //     isVisible = false\n      //   } else {\n      //     isVisible = true\n      //     for (let iii = 0; iii < openEdges.keys.length; iii++) {\n      //       const e = openEdges.keys[iii]\n      //       if (!e.edge.containsPoint(prev) && edgeIntersect(prev, p2, e.edge)) {\n      //         isVisible = false\n      //         break\n      //       }\n      //     }\n      //     if (isVisible && edgeInPolygon(prev, p2)) isVisible = false\n      //   }\n\n      //   const isInAdjacentPoints = p2.isPointEqual(prevPoint) || p2.isPointEqual(nextPoint)\n      //   if (isVisible && !isInAdjacentPoints) isVisible = !edgeInPolygon(p, p2)\n\n      //   if (isVisible) visible.push(p2)\n\n      //   for (let iii = 0; iii < p2.edges.length; iii++) {\n      //     const e = p2.edges[iii]\n      //     if (!e.containsPoint(p) && ccw(p, p2, e.getOtherPointInEdge(p2)) === 1) {\n      //       const k = new EdgeKey(p, p2, e)\n      //       openEdges.addKey(k)\n      //     }\n      //   }\n\n      //   prev = p2\n      //   prevVisible = isVisible\n      // }\n\n      const nodeId = createNodeId(p)\n      g.addNode(nodeId, { x: p.x, y: p.y })\n\n      for (var ii = 0; ii < visible.length; ii++) {\n        const otherNodeId = createNodeId(visible[ii])\n        g.addNode(otherNodeId, { x: visible[ii].x, y: visible[ii].y })\n        g.addLink(nodeId, otherNodeId)\n      }\n    }\n    return g\n  }\n\n  function createNodeId (p) {\n    return p.x + ',' + p.y\n  }\n\n  function clonePoints () {\n    return points.slice(0)\n  }\n\n  function sortPoints (point, clonedPoints) {\n    clonedPoints.sort((a, b) => {\n      const angle1 = point.angleToPoint(a)\n      const angle2 = point.angleToPoint(b)\n      if (angle1 < angle2) return -1\n      if (angle1 > angle2) return 1\n      const dist1 = Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"calcEdgeDistance\"])(point, a)\n      const dist2 = Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"calcEdgeDistance\"])(point, b)\n      if (dist1 < dist2) return -1\n      if (dist1 > dist2) return 1\n      return 0\n    })\n  }\n\n  function edgeInPolygon (p1, p2) {\n    if (p1.polygonID !== p2.polygonID) return false\n    if (p1.polygonID === -1 || p2.polygonID === -1) return false\n    const midPoint = new _Point__WEBPACK_IMPORTED_MODULE_3__[\"Point\"]([(p1.x + p2.x) / 2, (p1.y + p2.y) / 2], null)\n    return polygonCrossing(midPoint, polygons[p1.polygonID])\n  }\n\n  function polygonCrossing (p1, polyEdges) {\n    const p2 = new _Point__WEBPACK_IMPORTED_MODULE_3__[\"Point\"]([_utils__WEBPACK_IMPORTED_MODULE_5__[\"INF\"], p1.y], null)\n    let intersectCount = 0\n    let coFlag = false\n    let coDir = 0\n\n    for (let i = 0; i < polyEdges.length; i++) {\n      const e = polyEdges[i]\n      if (p1.y < e.p1.y && p1.y < e.p2.y) continue\n      if (p1.y > e.p1.y && p1.y > e.p2.y) continue\n      const co0 = (Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"ccw\"])(p1, e.p1, p2) === 0) && (e.p1.x > p1.x)\n      const co1 = (Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"ccw\"])(p1, e.p2, p2) === 0) && (e.p2.x > p1.x)\n      const coPoint = co0 ? e.p1 : e.p2\n      if (co0 || co1) {\n        coDir = e.getOtherPointInEdge(coPoint).y > p1.y ? coDir++ : coDir--\n        if (coFlag) {\n          if (coDir === 0) intersectCount++\n          coFlag = false\n          coDir = 0\n        } else {\n          coFlag = true\n        }\n      } else if (Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"edgeIntersect\"])(p1, p2, e)) {\n        intersectCount++\n      }\n    }\n    if (intersectCount % 2 === 0) return false\n    return true\n  }\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NyZWF0ZUdyYXBoRnJvbUdlb0pzb24uanM/MzkzNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQXNDO0FBQ0Q7QUFDRjtBQUNKO0FBQ2tCO0FBQzZCO0FBQ2Y7O0FBRWxDOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1AsRUFBRSxzRUFBYztBQUNoQjtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDTztBQUNQO0FBQ0E7QUFDQSxtQkFBbUIsMENBQUk7QUFDdkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxtREFBVztBQUN2QjtBQUNBOztBQUVBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBCQUEwQixrREFBUTtBQUNsQyx5QkFBeUIsNENBQUssRUFBRSwwQ0FBRztBQUNuQyxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQSxxQ0FBcUMsNERBQWE7QUFDbEQsWUFBWSx3REFBUyx1QkFBdUIsd0RBQVM7QUFDckQsNkJBQTZCLGdEQUFPO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0EsY0FBYyxrREFBRztBQUNqQiwwQkFBMEIsZ0RBQU87QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsa0RBQUcsd0JBQXdCLHdEQUFTO0FBQy9EO0FBQ0E7QUFDQSxTQUFTLFdBQVcsNERBQWE7QUFDakM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLHlCQUF5Qiw2QkFBNkI7QUFDdEQ7QUFDQSw2Q0FBNkMsNERBQWE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQSxtQ0FBbUMsa0RBQUc7QUFDdEMsd0JBQXdCLGdEQUFPO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwwQkFBMEIsaUJBQWlCOztBQUUzQyx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0EsaUNBQWlDLHFDQUFxQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQSxpQkFBaUIsMENBQUk7QUFDckI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJTztBQUNQLFlBQVksbURBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMEJBQTBCLGtEQUFRO0FBQ2xDLHlCQUF5Qiw0Q0FBSyxFQUFFLDBDQUFHO0FBQ25DLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBLHFDQUFxQyw0REFBYTtBQUNsRCxZQUFZLHdEQUFTLHVCQUF1Qix3REFBUztBQUNyRCw2QkFBNkIsZ0RBQU87QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0EsY0FBYyxrREFBRztBQUNqQiwwQkFBMEIsZ0RBQU87QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtEQUFHLHdCQUF3Qix3REFBUztBQUMvRDtBQUNBO0FBQ0EsU0FBUyxXQUFXLDREQUFhO0FBQ2pDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSx5QkFBeUIsNkJBQTZCO0FBQ3REO0FBQ0EsNkNBQTZDLDREQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQSxtQ0FBbUMsa0RBQUc7QUFDdEMsd0JBQXdCLGdEQUFPO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsaUJBQWlCOztBQUUzQyx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0EsaUNBQWlDLHFDQUFxQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSw0QkFBNEIsNkJBQTZCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQSwwQkFBMEIsdUJBQXVCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsaUJBQWlCOztBQUU5QywwQkFBMEIscUJBQXFCO0FBQy9DO0FBQ0Esb0NBQW9DLHFDQUFxQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1AsWUFBWSxtREFBVztBQUN2QjtBQUNBOztBQUVBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBCQUEwQixrREFBUTtBQUNsQyx5QkFBeUIsNENBQUssRUFBRSwwQ0FBRztBQUNuQyxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQSxxQ0FBcUMsNERBQWE7QUFDbEQsWUFBWSx3REFBUyx1QkFBdUIsd0RBQVM7QUFDckQsNkJBQTZCLGdEQUFPO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBLGNBQWMsa0RBQUc7QUFDakIsMEJBQTBCLGdEQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrREFBRyx3QkFBd0Isd0RBQVM7QUFDL0Q7QUFDQTtBQUNBLFNBQVMsV0FBVyw0REFBYTtBQUNqQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EseUJBQXlCLDZCQUE2QjtBQUN0RDtBQUNBLDZDQUE2Qyw0REFBYTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0EsbUNBQW1DLGtEQUFHO0FBQ3RDLHdCQUF3QixnREFBTztBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLGlCQUFpQjs7QUFFM0MsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBLGlDQUFpQyxxQ0FBcUM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTzs7QUFFUCxFQUFFLHNFQUFjOztBQUVoQjtBQUNBOztBQUVBO0FBQ0EsY0FBYyxtREFBVztBQUN6QjtBQUNBOztBQUVBLG1CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsZ0JBQWdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsZ0JBQWdCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4Qix1QkFBdUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBLDhCQUE4Qiw2QkFBNkI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixpQkFBaUI7O0FBRTFDLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQSxnQ0FBZ0MscUNBQXFDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0RBQWdCO0FBQ3BDLG9CQUFvQiwrREFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0Q0FBSztBQUM5QjtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLDRDQUFLLEVBQUUsMENBQUc7QUFDN0I7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtEQUFHO0FBQ3RCLG1CQUFtQixrREFBRztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTyxVQUFVLDREQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuLi9zcmMvY3JlYXRlR3JhcGhGcm9tR2VvSnNvbi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcmVhdGVHcmFwaCBmcm9tICduZ3JhcGguZ3JhcGgnXG5pbXBvcnQgeyBFZGdlS2V5cyB9IGZyb20gJy4vRWRnZUtleXMnXG5pbXBvcnQgeyBFZGdlS2V5IH0gZnJvbSAnLi9FZGdlS2V5J1xuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuL1BvaW50J1xuaW1wb3J0IHsgc2V0dXBTdHJ1Y3R1cmUgfSBmcm9tICcuL3NldHVwU3RydWN0dXJlJ1xuaW1wb3J0IHsgSU5GLCBlZGdlSW50ZXJzZWN0LCBvblNlZ21lbnQsIGNjdywgY2FsY0VkZ2VEaXN0YW5jZSB9IGZyb20gJy4vdXRpbHMnXG5pbXBvcnQgeyBfcmVuZGVyU29ydGVkUG9pbnRzLCBfcmVuZGVyT3BlbkVkZ2VzIH0gZnJvbSAnLi9kZWJ1ZycgLy9lc2xpbnQtZGlzYWJsZS1saW5lXG5cbmltcG9ydCB7IEVkZ2UgfSBmcm9tICcuL0VkZ2UnXG5cbmNvbnN0IHBvaW50cyA9IFtdXG5jb25zdCBlZGdlcyA9IFtdXG5jb25zdCBwb2x5Z29ucyA9IFtdXG52YXIgb3JpZ2luYWxQb2ludHNMZW5ndGggPSAwXG52YXIgb3JpZ2luYWxFZGdlc0xlbmd0aCA9IDBcblxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRQb2ludHMgKGdlb2pzb24pIHtcbiAgc2V0dXBTdHJ1Y3R1cmUoZ2VvanNvbiwgZWRnZXMsIHBvaW50cywgcG9seWdvbnMpXG4gIG9yaWdpbmFsUG9pbnRzTGVuZ3RoID0gcG9pbnRzLmxlbmd0aFxuICBvcmlnaW5hbEVkZ2VzTGVuZ3RoID0gZWRnZXMubGVuZ3RoXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXN0b3JlT3JpZ2luYWxQb2ludHNBbmRFZGdlcygpIHtcbiAgd2hpbGUocG9pbnRzLmxlbmd0aCA+IG9yaWdpbmFsUG9pbnRzTGVuZ3RoKSB7XG4gICAgcG9pbnRzLnBvcCgpXG4gIH1cblxuICB3aGlsZShlZGdlcy5sZW5ndGggPiBvcmlnaW5hbEVkZ2VzTGVuZ3RoKSB7XG4gICAgZWRnZXMucG9wKClcbiAgfVxufVxuXG4vLyBhZGQgc3RhcnQgYW5kIGVuZCB0byBub2RlcyBhbmQgY2hlY2sgZm9yIHZpc2liaWxpdHlcbmV4cG9ydCBmdW5jdGlvbiBnZXRWaXNpYmxlTm9kZXMgKHB0MSwgc3RhcnQsIGVuZCkge1xuICBpZihzdGFydCAhPSBudWxsICYmIGVuZCAhPSBudWxsKXtcbiAgICAvLyBlZGdlcy5wdXNoKG5ldyBFZGdlKHBvaW50c1twb2ludHMubGVuZ3RoLTFdLCBzdGFydCkpXG4gICAgZWRnZXMucHVzaChuZXcgRWRnZShzdGFydCwgZW5kKSlcbiAgICAvLyBlZGdlcy5wdXNoKG5ldyBFZGdlKGVuZCwgcG9pbnRzWzBdKSlcblxuICAgIC8vIHN0YXJ0LnByZXZQb2ludCA9IHBvaW50c1twb2ludHMubGVuZ3RoLTFdXG4gICAgLy8gc3RhcnQubmV4dFBvaW50ID0gZW5kXG4gICAgc3RhcnQucG9seWdvbklEID0gLTFcblxuICAgIC8vIGVuZC5wcmV2UG9pbnQgPSBzdGFydFxuICAgIC8vIGVuZC5uZXh0UG9pbnQgPSBwb2ludHNbMF1cbiAgICBlbmQucG9seWdvbklEID0gLTFcblxuICAgIHBvaW50cy5wdXNoKHN0YXJ0KVxuICAgIHBvaW50cy5wdXNoKGVuZClcbiAgfVxuXG4gIGNvbnN0IGcgPSBjcmVhdGVHcmFwaCgpXG4gIGNvbnN0IHBvaW50c0xlbiA9IHBvaW50cy5sZW5ndGhcbiAgY29uc3QgY2xvbmVkUG9pbnRzID0gY2xvbmVQb2ludHMoKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzTGVuOyBpKyspIHtcbiAgICBjb25zdCBwID0gcG9pbnRzW2ldXG4gICAgaWYgKCFwLmlzUG9pbnRFcXVhbChwdDEpKSBjb250aW51ZVxuXG4gICAgY29uc3QgcHJldlBvaW50ID0gcC5wcmV2UG9pbnRcbiAgICBjb25zdCBuZXh0UG9pbnQgPSBwLm5leHRQb2ludFxuXG4gICAgc29ydFBvaW50cyhwLCBjbG9uZWRQb2ludHMpXG4gICAgLy8gX3JlbmRlclNvcnRlZFBvaW50cyhwLCBjbG9uZWRQb2ludHMpXG5cbiAgICBjb25zdCBvcGVuRWRnZXMgPSBuZXcgRWRnZUtleXMoKVxuICAgIGNvbnN0IHBvaW50SW5mID0gbmV3IFBvaW50KFtJTkYsIHAueV0sIG51bGwpXG4gICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IHBvaW50c0xlbjsgaWkrKykge1xuICAgICAgY29uc3QgZSA9IGVkZ2VzW2lpXVxuICAgICAgaWYgKHR5cGVvZiBlICE9ICd1bmRlZmluZWQnICYmIGUuY29udGFpbnNQb2ludChwKSkgY29udGludWVcbiAgICAgIGlmICh0eXBlb2YgZSAhPSAndW5kZWZpbmVkJyAmJiBlZGdlSW50ZXJzZWN0KHAsIHBvaW50SW5mLCBlKSkge1xuICAgICAgICBpZiAob25TZWdtZW50KHAsIGUucDEsIHBvaW50SW5mKSB8fCBvblNlZ21lbnQocCwgZS5wMiwgcG9pbnRJbmYpKSBjb250aW51ZVxuICAgICAgICBvcGVuRWRnZXMuYWRkS2V5KG5ldyBFZGdlS2V5KHAsIHBvaW50SW5mLCBlKSlcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gLy8gX3JlbmRlck9wZW5FZGdlcyhwLCBvcGVuRWRnZXMua2V5cylcblxuICAgIGNvbnN0IHZpc2libGUgPSBbXVxuICAgIGlmKHByZXZQb2ludCkgdmlzaWJsZS5wdXNoKHByZXZQb2ludClcbiAgICBpZihuZXh0UG9pbnQpIHZpc2libGUucHVzaChuZXh0UG9pbnQpXG4gICAgbGV0IHByZXYgPSBudWxsXG4gICAgbGV0IHByZXZWaXNpYmxlID0gbnVsbFxuXG4gICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IHBvaW50c0xlbjsgaWkrKykge1xuICAgICAgY29uc3QgcDIgPSBjbG9uZWRQb2ludHNbaWldXG4gICAgICAvLyBpZiAoIXAyLmlzUG9pbnRFcXVhbChwdDIpKSBjb250aW51ZVxuICAgICAgaWYgKHAyLmlzUG9pbnRFcXVhbChwKSkgY29udGludWVcbiAgICAgIGlmIChwLmFuZ2xlVG9Qb2ludChwMikgPiBNYXRoLnBpKSBicmVha1xuXG4gICAgICBpZiAob3BlbkVkZ2VzLmtleXMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKGxldCBpaWkgPSAwOyBpaWkgPCBwMi5lZGdlcy5sZW5ndGg7IGlpaSsrKSB7XG4gICAgICAgICAgY29uc3QgZSA9IHAyLmVkZ2VzW2lpaV1cbiAgICAgICAgICBpZiAoY2N3KHAsIHAyLCBlLmdldE90aGVyUG9pbnRJbkVkZ2UocDIpKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IGsgPSBuZXcgRWRnZUtleShwLCBwMiwgZSlcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gb3BlbkVkZ2VzLmZpbmRLZXlQb3NpdGlvbihrKSAtIDFcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEgJiYgb3BlbkVkZ2VzLmtleXNbaW5kZXhdLm1hdGNoZXNPdGhlcktleShrKSkge1xuICAgICAgICAgICAgICBvcGVuRWRnZXMua2V5cy5zcGxpY2UoaW5kZXgsIDEpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCBpc1Zpc2libGUgPSBmYWxzZVxuICAgICAgaWYgKHByZXYgPT09IG51bGwgfHwgY2N3KHAsIHByZXYsIHAyKSAhPT0gMCB8fCAhb25TZWdtZW50KHAsIHByZXYsIHAyKSkge1xuICAgICAgICBpZiAob3BlbkVkZ2VzLmtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgaXNWaXNpYmxlID0gdHJ1ZVxuICAgICAgICB9IGVsc2UgaWYgKCFlZGdlSW50ZXJzZWN0KHAsIHAyLCBvcGVuRWRnZXMua2V5c1swXS5lZGdlKSkge1xuICAgICAgICAgIGlzVmlzaWJsZSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghcHJldlZpc2libGUpIHtcbiAgICAgICAgaXNWaXNpYmxlID0gZmFsc2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzVmlzaWJsZSA9IHRydWVcbiAgICAgICAgZm9yIChsZXQgaWlpID0gMDsgaWlpIDwgb3BlbkVkZ2VzLmtleXMubGVuZ3RoOyBpaWkrKykge1xuICAgICAgICAgIGNvbnN0IGUgPSBvcGVuRWRnZXMua2V5c1tpaWldXG4gICAgICAgICAgaWYgKCFlLmVkZ2UuY29udGFpbnNQb2ludChwcmV2KSAmJiBlZGdlSW50ZXJzZWN0KHByZXYsIHAyLCBlLmVkZ2UpKSB7XG4gICAgICAgICAgICBpc1Zpc2libGUgPSBmYWxzZVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVmlzaWJsZSAmJiBlZGdlSW5Qb2x5Z29uKHByZXYsIHAyKSkgaXNWaXNpYmxlID0gZmFsc2VcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXNJbkFkamFjZW50UG9pbnRzID0gKHByZXZQb2ludCAhPSBudWxsICYmIHAyLmlzUG9pbnRFcXVhbChwcmV2UG9pbnQpKSB8fCAobmV4dFBvaW50ICE9IG51bGwgJiYgcDIuaXNQb2ludEVxdWFsKG5leHRQb2ludCkpXG4gICAgICBpZiAoaXNWaXNpYmxlICYmICFpc0luQWRqYWNlbnRQb2ludHMpIGlzVmlzaWJsZSA9ICFlZGdlSW5Qb2x5Z29uKHAsIHAyKVxuXG4gICAgICBpZiAoaXNWaXNpYmxlKSB2aXNpYmxlLnB1c2gocDIpXG4gICAgICBcblxuICAgICAgZm9yIChsZXQgaWlpID0gMDsgaWlpIDwgcDIuZWRnZXMubGVuZ3RoOyBpaWkrKykge1xuICAgICAgICBjb25zdCBlID0gcDIuZWRnZXNbaWlpXVxuICAgICAgICBpZiAoIWUuY29udGFpbnNQb2ludChwKSAmJiBjY3cocCwgcDIsIGUuZ2V0T3RoZXJQb2ludEluRWRnZShwMikpID09PSAxKSB7XG4gICAgICAgICAgY29uc3QgayA9IG5ldyBFZGdlS2V5KHAsIHAyLCBlKVxuICAgICAgICAgIG9wZW5FZGdlcy5hZGRLZXkoaylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcmV2ID0gcDJcbiAgICAgIHByZXZWaXNpYmxlID0gaXNWaXNpYmxlXG4gICAgfVxuXG4gICAgcmV0dXJuIHZpc2libGU7XG5cbiAgICAvLyBjb25zdCBub2RlSWQgPSBjcmVhdGVOb2RlSWQocClcbiAgICAvLyBnLmFkZE5vZGUobm9kZUlkLCB7IHg6IHAueCwgeTogcC55IH0pXG5cbiAgICAvLyBmb3IgKHZhciBpaSA9IDA7IGlpIDwgdmlzaWJsZS5sZW5ndGg7IGlpKyspIHtcbiAgICAvLyAgIGNvbnN0IG90aGVyTm9kZUlkID0gY3JlYXRlTm9kZUlkKHZpc2libGVbaWldKVxuICAgIC8vICAgZy5hZGROb2RlKG90aGVyTm9kZUlkLCB7IHg6IHZpc2libGVbaWldLngsIHk6IHZpc2libGVbaWldLnkgfSlcbiAgICAvLyAgIGcuYWRkTGluayhub2RlSWQsIG90aGVyTm9kZUlkKVxuICAgIC8vIH1cbiAgfVxuICAvLyByZXR1cm4gZ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkU3RhcnRpbmdBbmRFbmRpbmdOb2RlcyAoc3RhcnQsIGVuZCkge1xuICAvLyBlZGdlcy5wdXNoKG5ldyBFZGdlKHBvaW50c1twb2ludHMubGVuZ3RoLTFdLCBzdGFydCkpXG4gIGVkZ2VzLnB1c2gobmV3IEVkZ2Uoc3RhcnQsIGVuZCkpXG4gIC8vIGVkZ2VzLnB1c2gobmV3IEVkZ2UoZW5kLCBwb2ludHNbMF0pKVxuXG4gIC8vIHN0YXJ0LnByZXZQb2ludCA9IHBvaW50c1twb2ludHMubGVuZ3RoLTFdXG4gIC8vIHN0YXJ0Lm5leHRQb2ludCA9IGVuZFxuICBzdGFydC5wb2x5Z29uSUQgPSAtMVxuXG4gIC8vIGVuZC5wcmV2UG9pbnQgPSBzdGFydFxuICAvLyBlbmQubmV4dFBvaW50ID0gcG9pbnRzWzBdXG4gIGVuZC5wb2x5Z29uSUQgPSAtMVxuXG4gIHBvaW50cy5wdXNoKHN0YXJ0KVxuICBwb2ludHMucHVzaChlbmQpXG59XG5cblxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0T2JzdHJ1Y3RpbmdFZGdlIChwdDEsIHB0MiwgcG9seWdvblBvaW50cykge1xuICBjb25zdCBnID0gY3JlYXRlR3JhcGgoKVxuICB2YXIgcG9pbnRzID0gcG9seWdvblBvaW50cy5zbGljZSgwKVxuICBwb2ludHMucHVzaChwdDEpXG4gIHBvaW50cy5wdXNoKHB0MilcbiAgY29uc3QgcG9pbnRzTGVuID0gcG9pbnRzLmxlbmd0aFxuICBjb25zdCBjbG9uZWRQb2ludHMgPSBwb2ludHMuc2xpY2UoMClcblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzTGVuOyBpKyspIHtcbiAgICBjb25zdCBwID0gcG9pbnRzW2ldXG4gICAgaWYgKCFwLmlzUG9pbnRFcXVhbChwdDEpKSBjb250aW51ZVxuXG4gICAgY29uc3QgcHJldlBvaW50ID0gcC5wcmV2UG9pbnRcbiAgICBjb25zdCBuZXh0UG9pbnQgPSBwLm5leHRQb2ludFxuXG4gICAgc29ydFBvaW50cyhwLCBjbG9uZWRQb2ludHMpXG4gICAgLy8gX3JlbmRlclNvcnRlZFBvaW50cyhwLCBjbG9uZWRQb2ludHMpXG5cbiAgICBjb25zdCBvcGVuRWRnZXMgPSBuZXcgRWRnZUtleXMoKVxuICAgIGNvbnN0IHBvaW50SW5mID0gbmV3IFBvaW50KFtJTkYsIHAueV0sIG51bGwpXG4gICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IHBvaW50c0xlbjsgaWkrKykge1xuICAgICAgY29uc3QgZSA9IGVkZ2VzW2lpXVxuICAgICAgaWYgKHR5cGVvZiBlICE9ICd1bmRlZmluZWQnICYmIGUuY29udGFpbnNQb2ludChwKSkgY29udGludWVcbiAgICAgIGlmICh0eXBlb2YgZSAhPSAndW5kZWZpbmVkJyAmJiBlZGdlSW50ZXJzZWN0KHAsIHBvaW50SW5mLCBlKSkge1xuICAgICAgICBpZiAob25TZWdtZW50KHAsIGUucDEsIHBvaW50SW5mKSB8fCBvblNlZ21lbnQocCwgZS5wMiwgcG9pbnRJbmYpKSBjb250aW51ZVxuICAgICAgICBvcGVuRWRnZXMuYWRkS2V5KG5ldyBFZGdlS2V5KHAsIHBvaW50SW5mLCBlKSlcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gLy8gX3JlbmRlck9wZW5FZGdlcyhwLCBvcGVuRWRnZXMua2V5cylcblxuICAgIGNvbnN0IHZpc2libGUgPSBbXVxuICAgIHZpc2libGUucHVzaChwcmV2UG9pbnQpXG4gICAgdmlzaWJsZS5wdXNoKG5leHRQb2ludClcbiAgICBsZXQgcHJldiA9IG51bGxcbiAgICBsZXQgcHJldlZpc2libGUgPSBudWxsXG5cbiAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgcG9pbnRzTGVuOyBpaSsrKSB7XG4gICAgICBjb25zdCBwMiA9IGNsb25lZFBvaW50c1tpaV1cbiAgICAgIC8vIGlmICghcDIuaXNQb2ludEVxdWFsKHB0MikpIGNvbnRpbnVlXG5cbiAgICAgIGlmIChwMi5pc1BvaW50RXF1YWwocCkpIGNvbnRpbnVlXG4gICAgICBpZiAocC5hbmdsZVRvUG9pbnQocDIpID4gTWF0aC5waSkgYnJlYWtcblxuICAgICAgaWYgKG9wZW5FZGdlcy5rZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yIChsZXQgaWlpID0gMDsgaWlpIDwgcDIuZWRnZXMubGVuZ3RoOyBpaWkrKykge1xuICAgICAgICAgIGNvbnN0IGUgPSBwMi5lZGdlc1tpaWldXG4gICAgICAgICAgaWYgKGNjdyhwLCBwMiwgZS5nZXRPdGhlclBvaW50SW5FZGdlKHAyKSkgPT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBrID0gbmV3IEVkZ2VLZXkocCwgcDIsIGUpXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IG9wZW5FZGdlcy5maW5kS2V5UG9zaXRpb24oaykgLSAxXG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xICYmIG9wZW5FZGdlcy5rZXlzW2luZGV4XS5tYXRjaGVzT3RoZXJLZXkoaykpIHtcbiAgICAgICAgICAgICAgb3BlbkVkZ2VzLmtleXMuc3BsaWNlKGluZGV4LCAxKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocDIuaXNQb2ludEVxdWFsKHB0MikpXG4gICAgICAgIHB0MiA9IHB0MlxuICAgICAgbGV0IGlzVmlzaWJsZSA9IGZhbHNlXG4gICAgICBpZiAocHJldiA9PT0gbnVsbCB8fCBjY3cocCwgcHJldiwgcDIpICE9PSAwIHx8ICFvblNlZ21lbnQocCwgcHJldiwgcDIpKSB7XG4gICAgICAgIGlmIChvcGVuRWRnZXMua2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpc1Zpc2libGUgPSB0cnVlXG4gICAgICAgIH0gZWxzZSBpZiAoIWVkZ2VJbnRlcnNlY3QocCwgcDIsIG9wZW5FZGdlcy5rZXlzWzBdLmVkZ2UpKSB7XG4gICAgICAgICAgaXNWaXNpYmxlID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFwcmV2VmlzaWJsZSkge1xuICAgICAgICBpc1Zpc2libGUgPSBmYWxzZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNWaXNpYmxlID0gdHJ1ZVxuICAgICAgICBmb3IgKGxldCBpaWkgPSAwOyBpaWkgPCBvcGVuRWRnZXMua2V5cy5sZW5ndGg7IGlpaSsrKSB7XG4gICAgICAgICAgY29uc3QgZSA9IG9wZW5FZGdlcy5rZXlzW2lpaV1cbiAgICAgICAgICBpZiAoIWUuZWRnZS5jb250YWluc1BvaW50KHByZXYpICYmIGVkZ2VJbnRlcnNlY3QocHJldiwgcDIsIGUuZWRnZSkpIHtcbiAgICAgICAgICAgIGlzVmlzaWJsZSA9IGZhbHNlXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNWaXNpYmxlICYmIGVkZ2VJblBvbHlnb24ocHJldiwgcDIpKSBpc1Zpc2libGUgPSBmYWxzZVxuICAgICAgfVxuXG4gICAgICBjb25zdCBpc0luQWRqYWNlbnRQb2ludHMgPSAocHJldlBvaW50ICE9IG51bGwgJiYgcDIuaXNQb2ludEVxdWFsKHByZXZQb2ludCkpIHx8IChuZXh0UG9pbnQgIT0gbnVsbCAmJiBwMi5pc1BvaW50RXF1YWwobmV4dFBvaW50KSlcbiAgICAgIGlmIChpc1Zpc2libGUgJiYgIWlzSW5BZGphY2VudFBvaW50cykgaXNWaXNpYmxlID0gIWVkZ2VJblBvbHlnb24ocCwgcDIpXG5cbiAgICAgIC8vIGlmIHNhbWUgcG9seWdvbiB2aXNpc2JsZVxuICAgICAgaWYgKHAucG9seWdvbklEID09IHAyLnBvbHlnb25JRCAmJiBwLnBvbHlnb25JRCAhPSAtMSlcbiAgICAgICAgaXNWaXNpYmxlID0gdHJ1ZVxuXG4gICAgICAvLyBpZiAoaXNWaXNpYmxlKSB2aXNpYmxlLnB1c2gocDIpXG4gICAgICBpZiAocDIuaXNQb2ludEVxdWFsKHB0MikpXG4gICAgICAgcmV0dXJuIGlzVmlzaWJsZSA/IG51bGwgOiBvcGVuRWRnZXMua2V5c1swXS5lZGdlO1xuICAgICAgXG5cbiAgICAgIGZvciAobGV0IGlpaSA9IDA7IGlpaSA8IHAyLmVkZ2VzLmxlbmd0aDsgaWlpKyspIHtcbiAgICAgICAgY29uc3QgZSA9IHAyLmVkZ2VzW2lpaV1cbiAgICAgICAgaWYgKCFlLmNvbnRhaW5zUG9pbnQocCkgJiYgY2N3KHAsIHAyLCBlLmdldE90aGVyUG9pbnRJbkVkZ2UocDIpKSA9PT0gMSkge1xuICAgICAgICAgIGNvbnN0IGsgPSBuZXcgRWRnZUtleShwLCBwMiwgZSlcbiAgICAgICAgICBvcGVuRWRnZXMuYWRkS2V5KGspXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHJldiA9IHAyXG4gICAgICBwcmV2VmlzaWJsZSA9IGlzVmlzaWJsZVxuICAgIH1cblxuICAgIC8vIGNvbnN0IG5vZGVJZCA9IGNyZWF0ZU5vZGVJZChwKVxuICAgIC8vIGcuYWRkTm9kZShub2RlSWQsIHsgeDogcC54LCB5OiBwLnkgfSlcblxuICAgIC8vIGZvciAodmFyIGlpID0gMDsgaWkgPCB2aXNpYmxlLmxlbmd0aDsgaWkrKykge1xuICAgIC8vICAgY29uc3Qgb3RoZXJOb2RlSWQgPSBjcmVhdGVOb2RlSWQodmlzaWJsZVtpaV0pXG4gICAgLy8gICBnLmFkZE5vZGUob3RoZXJOb2RlSWQsIHsgeDogdmlzaWJsZVtpaV0ueCwgeTogdmlzaWJsZVtpaV0ueSB9KVxuICAgIC8vICAgZy5hZGRMaW5rKG5vZGVJZCwgb3RoZXJOb2RlSWQpXG4gICAgLy8gfVxuICB9XG4gIC8vIHJldHVybiBnXG59XG5cbi8vIGV4cG9ydCBmdW5jdGlvbiBnZXRPYnN0cnVjdGluZ0VkZ2UgKHB0MSwgcHQyKSB7XG4vLyAgIGNvbnN0IGcgPSBjcmVhdGVHcmFwaCgpXG4vLyAgIGNvbnN0IHBvaW50c0xlbiA9IHBvaW50cy5sZW5ndGhcbi8vICAgY29uc3QgY2xvbmVkUG9pbnRzID0gY2xvbmVQb2ludHMoKVxuXG4vLyAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzTGVuOyBpKyspIHtcbi8vICAgICBjb25zdCBwID0gcG9pbnRzW2ldXG4vLyAgICAgaWYgKCFwLmlzUG9pbnRFcXVhbChwdDEpKSBjb250aW51ZVxuXG4vLyAgICAgY29uc3QgcHJldlBvaW50ID0gcC5wcmV2UG9pbnRcbi8vICAgICBjb25zdCBuZXh0UG9pbnQgPSBwLm5leHRQb2ludFxuXG4vLyAgICAgc29ydFBvaW50cyhwLCBjbG9uZWRQb2ludHMpXG4vLyAgICAgLy8gX3JlbmRlclNvcnRlZFBvaW50cyhwLCBjbG9uZWRQb2ludHMpXG5cbi8vICAgICBjb25zdCBvcGVuRWRnZXMgPSBuZXcgRWRnZUtleXMoKVxuLy8gICAgIGNvbnN0IHBvaW50SW5mID0gbmV3IFBvaW50KFtJTkYsIHAueV0sIG51bGwpXG4vLyAgICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IHBvaW50c0xlbjsgaWkrKykge1xuLy8gICAgICAgY29uc3QgZSA9IGVkZ2VzW2lpXVxuLy8gICAgICAgaWYgKHR5cGVvZiBlICE9ICd1bmRlZmluZWQnICYmIGUuY29udGFpbnNQb2ludChwKSkgY29udGludWVcbi8vICAgICAgIGlmICh0eXBlb2YgZSAhPSAndW5kZWZpbmVkJyAmJiBlZGdlSW50ZXJzZWN0KHAsIHBvaW50SW5mLCBlKSkge1xuLy8gICAgICAgICBpZiAob25TZWdtZW50KHAsIGUucDEsIHBvaW50SW5mKSB8fCBvblNlZ21lbnQocCwgZS5wMiwgcG9pbnRJbmYpKSBjb250aW51ZVxuLy8gICAgICAgICBvcGVuRWRnZXMuYWRkS2V5KG5ldyBFZGdlS2V5KHAsIHBvaW50SW5mLCBlKSlcbi8vICAgICAgIH1cbi8vICAgICB9XG4vLyAgICAgLy8gLy8gX3JlbmRlck9wZW5FZGdlcyhwLCBvcGVuRWRnZXMua2V5cylcblxuLy8gICAgIGNvbnN0IHZpc2libGUgPSBbXVxuLy8gICAgIHZpc2libGUucHVzaChwcmV2UG9pbnQpXG4vLyAgICAgdmlzaWJsZS5wdXNoKG5leHRQb2ludClcbi8vICAgICBsZXQgcHJldiA9IG51bGxcbi8vICAgICBsZXQgcHJldlZpc2libGUgPSBudWxsXG5cbi8vICAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgcG9pbnRzTGVuOyBpaSsrKSB7XG4vLyAgICAgICBjb25zdCBwMiA9IGNsb25lZFBvaW50c1tpaV1cbi8vICAgICAgIC8vIGlmICghcDIuaXNQb2ludEVxdWFsKHB0MikpIGNvbnRpbnVlXG5cbi8vICAgICAgIGlmIChwMi5pc1BvaW50RXF1YWwocCkpIGNvbnRpbnVlXG4vLyAgICAgICBpZiAocC5hbmdsZVRvUG9pbnQocDIpID4gTWF0aC5waSkgYnJlYWtcblxuLy8gICAgICAgaWYgKG9wZW5FZGdlcy5rZXlzLmxlbmd0aCA+IDApIHtcbi8vICAgICAgICAgZm9yIChsZXQgaWlpID0gMDsgaWlpIDwgcDIuZWRnZXMubGVuZ3RoOyBpaWkrKykge1xuLy8gICAgICAgICAgIGNvbnN0IGUgPSBwMi5lZGdlc1tpaWldXG4vLyAgICAgICAgICAgaWYgKGNjdyhwLCBwMiwgZS5nZXRPdGhlclBvaW50SW5FZGdlKHAyKSkgPT09IC0xKSB7XG4vLyAgICAgICAgICAgICBjb25zdCBrID0gbmV3IEVkZ2VLZXkocCwgcDIsIGUpXG4vLyAgICAgICAgICAgICBjb25zdCBpbmRleCA9IG9wZW5FZGdlcy5maW5kS2V5UG9zaXRpb24oaykgLSAxXG4vLyAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xICYmIG9wZW5FZGdlcy5rZXlzW2luZGV4XS5tYXRjaGVzT3RoZXJLZXkoaykpIHtcbi8vICAgICAgICAgICAgICAgb3BlbkVkZ2VzLmtleXMuc3BsaWNlKGluZGV4LCAxKVxuLy8gICAgICAgICAgICAgfVxuLy8gICAgICAgICAgIH1cbi8vICAgICAgICAgfVxuLy8gICAgICAgfVxuXG4vLyAgICAgICBpZiAocDIuaXNQb2ludEVxdWFsKHB0MikpXG4vLyAgICAgICAgIHB0MiA9IHB0MlxuLy8gICAgICAgbGV0IGlzVmlzaWJsZSA9IGZhbHNlXG4vLyAgICAgICBpZiAocHJldiA9PT0gbnVsbCB8fCBjY3cocCwgcHJldiwgcDIpICE9PSAwIHx8ICFvblNlZ21lbnQocCwgcHJldiwgcDIpKSB7XG4vLyAgICAgICAgIGlmIChvcGVuRWRnZXMua2V5cy5sZW5ndGggPT09IDApIHtcbi8vICAgICAgICAgICBpc1Zpc2libGUgPSB0cnVlXG4vLyAgICAgICAgIH0gZWxzZSBpZiAoIWVkZ2VJbnRlcnNlY3QocCwgcDIsIG9wZW5FZGdlcy5rZXlzWzBdLmVkZ2UpKSB7XG4vLyAgICAgICAgICAgaXNWaXNpYmxlID0gdHJ1ZVxuLy8gICAgICAgICB9XG4vLyAgICAgICB9IGVsc2UgaWYgKCFwcmV2VmlzaWJsZSkge1xuLy8gICAgICAgICBpc1Zpc2libGUgPSBmYWxzZVxuLy8gICAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgaXNWaXNpYmxlID0gdHJ1ZVxuLy8gICAgICAgICBmb3IgKGxldCBpaWkgPSAwOyBpaWkgPCBvcGVuRWRnZXMua2V5cy5sZW5ndGg7IGlpaSsrKSB7XG4vLyAgICAgICAgICAgY29uc3QgZSA9IG9wZW5FZGdlcy5rZXlzW2lpaV1cbi8vICAgICAgICAgICBpZiAoIWUuZWRnZS5jb250YWluc1BvaW50KHByZXYpICYmIGVkZ2VJbnRlcnNlY3QocHJldiwgcDIsIGUuZWRnZSkpIHtcbi8vICAgICAgICAgICAgIGlzVmlzaWJsZSA9IGZhbHNlXG4vLyAgICAgICAgICAgICBicmVha1xuLy8gICAgICAgICAgIH1cbi8vICAgICAgICAgfVxuLy8gICAgICAgICBpZiAoaXNWaXNpYmxlICYmIGVkZ2VJblBvbHlnb24ocHJldiwgcDIpKSBpc1Zpc2libGUgPSBmYWxzZVxuLy8gICAgICAgfVxuXG4vLyAgICAgICBjb25zdCBpc0luQWRqYWNlbnRQb2ludHMgPSAocHJldlBvaW50ICE9IG51bGwgJiYgcDIuaXNQb2ludEVxdWFsKHByZXZQb2ludCkpIHx8IChuZXh0UG9pbnQgIT0gbnVsbCAmJiBwMi5pc1BvaW50RXF1YWwobmV4dFBvaW50KSlcbi8vICAgICAgIGlmIChpc1Zpc2libGUgJiYgIWlzSW5BZGphY2VudFBvaW50cykgaXNWaXNpYmxlID0gIWVkZ2VJblBvbHlnb24ocCwgcDIpXG5cbi8vICAgICAgIC8vIGlmIHNhbWUgcG9seWdvbiB2aXNpc2JsZVxuLy8gICAgICAgaWYgKHAucG9seWdvbklEID09IHAyLnBvbHlnb25JRCAmJiBwLnBvbHlnb25JRCAhPSAtMSlcbi8vICAgICAgICAgaXNWaXNpYmxlID0gdHJ1ZVxuXG4vLyAgICAgICAvLyBpZiAoaXNWaXNpYmxlKSB2aXNpYmxlLnB1c2gocDIpXG4vLyAgICAgICBpZiAocDIuaXNQb2ludEVxdWFsKHB0MikpXG4vLyAgICAgICAgcmV0dXJuIGlzVmlzaWJsZSA/IG51bGwgOiBvcGVuRWRnZXMua2V5c1swXS5lZGdlO1xuICAgICAgXG5cbi8vICAgICAgIGZvciAobGV0IGlpaSA9IDA7IGlpaSA8IHAyLmVkZ2VzLmxlbmd0aDsgaWlpKyspIHtcbi8vICAgICAgICAgY29uc3QgZSA9IHAyLmVkZ2VzW2lpaV1cbi8vICAgICAgICAgaWYgKCFlLmNvbnRhaW5zUG9pbnQocCkgJiYgY2N3KHAsIHAyLCBlLmdldE90aGVyUG9pbnRJbkVkZ2UocDIpKSA9PT0gMSkge1xuLy8gICAgICAgICAgIGNvbnN0IGsgPSBuZXcgRWRnZUtleShwLCBwMiwgZSlcbi8vICAgICAgICAgICBvcGVuRWRnZXMuYWRkS2V5KGspXG4vLyAgICAgICAgIH1cbi8vICAgICAgIH1cblxuLy8gICAgICAgcHJldiA9IHAyXG4vLyAgICAgICBwcmV2VmlzaWJsZSA9IGlzVmlzaWJsZVxuLy8gICAgIH1cblxuLy8gICAgIC8vIGNvbnN0IG5vZGVJZCA9IGNyZWF0ZU5vZGVJZChwKVxuLy8gICAgIC8vIGcuYWRkTm9kZShub2RlSWQsIHsgeDogcC54LCB5OiBwLnkgfSlcblxuLy8gICAgIC8vIGZvciAodmFyIGlpID0gMDsgaWkgPCB2aXNpYmxlLmxlbmd0aDsgaWkrKykge1xuLy8gICAgIC8vICAgY29uc3Qgb3RoZXJOb2RlSWQgPSBjcmVhdGVOb2RlSWQodmlzaWJsZVtpaV0pXG4vLyAgICAgLy8gICBnLmFkZE5vZGUob3RoZXJOb2RlSWQsIHsgeDogdmlzaWJsZVtpaV0ueCwgeTogdmlzaWJsZVtpaV0ueSB9KVxuLy8gICAgIC8vICAgZy5hZGRMaW5rKG5vZGVJZCwgb3RoZXJOb2RlSWQpXG4vLyAgICAgLy8gfVxuLy8gICB9XG4vLyAgIC8vIHJldHVybiBnXG4vLyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1Zpc2libGUgKHB0MSwgcHQyKSB7XG4gIGNvbnN0IGcgPSBjcmVhdGVHcmFwaCgpXG4gIGNvbnN0IHBvaW50c0xlbiA9IHBvaW50cy5sZW5ndGhcbiAgY29uc3QgY2xvbmVkUG9pbnRzID0gY2xvbmVQb2ludHMoKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzTGVuOyBpKyspIHtcbiAgICBjb25zdCBwID0gcG9pbnRzW2ldXG4gICAgaWYgKCFwLmlzUG9pbnRFcXVhbChwdDEpKSBjb250aW51ZVxuXG4gICAgY29uc3QgcHJldlBvaW50ID0gcC5wcmV2UG9pbnRcbiAgICBjb25zdCBuZXh0UG9pbnQgPSBwLm5leHRQb2ludFxuXG4gICAgc29ydFBvaW50cyhwLCBjbG9uZWRQb2ludHMpXG4gICAgLy8gX3JlbmRlclNvcnRlZFBvaW50cyhwLCBjbG9uZWRQb2ludHMpXG5cbiAgICBjb25zdCBvcGVuRWRnZXMgPSBuZXcgRWRnZUtleXMoKVxuICAgIGNvbnN0IHBvaW50SW5mID0gbmV3IFBvaW50KFtJTkYsIHAueV0sIG51bGwpXG4gICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IHBvaW50c0xlbjsgaWkrKykge1xuICAgICAgY29uc3QgZSA9IGVkZ2VzW2lpXVxuICAgICAgaWYgKHR5cGVvZiBlICE9ICd1bmRlZmluZWQnICYmIGUuY29udGFpbnNQb2ludChwKSkgY29udGludWVcbiAgICAgIGlmICh0eXBlb2YgZSAhPSAndW5kZWZpbmVkJyAmJiBlZGdlSW50ZXJzZWN0KHAsIHBvaW50SW5mLCBlKSkge1xuICAgICAgICBpZiAob25TZWdtZW50KHAsIGUucDEsIHBvaW50SW5mKSB8fCBvblNlZ21lbnQocCwgZS5wMiwgcG9pbnRJbmYpKSBjb250aW51ZVxuICAgICAgICBvcGVuRWRnZXMuYWRkS2V5KG5ldyBFZGdlS2V5KHAsIHBvaW50SW5mLCBlKSlcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gLy8gX3JlbmRlck9wZW5FZGdlcyhwLCBvcGVuRWRnZXMua2V5cylcblxuICAgIGNvbnN0IHZpc2libGUgPSBbXVxuICAgIHZpc2libGUucHVzaChwcmV2UG9pbnQpXG4gICAgdmlzaWJsZS5wdXNoKG5leHRQb2ludClcbiAgICBsZXQgcHJldiA9IG51bGxcbiAgICBsZXQgcHJldlZpc2libGUgPSBudWxsXG5cbiAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgcG9pbnRzTGVuOyBpaSsrKSB7XG4gICAgICBjb25zdCBwMiA9IGNsb25lZFBvaW50c1tpaV1cbiAgICAgIC8vIGlmICghcDIuaXNQb2ludEVxdWFsKHB0MikpIGNvbnRpbnVlXG5cbiAgICAgIGlmIChwMi5pc1BvaW50RXF1YWwocCkpIGNvbnRpbnVlXG4gICAgICBpZiAocC5hbmdsZVRvUG9pbnQocDIpID4gTWF0aC5waSkgYnJlYWtcblxuICAgICAgaWYgKG9wZW5FZGdlcy5rZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yIChsZXQgaWlpID0gMDsgaWlpIDwgcDIuZWRnZXMubGVuZ3RoOyBpaWkrKykge1xuICAgICAgICAgIGNvbnN0IGUgPSBwMi5lZGdlc1tpaWldXG4gICAgICAgICAgaWYgKGNjdyhwLCBwMiwgZS5nZXRPdGhlclBvaW50SW5FZGdlKHAyKSkgPT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBrID0gbmV3IEVkZ2VLZXkocCwgcDIsIGUpXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IG9wZW5FZGdlcy5maW5kS2V5UG9zaXRpb24oaykgLSAxXG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xICYmIG9wZW5FZGdlcy5rZXlzW2luZGV4XS5tYXRjaGVzT3RoZXJLZXkoaykpIHtcbiAgICAgICAgICAgICAgb3BlbkVkZ2VzLmtleXMuc3BsaWNlKGluZGV4LCAxKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocDIuaXNQb2ludEVxdWFsKHB0MikpXG4gICAgICAgIHB0MiA9IHB0MlxuICAgICAgbGV0IGlzVmlzaWJsZSA9IGZhbHNlXG4gICAgICBpZiAocHJldiA9PT0gbnVsbCB8fCBjY3cocCwgcHJldiwgcDIpICE9PSAwIHx8ICFvblNlZ21lbnQocCwgcHJldiwgcDIpKSB7XG4gICAgICAgIGlmIChvcGVuRWRnZXMua2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpc1Zpc2libGUgPSB0cnVlXG4gICAgICAgIH0gZWxzZSBpZiAoIWVkZ2VJbnRlcnNlY3QocCwgcDIsIG9wZW5FZGdlcy5rZXlzWzBdLmVkZ2UpKSB7XG4gICAgICAgICAgaXNWaXNpYmxlID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFwcmV2VmlzaWJsZSkge1xuICAgICAgICBpc1Zpc2libGUgPSBmYWxzZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNWaXNpYmxlID0gdHJ1ZVxuICAgICAgICBmb3IgKGxldCBpaWkgPSAwOyBpaWkgPCBvcGVuRWRnZXMua2V5cy5sZW5ndGg7IGlpaSsrKSB7XG4gICAgICAgICAgY29uc3QgZSA9IG9wZW5FZGdlcy5rZXlzW2lpaV1cbiAgICAgICAgICBpZiAoIWUuZWRnZS5jb250YWluc1BvaW50KHByZXYpICYmIGVkZ2VJbnRlcnNlY3QocHJldiwgcDIsIGUuZWRnZSkpIHtcbiAgICAgICAgICAgIGlzVmlzaWJsZSA9IGZhbHNlXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNWaXNpYmxlICYmIGVkZ2VJblBvbHlnb24ocHJldiwgcDIpKSBpc1Zpc2libGUgPSBmYWxzZVxuICAgICAgfVxuXG4gICAgICBjb25zdCBpc0luQWRqYWNlbnRQb2ludHMgPSAocHJldlBvaW50ICE9IG51bGwgJiYgcDIuaXNQb2ludEVxdWFsKHByZXZQb2ludCkpIHx8IChuZXh0UG9pbnQgIT0gbnVsbCAmJiBwMi5pc1BvaW50RXF1YWwobmV4dFBvaW50KSlcbiAgICAgIGlmIChpc1Zpc2libGUgJiYgIWlzSW5BZGphY2VudFBvaW50cykgaXNWaXNpYmxlID0gIWVkZ2VJblBvbHlnb24ocCwgcDIpXG5cbiAgICAgIC8vIGlmIChpc1Zpc2libGUpIHZpc2libGUucHVzaChwMilcbiAgICAgIGlmIChwMi5pc1BvaW50RXF1YWwocHQyKSkgcmV0dXJuIGlzVmlzaWJsZTtcbiAgICAgIFxuXG4gICAgICBmb3IgKGxldCBpaWkgPSAwOyBpaWkgPCBwMi5lZGdlcy5sZW5ndGg7IGlpaSsrKSB7XG4gICAgICAgIGNvbnN0IGUgPSBwMi5lZGdlc1tpaWldXG4gICAgICAgIGlmICghZS5jb250YWluc1BvaW50KHApICYmIGNjdyhwLCBwMiwgZS5nZXRPdGhlclBvaW50SW5FZGdlKHAyKSkgPT09IDEpIHtcbiAgICAgICAgICBjb25zdCBrID0gbmV3IEVkZ2VLZXkocCwgcDIsIGUpXG4gICAgICAgICAgb3BlbkVkZ2VzLmFkZEtleShrKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHByZXYgPSBwMlxuICAgICAgcHJldlZpc2libGUgPSBpc1Zpc2libGVcbiAgICB9XG5cbiAgICAvLyBjb25zdCBub2RlSWQgPSBjcmVhdGVOb2RlSWQocClcbiAgICAvLyBnLmFkZE5vZGUobm9kZUlkLCB7IHg6IHAueCwgeTogcC55IH0pXG5cbiAgICAvLyBmb3IgKHZhciBpaSA9IDA7IGlpIDwgdmlzaWJsZS5sZW5ndGg7IGlpKyspIHtcbiAgICAvLyAgIGNvbnN0IG90aGVyTm9kZUlkID0gY3JlYXRlTm9kZUlkKHZpc2libGVbaWldKVxuICAgIC8vICAgZy5hZGROb2RlKG90aGVyTm9kZUlkLCB7IHg6IHZpc2libGVbaWldLngsIHk6IHZpc2libGVbaWldLnkgfSlcbiAgICAvLyAgIGcuYWRkTGluayhub2RlSWQsIG90aGVyTm9kZUlkKVxuICAgIC8vIH1cbiAgfVxuICAvLyByZXR1cm4gZ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlR3JhcGhGcm9tR2VvSnNvbiAoZ2VvanNvbikge1xuXG4gIHNldHVwU3RydWN0dXJlKGdlb2pzb24sIGVkZ2VzLCBwb2ludHMsIHBvbHlnb25zKVxuXG4gIHJldHVybiBwcm9jZXNzR3JhcGgoKVxufVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NHcmFwaCAoKSB7XG4gICAgY29uc3QgZyA9IGNyZWF0ZUdyYXBoKClcbiAgICBjb25zdCBwb2ludHNMZW4gPSBwb2ludHMubGVuZ3RoXG4gICAgY29uc3QgY2xvbmVkUG9pbnRzID0gY2xvbmVQb2ludHMoKVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHNMZW47IGkrKykge1xuICAgICAgY29uc3QgcCA9IHBvaW50c1tpXVxuICAgICAgY29uc3QgcHJldlBvaW50ID0gcC5wcmV2UG9pbnRcbiAgICAgIGNvbnN0IG5leHRQb2ludCA9IHAubmV4dFBvaW50XG5cbiAgICAgIC8vIHNvcnRQb2ludHMocCwgY2xvbmVkUG9pbnRzKVxuICAgICAgLy8gX3JlbmRlclNvcnRlZFBvaW50cyhwLCBjbG9uZWRQb2ludHMpXG5cbiAgICAgIC8vIGNvbnN0IG9wZW5FZGdlcyA9IG5ldyBFZGdlS2V5cygpXG4gICAgICAvLyBjb25zdCBwb2ludEluZiA9IG5ldyBQb2ludChbSU5GLCBwLnldLCBudWxsKVxuICAgICAgLy8gZm9yIChsZXQgaWkgPSAwOyBpaSA8IHBvaW50c0xlbjsgaWkrKykge1xuICAgICAgLy8gICBjb25zdCBlID0gZWRnZXNbaWldXG4gICAgICAvLyAgIGlmIChlLmNvbnRhaW5zUG9pbnQocCkpIGNvbnRpbnVlXG4gICAgICAvLyAgIGlmIChlZGdlSW50ZXJzZWN0KHAsIHBvaW50SW5mLCBlKSkge1xuICAgICAgLy8gICAgIGlmIChvblNlZ21lbnQocCwgZS5wMSwgcG9pbnRJbmYpIHx8IG9uU2VnbWVudChwLCBlLnAyLCBwb2ludEluZikpIGNvbnRpbnVlXG4gICAgICAvLyAgICAgb3BlbkVkZ2VzLmFkZEtleShuZXcgRWRnZUtleShwLCBwb2ludEluZiwgZSkpXG4gICAgICAvLyAgIH1cbiAgICAgIC8vIH1cbiAgICAgIC8vIC8vIF9yZW5kZXJPcGVuRWRnZXMocCwgb3BlbkVkZ2VzLmtleXMpXG5cbiAgICAgIGNvbnN0IHZpc2libGUgPSBbXVxuICAgICAgaWYoaSA9PSAwKVxuICAgICAgICB2aXNpYmxlLnB1c2gocHJldlBvaW50KVxuXG4gICAgICB2aXNpYmxlLnB1c2gobmV4dFBvaW50KVxuICAgICAgbGV0IHByZXYgPSBudWxsXG4gICAgICBsZXQgcHJldlZpc2libGUgPSBudWxsXG5cbiAgICAgIC8vIGZvciAobGV0IGlpID0gMDsgaWkgPCBwb2ludHNMZW47IGlpKyspIHtcbiAgICAgIC8vICAgY29uc3QgcDIgPSBjbG9uZWRQb2ludHNbaWldXG4gICAgICAvLyAgIGlmIChwMi5pc1BvaW50RXF1YWwocCkpIGNvbnRpbnVlXG4gICAgICAvLyAgIGlmIChwLmFuZ2xlVG9Qb2ludChwMikgPiBNYXRoLnBpKSBicmVha1xuXG4gICAgICAvLyAgIGlmIChvcGVuRWRnZXMua2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyAgICAgZm9yIChsZXQgaWlpID0gMDsgaWlpIDwgcDIuZWRnZXMubGVuZ3RoOyBpaWkrKykge1xuICAgICAgLy8gICAgICAgY29uc3QgZSA9IHAyLmVkZ2VzW2lpaV1cbiAgICAgIC8vICAgICAgIGlmIChjY3cocCwgcDIsIGUuZ2V0T3RoZXJQb2ludEluRWRnZShwMikpID09PSAtMSkge1xuICAgICAgLy8gICAgICAgICBjb25zdCBrID0gbmV3IEVkZ2VLZXkocCwgcDIsIGUpXG4gICAgICAvLyAgICAgICAgIGNvbnN0IGluZGV4ID0gb3BlbkVkZ2VzLmZpbmRLZXlQb3NpdGlvbihrKSAtIDFcbiAgICAgIC8vICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSAmJiBvcGVuRWRnZXMua2V5c1tpbmRleF0ubWF0Y2hlc090aGVyS2V5KGspKSB7XG4gICAgICAvLyAgICAgICAgICAgb3BlbkVkZ2VzLmtleXMuc3BsaWNlKGluZGV4LCAxKVxuICAgICAgLy8gICAgICAgICB9XG4gICAgICAvLyAgICAgICB9XG4gICAgICAvLyAgICAgfVxuICAgICAgLy8gICB9XG5cbiAgICAgIC8vICAgbGV0IGlzVmlzaWJsZSA9IGZhbHNlXG4gICAgICAvLyAgIGlmIChwcmV2ID09PSBudWxsIHx8IGNjdyhwLCBwcmV2LCBwMikgIT09IDAgfHwgIW9uU2VnbWVudChwLCBwcmV2LCBwMikpIHtcbiAgICAgIC8vICAgICBpZiAob3BlbkVkZ2VzLmtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyAgICAgICBpc1Zpc2libGUgPSB0cnVlXG4gICAgICAvLyAgICAgfSBlbHNlIGlmICghZWRnZUludGVyc2VjdChwLCBwMiwgb3BlbkVkZ2VzLmtleXNbMF0uZWRnZSkpIHtcbiAgICAgIC8vICAgICAgIGlzVmlzaWJsZSA9IHRydWVcbiAgICAgIC8vICAgICB9XG4gICAgICAvLyAgIH0gZWxzZSBpZiAoIXByZXZWaXNpYmxlKSB7XG4gICAgICAvLyAgICAgaXNWaXNpYmxlID0gZmFsc2VcbiAgICAgIC8vICAgfSBlbHNlIHtcbiAgICAgIC8vICAgICBpc1Zpc2libGUgPSB0cnVlXG4gICAgICAvLyAgICAgZm9yIChsZXQgaWlpID0gMDsgaWlpIDwgb3BlbkVkZ2VzLmtleXMubGVuZ3RoOyBpaWkrKykge1xuICAgICAgLy8gICAgICAgY29uc3QgZSA9IG9wZW5FZGdlcy5rZXlzW2lpaV1cbiAgICAgIC8vICAgICAgIGlmICghZS5lZGdlLmNvbnRhaW5zUG9pbnQocHJldikgJiYgZWRnZUludGVyc2VjdChwcmV2LCBwMiwgZS5lZGdlKSkge1xuICAgICAgLy8gICAgICAgICBpc1Zpc2libGUgPSBmYWxzZVxuICAgICAgLy8gICAgICAgICBicmVha1xuICAgICAgLy8gICAgICAgfVxuICAgICAgLy8gICAgIH1cbiAgICAgIC8vICAgICBpZiAoaXNWaXNpYmxlICYmIGVkZ2VJblBvbHlnb24ocHJldiwgcDIpKSBpc1Zpc2libGUgPSBmYWxzZVxuICAgICAgLy8gICB9XG5cbiAgICAgIC8vICAgY29uc3QgaXNJbkFkamFjZW50UG9pbnRzID0gcDIuaXNQb2ludEVxdWFsKHByZXZQb2ludCkgfHwgcDIuaXNQb2ludEVxdWFsKG5leHRQb2ludClcbiAgICAgIC8vICAgaWYgKGlzVmlzaWJsZSAmJiAhaXNJbkFkamFjZW50UG9pbnRzKSBpc1Zpc2libGUgPSAhZWRnZUluUG9seWdvbihwLCBwMilcblxuICAgICAgLy8gICBpZiAoaXNWaXNpYmxlKSB2aXNpYmxlLnB1c2gocDIpXG5cbiAgICAgIC8vICAgZm9yIChsZXQgaWlpID0gMDsgaWlpIDwgcDIuZWRnZXMubGVuZ3RoOyBpaWkrKykge1xuICAgICAgLy8gICAgIGNvbnN0IGUgPSBwMi5lZGdlc1tpaWldXG4gICAgICAvLyAgICAgaWYgKCFlLmNvbnRhaW5zUG9pbnQocCkgJiYgY2N3KHAsIHAyLCBlLmdldE90aGVyUG9pbnRJbkVkZ2UocDIpKSA9PT0gMSkge1xuICAgICAgLy8gICAgICAgY29uc3QgayA9IG5ldyBFZGdlS2V5KHAsIHAyLCBlKVxuICAgICAgLy8gICAgICAgb3BlbkVkZ2VzLmFkZEtleShrKVxuICAgICAgLy8gICAgIH1cbiAgICAgIC8vICAgfVxuXG4gICAgICAvLyAgIHByZXYgPSBwMlxuICAgICAgLy8gICBwcmV2VmlzaWJsZSA9IGlzVmlzaWJsZVxuICAgICAgLy8gfVxuXG4gICAgICBjb25zdCBub2RlSWQgPSBjcmVhdGVOb2RlSWQocClcbiAgICAgIGcuYWRkTm9kZShub2RlSWQsIHsgeDogcC54LCB5OiBwLnkgfSlcblxuICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IHZpc2libGUubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgIGNvbnN0IG90aGVyTm9kZUlkID0gY3JlYXRlTm9kZUlkKHZpc2libGVbaWldKVxuICAgICAgICBnLmFkZE5vZGUob3RoZXJOb2RlSWQsIHsgeDogdmlzaWJsZVtpaV0ueCwgeTogdmlzaWJsZVtpaV0ueSB9KVxuICAgICAgICBnLmFkZExpbmsobm9kZUlkLCBvdGhlck5vZGVJZClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVJZCAocCkge1xuICAgIHJldHVybiBwLnggKyAnLCcgKyBwLnlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb25lUG9pbnRzICgpIHtcbiAgICByZXR1cm4gcG9pbnRzLnNsaWNlKDApXG4gIH1cblxuICBmdW5jdGlvbiBzb3J0UG9pbnRzIChwb2ludCwgY2xvbmVkUG9pbnRzKSB7XG4gICAgY2xvbmVkUG9pbnRzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGNvbnN0IGFuZ2xlMSA9IHBvaW50LmFuZ2xlVG9Qb2ludChhKVxuICAgICAgY29uc3QgYW5nbGUyID0gcG9pbnQuYW5nbGVUb1BvaW50KGIpXG4gICAgICBpZiAoYW5nbGUxIDwgYW5nbGUyKSByZXR1cm4gLTFcbiAgICAgIGlmIChhbmdsZTEgPiBhbmdsZTIpIHJldHVybiAxXG4gICAgICBjb25zdCBkaXN0MSA9IGNhbGNFZGdlRGlzdGFuY2UocG9pbnQsIGEpXG4gICAgICBjb25zdCBkaXN0MiA9IGNhbGNFZGdlRGlzdGFuY2UocG9pbnQsIGIpXG4gICAgICBpZiAoZGlzdDEgPCBkaXN0MikgcmV0dXJuIC0xXG4gICAgICBpZiAoZGlzdDEgPiBkaXN0MikgcmV0dXJuIDFcbiAgICAgIHJldHVybiAwXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGVkZ2VJblBvbHlnb24gKHAxLCBwMikge1xuICAgIGlmIChwMS5wb2x5Z29uSUQgIT09IHAyLnBvbHlnb25JRCkgcmV0dXJuIGZhbHNlXG4gICAgaWYgKHAxLnBvbHlnb25JRCA9PT0gLTEgfHwgcDIucG9seWdvbklEID09PSAtMSkgcmV0dXJuIGZhbHNlXG4gICAgY29uc3QgbWlkUG9pbnQgPSBuZXcgUG9pbnQoWyhwMS54ICsgcDIueCkgLyAyLCAocDEueSArIHAyLnkpIC8gMl0sIG51bGwpXG4gICAgcmV0dXJuIHBvbHlnb25Dcm9zc2luZyhtaWRQb2ludCwgcG9seWdvbnNbcDEucG9seWdvbklEXSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvbHlnb25Dcm9zc2luZyAocDEsIHBvbHlFZGdlcykge1xuICAgIGNvbnN0IHAyID0gbmV3IFBvaW50KFtJTkYsIHAxLnldLCBudWxsKVxuICAgIGxldCBpbnRlcnNlY3RDb3VudCA9IDBcbiAgICBsZXQgY29GbGFnID0gZmFsc2VcbiAgICBsZXQgY29EaXIgPSAwXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvbHlFZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZSA9IHBvbHlFZGdlc1tpXVxuICAgICAgaWYgKHAxLnkgPCBlLnAxLnkgJiYgcDEueSA8IGUucDIueSkgY29udGludWVcbiAgICAgIGlmIChwMS55ID4gZS5wMS55ICYmIHAxLnkgPiBlLnAyLnkpIGNvbnRpbnVlXG4gICAgICBjb25zdCBjbzAgPSAoY2N3KHAxLCBlLnAxLCBwMikgPT09IDApICYmIChlLnAxLnggPiBwMS54KVxuICAgICAgY29uc3QgY28xID0gKGNjdyhwMSwgZS5wMiwgcDIpID09PSAwKSAmJiAoZS5wMi54ID4gcDEueClcbiAgICAgIGNvbnN0IGNvUG9pbnQgPSBjbzAgPyBlLnAxIDogZS5wMlxuICAgICAgaWYgKGNvMCB8fCBjbzEpIHtcbiAgICAgICAgY29EaXIgPSBlLmdldE90aGVyUG9pbnRJbkVkZ2UoY29Qb2ludCkueSA+IHAxLnkgPyBjb0RpcisrIDogY29EaXItLVxuICAgICAgICBpZiAoY29GbGFnKSB7XG4gICAgICAgICAgaWYgKGNvRGlyID09PSAwKSBpbnRlcnNlY3RDb3VudCsrXG4gICAgICAgICAgY29GbGFnID0gZmFsc2VcbiAgICAgICAgICBjb0RpciA9IDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb0ZsYWcgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZWRnZUludGVyc2VjdChwMSwgcDIsIGUpKSB7XG4gICAgICAgIGludGVyc2VjdENvdW50KytcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGludGVyc2VjdENvdW50ICUgMiA9PT0gMCkgcmV0dXJuIGZhbHNlXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../src/createGraphFromGeoJson.js\n");

/***/ }),

/***/ "../src/debug.js":
/*!***********************!*\
  !*** ../src/debug.js ***!
  \***********************/
/*! exports provided: _renderSortedPoints, _renderOpenEdges */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_renderSortedPoints\", function() { return _renderSortedPoints; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_renderOpenEdges\", function() { return _renderOpenEdges; });\n\nfunction _renderSortedPoints (point, sortedPoints) {\n  const map = window.map\n  var sortedPointsLg = null\n\n  L.NumberedDivIcon = createNumberDiv()\n\n  setCurrentPoint(point)\n\n  if (sortedPointsLg === null) sortedPointsLg = L.layerGroup([]).addTo(map)\n  else sortedPointsLg.clearLayers()\n  sortedPoints.forEach((p, index) => {\n    return L.marker([p.y, p.x], {\n      color: 'black',\n      icon: new L.NumberedDivIcon({ number: index.toString() })\n    }).addTo(sortedPointsLg)\n  })\n\n  // debugger\n}\n\nfunction _renderOpenEdges (point, edges) {\n  const map = window.map\n  const currentPoint = L.circleMarker([point.y, point.x], {\n    radius: 20,\n    color: 'green'\n  }).addTo(map)\n  var openEdges = L.layerGroup([]).addTo(map)\n\n  edges.forEach((e, index) => {\n    L.polyline([[e.edge.p1.y, e.edge.p1.x], [e.edge.p2.y, e.edge.p2.x]], {\n      color: 'red'\n    }).addTo(openEdges)\n  })\n\n  // debugger\n  openEdges.clearLayers()\n  map.removeLayer(currentPoint)\n}\n\nfunction setCurrentPoint (point) {\n  const map = window.map\n  let currentPoint = null\n\n  if (currentPoint !== null) map.removeLayer(currentPoint)\n\n  currentPoint = L.circleMarker([point.y, point.x], {\n    radius: 20,\n    color: 'green'\n  }).addTo(map)\n\n}\n\nfunction createNumberDiv () {\n  return L.Icon.extend({\n    options: {\n      number: '',\n      iconSize: new L.Point(25, 25),\n      className: 'leaflet-div-icon'\n    },\n    createIcon: function () {\n      var div = document.createElement('div')\n      var numdiv = document.createElement('div')\n      numdiv.setAttribute('class', 'number')\n      numdiv.innerHTML = this.options['number'] || ''\n      div.appendChild(numdiv)\n      this._setIconStyles(div, 'icon')\n      return div\n    }\n  })\n}\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2RlYnVnLmpzP2M5MWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUNPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDJCQUEyQjtBQUM5RCxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsImZpbGUiOiIuLi9zcmMvZGVidWcuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmV4cG9ydCBmdW5jdGlvbiBfcmVuZGVyU29ydGVkUG9pbnRzIChwb2ludCwgc29ydGVkUG9pbnRzKSB7XG4gIGNvbnN0IG1hcCA9IHdpbmRvdy5tYXBcbiAgdmFyIHNvcnRlZFBvaW50c0xnID0gbnVsbFxuXG4gIEwuTnVtYmVyZWREaXZJY29uID0gY3JlYXRlTnVtYmVyRGl2KClcblxuICBzZXRDdXJyZW50UG9pbnQocG9pbnQpXG5cbiAgaWYgKHNvcnRlZFBvaW50c0xnID09PSBudWxsKSBzb3J0ZWRQb2ludHNMZyA9IEwubGF5ZXJHcm91cChbXSkuYWRkVG8obWFwKVxuICBlbHNlIHNvcnRlZFBvaW50c0xnLmNsZWFyTGF5ZXJzKClcbiAgc29ydGVkUG9pbnRzLmZvckVhY2goKHAsIGluZGV4KSA9PiB7XG4gICAgcmV0dXJuIEwubWFya2VyKFtwLnksIHAueF0sIHtcbiAgICAgIGNvbG9yOiAnYmxhY2snLFxuICAgICAgaWNvbjogbmV3IEwuTnVtYmVyZWREaXZJY29uKHsgbnVtYmVyOiBpbmRleC50b1N0cmluZygpIH0pXG4gICAgfSkuYWRkVG8oc29ydGVkUG9pbnRzTGcpXG4gIH0pXG5cbiAgLy8gZGVidWdnZXJcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9yZW5kZXJPcGVuRWRnZXMgKHBvaW50LCBlZGdlcykge1xuICBjb25zdCBtYXAgPSB3aW5kb3cubWFwXG4gIGNvbnN0IGN1cnJlbnRQb2ludCA9IEwuY2lyY2xlTWFya2VyKFtwb2ludC55LCBwb2ludC54XSwge1xuICAgIHJhZGl1czogMjAsXG4gICAgY29sb3I6ICdncmVlbidcbiAgfSkuYWRkVG8obWFwKVxuICB2YXIgb3BlbkVkZ2VzID0gTC5sYXllckdyb3VwKFtdKS5hZGRUbyhtYXApXG5cbiAgZWRnZXMuZm9yRWFjaCgoZSwgaW5kZXgpID0+IHtcbiAgICBMLnBvbHlsaW5lKFtbZS5lZGdlLnAxLnksIGUuZWRnZS5wMS54XSwgW2UuZWRnZS5wMi55LCBlLmVkZ2UucDIueF1dLCB7XG4gICAgICBjb2xvcjogJ3JlZCdcbiAgICB9KS5hZGRUbyhvcGVuRWRnZXMpXG4gIH0pXG5cbiAgLy8gZGVidWdnZXJcbiAgb3BlbkVkZ2VzLmNsZWFyTGF5ZXJzKClcbiAgbWFwLnJlbW92ZUxheWVyKGN1cnJlbnRQb2ludClcbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudFBvaW50IChwb2ludCkge1xuICBjb25zdCBtYXAgPSB3aW5kb3cubWFwXG4gIGxldCBjdXJyZW50UG9pbnQgPSBudWxsXG5cbiAgaWYgKGN1cnJlbnRQb2ludCAhPT0gbnVsbCkgbWFwLnJlbW92ZUxheWVyKGN1cnJlbnRQb2ludClcblxuICBjdXJyZW50UG9pbnQgPSBMLmNpcmNsZU1hcmtlcihbcG9pbnQueSwgcG9pbnQueF0sIHtcbiAgICByYWRpdXM6IDIwLFxuICAgIGNvbG9yOiAnZ3JlZW4nXG4gIH0pLmFkZFRvKG1hcClcblxufVxuXG5mdW5jdGlvbiBjcmVhdGVOdW1iZXJEaXYgKCkge1xuICByZXR1cm4gTC5JY29uLmV4dGVuZCh7XG4gICAgb3B0aW9uczoge1xuICAgICAgbnVtYmVyOiAnJyxcbiAgICAgIGljb25TaXplOiBuZXcgTC5Qb2ludCgyNSwgMjUpLFxuICAgICAgY2xhc3NOYW1lOiAnbGVhZmxldC1kaXYtaWNvbidcbiAgICB9LFxuICAgIGNyZWF0ZUljb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgdmFyIG51bWRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICBudW1kaXYuc2V0QXR0cmlidXRlKCdjbGFzcycsICdudW1iZXInKVxuICAgICAgbnVtZGl2LmlubmVySFRNTCA9IHRoaXMub3B0aW9uc1snbnVtYmVyJ10gfHwgJydcbiAgICAgIGRpdi5hcHBlbmRDaGlsZChudW1kaXYpXG4gICAgICB0aGlzLl9zZXRJY29uU3R5bGVzKGRpdiwgJ2ljb24nKVxuICAgICAgcmV0dXJuIGRpdlxuICAgIH1cbiAgfSlcbn1cblxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../src/debug.js\n");

/***/ }),

/***/ "../src/main.js":
/*!**********************!*\
  !*** ../src/main.js ***!
  \**********************/
/*! exports provided: createGraphFromGeoJson, getVisibleNodes, isVisible, loadPoints, restoreOriginalPointsAndEdges, getObstructingEdge, addStartingAndEndingNodes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _createGraphFromGeoJson__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createGraphFromGeoJson */ \"../src/createGraphFromGeoJson.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createGraphFromGeoJson\", function() { return _createGraphFromGeoJson__WEBPACK_IMPORTED_MODULE_0__[\"createGraphFromGeoJson\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getVisibleNodes\", function() { return _createGraphFromGeoJson__WEBPACK_IMPORTED_MODULE_0__[\"getVisibleNodes\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"isVisible\", function() { return _createGraphFromGeoJson__WEBPACK_IMPORTED_MODULE_0__[\"isVisible\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"loadPoints\", function() { return _createGraphFromGeoJson__WEBPACK_IMPORTED_MODULE_0__[\"loadPoints\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"restoreOriginalPointsAndEdges\", function() { return _createGraphFromGeoJson__WEBPACK_IMPORTED_MODULE_0__[\"restoreOriginalPointsAndEdges\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getObstructingEdge\", function() { return _createGraphFromGeoJson__WEBPACK_IMPORTED_MODULE_0__[\"getObstructingEdge\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"addStartingAndEndingNodes\", function() { return _createGraphFromGeoJson__WEBPACK_IMPORTED_MODULE_0__[\"addStartingAndEndingNodes\"]; });\n\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL21haW4uanM/ZDNmZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUF1TCIsImZpbGUiOiIuLi9zcmMvbWFpbi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IGNyZWF0ZUdyYXBoRnJvbUdlb0pzb24sIGdldFZpc2libGVOb2RlcywgaXNWaXNpYmxlLCBsb2FkUG9pbnRzLCByZXN0b3JlT3JpZ2luYWxQb2ludHNBbmRFZGdlcywgZ2V0T2JzdHJ1Y3RpbmdFZGdlLCBhZGRTdGFydGluZ0FuZEVuZGluZ05vZGVzIH0gZnJvbSAnLi9jcmVhdGVHcmFwaEZyb21HZW9Kc29uJ1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../src/main.js\n");

/***/ }),

/***/ "../src/setupStructure.js":
/*!********************************!*\
  !*** ../src/setupStructure.js ***!
  \********************************/
/*! exports provided: setupStructure */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setupStructure\", function() { return setupStructure; });\n/* harmony import */ var _Point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Point */ \"../src/Point.js\");\n/* harmony import */ var _Edge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Edge */ \"../src/Edge.js\");\n\n\n\nfunction setupStructure (geojson, edges, points, polygons) {\n  const geom = geojson.type === 'Feature' ? geojson.geometry : geojson\n\n  let coords = geom.features\n\n  // standardise the input\n  if (geom.type === 'Polygon') coords = [coords]\n\n  for (let i = 0; i < coords.length; i++) {\n    const contour = []\n    polygons.push(contour)\n\n    for (let ii = 0; ii < coords[i].geometry.coordinates.length; ii++) {\n      let prevPoint = new _Point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"](coords[i].geometry.coordinates[ii][0], i)\n      let currentPoint = new _Point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"](coords[i].geometry.coordinates[ii][1], i)\n      prevPoint.nextPoint = currentPoint\n      let nextPoint = new _Point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"](coords[i].geometry.coordinates[ii][2], i)\n      linkPoints(prevPoint, currentPoint, nextPoint)\n\n      points.push(prevPoint)\n\n      let prevEdge = new _Edge__WEBPACK_IMPORTED_MODULE_1__[\"Edge\"](prevPoint, currentPoint) // eslint-disable-line\n      edges.push(prevEdge)\n      contour.push(prevEdge)\n\n      // Save me for later\n      const firstPoint = prevPoint\n\n      prevPoint = currentPoint\n      currentPoint = nextPoint\n\n      for (let iii = 2; iii < coords[i].geometry.coordinates[ii].length - 2; iii++) {\n        points.push(prevPoint)\n\n        nextPoint = new _Point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"](coords[i].geometry.coordinates[ii][iii + 1], i)\n\n        linkPoints(prevPoint, currentPoint, nextPoint)\n\n        const e = new _Edge__WEBPACK_IMPORTED_MODULE_1__[\"Edge\"](prevPoint, currentPoint) // eslint-disable-line\n\n        edges.push(e)\n        contour.push(e)\n\n        prevPoint = currentPoint\n        currentPoint = nextPoint\n        prevEdge = e\n      }\n\n      linkPoints(prevPoint, currentPoint, firstPoint)\n\n      const secondLastEdge = new _Edge__WEBPACK_IMPORTED_MODULE_1__[\"Edge\"](prevEdge.p2, currentPoint)\n\n      edges.push(secondLastEdge)\n      contour.push(secondLastEdge)\n\n      const lastEdge = new _Edge__WEBPACK_IMPORTED_MODULE_1__[\"Edge\"](currentPoint, firstPoint) // eslint-disable-line\n      linkPoints(currentPoint, firstPoint, firstPoint.nextPoint)\n\n      edges.push(lastEdge)\n      contour.push(lastEdge)\n\n      points.push(prevPoint)\n      points.push(nextPoint)\n    }\n  }\n}\n\n// export function setupStructure (geojson, edges, points, polygons) {\n//   const geom = geojson.type === 'Feature' ? geojson.geometry : geojson\n\n//   let coords = geom.coordinates\n\n//   // standardise the input\n//   if (geom.type === 'Polygon') coords = [coords]\n\n//   for (let i = 0; i < coords.length; i++) {\n//     const contour = []\n//     polygons.push(contour)\n\n//     for (let ii = 0; ii < coords[i].length; ii++) {\n//       let prevPoint = new Point(coords[i][ii][0], i)\n//       let currentPoint = new Point(coords[i][ii][1], i)\n//       prevPoint.nextPoint = currentPoint\n//       let nextPoint = new Point(coords[i][ii][2], i)\n//       linkPoints(prevPoint, currentPoint, nextPoint)\n\n//       points.push(prevPoint)\n\n//       let prevEdge = new Edge(prevPoint, currentPoint) // eslint-disable-line\n//       edges.push(prevEdge)\n//       contour.push(prevEdge)\n\n//       // Save me for later\n//       const firstPoint = prevPoint\n\n//       prevPoint = currentPoint\n//       currentPoint = nextPoint\n\n//       for (let iii = 2; iii < coords[i][ii].length - 2; iii++) {\n//         points.push(prevPoint)\n\n//         nextPoint = new Point(coords[i][ii][iii + 1], i)\n\n//         linkPoints(prevPoint, currentPoint, nextPoint)\n\n//         const e = new Edge(prevPoint, currentPoint) // eslint-disable-line\n\n//         edges.push(e)\n//         contour.push(e)\n\n//         prevPoint = currentPoint\n//         currentPoint = nextPoint\n//         prevEdge = e\n//       }\n\n//       linkPoints(prevPoint, currentPoint, firstPoint)\n\n//       const secondLastEdge = new Edge(prevEdge.p2, currentPoint)\n\n//       edges.push(secondLastEdge)\n//       contour.push(secondLastEdge)\n\n//       const lastEdge = new Edge(currentPoint, firstPoint) // eslint-disable-line\n//       linkPoints(currentPoint, firstPoint, firstPoint.nextPoint)\n\n//       edges.push(lastEdge)\n//       contour.push(lastEdge)\n\n//       points.push(prevPoint)\n//       points.push(nextPoint)\n//     }\n//   }\n// }\n\nfunction linkPoints (prevPoint, currentPoint, nextPoint) {\n  currentPoint.prevPoint = prevPoint\n  currentPoint.nextPoint = nextPoint\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL3NldHVwU3RydWN0dXJlLmpzPzI2ZmEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBK0I7QUFDRjs7QUFFdEI7QUFDUDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTs7QUFFQSxvQkFBb0IsNENBQTRDO0FBQ2hFLDBCQUEwQiw0Q0FBSztBQUMvQiw2QkFBNkIsNENBQUs7QUFDbEM7QUFDQSwwQkFBMEIsNENBQUs7QUFDL0I7O0FBRUE7O0FBRUEseUJBQXlCLDBDQUFJO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1QixxREFBcUQ7QUFDNUU7O0FBRUEsd0JBQXdCLDRDQUFLOztBQUU3Qjs7QUFFQSxzQkFBc0IsMENBQUk7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUNBQWlDLDBDQUFJOztBQUVyQztBQUNBOztBQUVBLDJCQUEyQiwwQ0FBSTtBQUMvQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTs7QUFFQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQkFBMEIsZ0NBQWdDO0FBQzFEOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuLi9zcmMvc2V0dXBTdHJ1Y3R1cmUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQb2ludCB9IGZyb20gJy4vUG9pbnQnXG5pbXBvcnQgeyBFZGdlIH0gZnJvbSAnLi9FZGdlJ1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0dXBTdHJ1Y3R1cmUgKGdlb2pzb24sIGVkZ2VzLCBwb2ludHMsIHBvbHlnb25zKSB7XG4gIGNvbnN0IGdlb20gPSBnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlJyA/IGdlb2pzb24uZ2VvbWV0cnkgOiBnZW9qc29uXG5cbiAgbGV0IGNvb3JkcyA9IGdlb20uZmVhdHVyZXNcblxuICAvLyBzdGFuZGFyZGlzZSB0aGUgaW5wdXRcbiAgaWYgKGdlb20udHlwZSA9PT0gJ1BvbHlnb24nKSBjb29yZHMgPSBbY29vcmRzXVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY29udG91ciA9IFtdXG4gICAgcG9seWdvbnMucHVzaChjb250b3VyKVxuXG4gICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IGNvb3Jkc1tpXS5nZW9tZXRyeS5jb29yZGluYXRlcy5sZW5ndGg7IGlpKyspIHtcbiAgICAgIGxldCBwcmV2UG9pbnQgPSBuZXcgUG9pbnQoY29vcmRzW2ldLmdlb21ldHJ5LmNvb3JkaW5hdGVzW2lpXVswXSwgaSlcbiAgICAgIGxldCBjdXJyZW50UG9pbnQgPSBuZXcgUG9pbnQoY29vcmRzW2ldLmdlb21ldHJ5LmNvb3JkaW5hdGVzW2lpXVsxXSwgaSlcbiAgICAgIHByZXZQb2ludC5uZXh0UG9pbnQgPSBjdXJyZW50UG9pbnRcbiAgICAgIGxldCBuZXh0UG9pbnQgPSBuZXcgUG9pbnQoY29vcmRzW2ldLmdlb21ldHJ5LmNvb3JkaW5hdGVzW2lpXVsyXSwgaSlcbiAgICAgIGxpbmtQb2ludHMocHJldlBvaW50LCBjdXJyZW50UG9pbnQsIG5leHRQb2ludClcblxuICAgICAgcG9pbnRzLnB1c2gocHJldlBvaW50KVxuXG4gICAgICBsZXQgcHJldkVkZ2UgPSBuZXcgRWRnZShwcmV2UG9pbnQsIGN1cnJlbnRQb2ludCkgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgZWRnZXMucHVzaChwcmV2RWRnZSlcbiAgICAgIGNvbnRvdXIucHVzaChwcmV2RWRnZSlcblxuICAgICAgLy8gU2F2ZSBtZSBmb3IgbGF0ZXJcbiAgICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBwcmV2UG9pbnRcblxuICAgICAgcHJldlBvaW50ID0gY3VycmVudFBvaW50XG4gICAgICBjdXJyZW50UG9pbnQgPSBuZXh0UG9pbnRcblxuICAgICAgZm9yIChsZXQgaWlpID0gMjsgaWlpIDwgY29vcmRzW2ldLmdlb21ldHJ5LmNvb3JkaW5hdGVzW2lpXS5sZW5ndGggLSAyOyBpaWkrKykge1xuICAgICAgICBwb2ludHMucHVzaChwcmV2UG9pbnQpXG5cbiAgICAgICAgbmV4dFBvaW50ID0gbmV3IFBvaW50KGNvb3Jkc1tpXS5nZW9tZXRyeS5jb29yZGluYXRlc1tpaV1baWlpICsgMV0sIGkpXG5cbiAgICAgICAgbGlua1BvaW50cyhwcmV2UG9pbnQsIGN1cnJlbnRQb2ludCwgbmV4dFBvaW50KVxuXG4gICAgICAgIGNvbnN0IGUgPSBuZXcgRWRnZShwcmV2UG9pbnQsIGN1cnJlbnRQb2ludCkgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgICAgIGVkZ2VzLnB1c2goZSlcbiAgICAgICAgY29udG91ci5wdXNoKGUpXG5cbiAgICAgICAgcHJldlBvaW50ID0gY3VycmVudFBvaW50XG4gICAgICAgIGN1cnJlbnRQb2ludCA9IG5leHRQb2ludFxuICAgICAgICBwcmV2RWRnZSA9IGVcbiAgICAgIH1cblxuICAgICAgbGlua1BvaW50cyhwcmV2UG9pbnQsIGN1cnJlbnRQb2ludCwgZmlyc3RQb2ludClcblxuICAgICAgY29uc3Qgc2Vjb25kTGFzdEVkZ2UgPSBuZXcgRWRnZShwcmV2RWRnZS5wMiwgY3VycmVudFBvaW50KVxuXG4gICAgICBlZGdlcy5wdXNoKHNlY29uZExhc3RFZGdlKVxuICAgICAgY29udG91ci5wdXNoKHNlY29uZExhc3RFZGdlKVxuXG4gICAgICBjb25zdCBsYXN0RWRnZSA9IG5ldyBFZGdlKGN1cnJlbnRQb2ludCwgZmlyc3RQb2ludCkgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgbGlua1BvaW50cyhjdXJyZW50UG9pbnQsIGZpcnN0UG9pbnQsIGZpcnN0UG9pbnQubmV4dFBvaW50KVxuXG4gICAgICBlZGdlcy5wdXNoKGxhc3RFZGdlKVxuICAgICAgY29udG91ci5wdXNoKGxhc3RFZGdlKVxuXG4gICAgICBwb2ludHMucHVzaChwcmV2UG9pbnQpXG4gICAgICBwb2ludHMucHVzaChuZXh0UG9pbnQpXG4gICAgfVxuICB9XG59XG5cbi8vIGV4cG9ydCBmdW5jdGlvbiBzZXR1cFN0cnVjdHVyZSAoZ2VvanNvbiwgZWRnZXMsIHBvaW50cywgcG9seWdvbnMpIHtcbi8vICAgY29uc3QgZ2VvbSA9IGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmUnID8gZ2VvanNvbi5nZW9tZXRyeSA6IGdlb2pzb25cblxuLy8gICBsZXQgY29vcmRzID0gZ2VvbS5jb29yZGluYXRlc1xuXG4vLyAgIC8vIHN0YW5kYXJkaXNlIHRoZSBpbnB1dFxuLy8gICBpZiAoZ2VvbS50eXBlID09PSAnUG9seWdvbicpIGNvb3JkcyA9IFtjb29yZHNdXG5cbi8vICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcbi8vICAgICBjb25zdCBjb250b3VyID0gW11cbi8vICAgICBwb2x5Z29ucy5wdXNoKGNvbnRvdXIpXG5cbi8vICAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgY29vcmRzW2ldLmxlbmd0aDsgaWkrKykge1xuLy8gICAgICAgbGV0IHByZXZQb2ludCA9IG5ldyBQb2ludChjb29yZHNbaV1baWldWzBdLCBpKVxuLy8gICAgICAgbGV0IGN1cnJlbnRQb2ludCA9IG5ldyBQb2ludChjb29yZHNbaV1baWldWzFdLCBpKVxuLy8gICAgICAgcHJldlBvaW50Lm5leHRQb2ludCA9IGN1cnJlbnRQb2ludFxuLy8gICAgICAgbGV0IG5leHRQb2ludCA9IG5ldyBQb2ludChjb29yZHNbaV1baWldWzJdLCBpKVxuLy8gICAgICAgbGlua1BvaW50cyhwcmV2UG9pbnQsIGN1cnJlbnRQb2ludCwgbmV4dFBvaW50KVxuXG4vLyAgICAgICBwb2ludHMucHVzaChwcmV2UG9pbnQpXG5cbi8vICAgICAgIGxldCBwcmV2RWRnZSA9IG5ldyBFZGdlKHByZXZQb2ludCwgY3VycmVudFBvaW50KSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4vLyAgICAgICBlZGdlcy5wdXNoKHByZXZFZGdlKVxuLy8gICAgICAgY29udG91ci5wdXNoKHByZXZFZGdlKVxuXG4vLyAgICAgICAvLyBTYXZlIG1lIGZvciBsYXRlclxuLy8gICAgICAgY29uc3QgZmlyc3RQb2ludCA9IHByZXZQb2ludFxuXG4vLyAgICAgICBwcmV2UG9pbnQgPSBjdXJyZW50UG9pbnRcbi8vICAgICAgIGN1cnJlbnRQb2ludCA9IG5leHRQb2ludFxuXG4vLyAgICAgICBmb3IgKGxldCBpaWkgPSAyOyBpaWkgPCBjb29yZHNbaV1baWldLmxlbmd0aCAtIDI7IGlpaSsrKSB7XG4vLyAgICAgICAgIHBvaW50cy5wdXNoKHByZXZQb2ludClcblxuLy8gICAgICAgICBuZXh0UG9pbnQgPSBuZXcgUG9pbnQoY29vcmRzW2ldW2lpXVtpaWkgKyAxXSwgaSlcblxuLy8gICAgICAgICBsaW5rUG9pbnRzKHByZXZQb2ludCwgY3VycmVudFBvaW50LCBuZXh0UG9pbnQpXG5cbi8vICAgICAgICAgY29uc3QgZSA9IG5ldyBFZGdlKHByZXZQb2ludCwgY3VycmVudFBvaW50KSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbi8vICAgICAgICAgZWRnZXMucHVzaChlKVxuLy8gICAgICAgICBjb250b3VyLnB1c2goZSlcblxuLy8gICAgICAgICBwcmV2UG9pbnQgPSBjdXJyZW50UG9pbnRcbi8vICAgICAgICAgY3VycmVudFBvaW50ID0gbmV4dFBvaW50XG4vLyAgICAgICAgIHByZXZFZGdlID0gZVxuLy8gICAgICAgfVxuXG4vLyAgICAgICBsaW5rUG9pbnRzKHByZXZQb2ludCwgY3VycmVudFBvaW50LCBmaXJzdFBvaW50KVxuXG4vLyAgICAgICBjb25zdCBzZWNvbmRMYXN0RWRnZSA9IG5ldyBFZGdlKHByZXZFZGdlLnAyLCBjdXJyZW50UG9pbnQpXG5cbi8vICAgICAgIGVkZ2VzLnB1c2goc2Vjb25kTGFzdEVkZ2UpXG4vLyAgICAgICBjb250b3VyLnB1c2goc2Vjb25kTGFzdEVkZ2UpXG5cbi8vICAgICAgIGNvbnN0IGxhc3RFZGdlID0gbmV3IEVkZ2UoY3VycmVudFBvaW50LCBmaXJzdFBvaW50KSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4vLyAgICAgICBsaW5rUG9pbnRzKGN1cnJlbnRQb2ludCwgZmlyc3RQb2ludCwgZmlyc3RQb2ludC5uZXh0UG9pbnQpXG5cbi8vICAgICAgIGVkZ2VzLnB1c2gobGFzdEVkZ2UpXG4vLyAgICAgICBjb250b3VyLnB1c2gobGFzdEVkZ2UpXG5cbi8vICAgICAgIHBvaW50cy5wdXNoKHByZXZQb2ludClcbi8vICAgICAgIHBvaW50cy5wdXNoKG5leHRQb2ludClcbi8vICAgICB9XG4vLyAgIH1cbi8vIH1cblxuZnVuY3Rpb24gbGlua1BvaW50cyAocHJldlBvaW50LCBjdXJyZW50UG9pbnQsIG5leHRQb2ludCkge1xuICBjdXJyZW50UG9pbnQucHJldlBvaW50ID0gcHJldlBvaW50XG4gIGN1cnJlbnRQb2ludC5uZXh0UG9pbnQgPSBuZXh0UG9pbnRcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../src/setupStructure.js\n");

/***/ }),

/***/ "../src/utils.js":
/*!***********************!*\
  !*** ../src/utils.js ***!
  \***********************/
/*! exports provided: pi1, pi2, INF, edgeIntersect, ccw, onSegment, angle2, pointEdgeDistance, intersectPoint, calcEdgeDistance */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pi1\", function() { return pi1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pi2\", function() { return pi2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"INF\", function() { return INF; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"edgeIntersect\", function() { return edgeIntersect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ccw\", function() { return ccw; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"onSegment\", function() { return onSegment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"angle2\", function() { return angle2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pointEdgeDistance\", function() { return pointEdgeDistance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"intersectPoint\", function() { return intersectPoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"calcEdgeDistance\", function() { return calcEdgeDistance; });\n/* harmony import */ var _Point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Point */ \"../src/Point.js\");\n\n\nconst pi1 = Math.PI * 3 / 2\nconst pi2 = Math.PI / 2\n\nconst INF = 10000\nconst COLIN_TOLERANCE = 13\nconst T = Math.pow(10, COLIN_TOLERANCE)\nconst T2 = Math.pow(10.0, COLIN_TOLERANCE)\n\nfunction edgeIntersect (p1, q1, edge) {\n  const p2 = edge.p1\n  const q2 = edge.p2\n  const o1 = ccw(p1, q1, p2)\n  const o2 = ccw(p1, q1, q2)\n  const o3 = ccw(p2, q2, p1)\n  const o4 = ccw(p2, q2, q1)\n  if (o1 !== o2 && o3 !== o4) return true\n  if (o1 === 0 && onSegment(p1, p2, q1)) return true\n  if (o2 === 0 && onSegment(p1, q2, q1)) return true\n  if (o3 === 0 && onSegment(p2, p1, q2)) return true\n  if (o4 === 0 && onSegment(p2, q1, q2)) return true\n  return false\n}\n\nfunction ccw (a, b, c) {\n  const area = Math.round(((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) * T) / T2\n  if (area > 0) return 1\n  if (area < 0) return -1\n  return 0\n}\n\nfunction onSegment (p, q, r) {\n  if (q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x)) {\n    if (q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y)) return true\n  }\n  return false\n}\n\nfunction angle2 (p1, p2, p3) {\n  const a = Math.pow((p3.x - p2.x), 2) + Math.pow((p3.y - p2.y), 2)\n  const b = Math.pow((p3.x - p1.x), 2) + Math.pow((p3.y - p1.y), 2)\n  const c = Math.pow((p2.x - p1.x), 2) + Math.pow((p2.y - p1.y), 2)\n  return Math.acos((a + c - b) / (2 * Math.sqrt(a) * Math.sqrt(c)))\n}\n\nfunction pointEdgeDistance (p1, p2, edge) {\n  const ip = intersectPoint(p1, p2, edge)\n  return ip !== null ? calcEdgeDistance(p1, ip) : 0\n}\n\nfunction intersectPoint (p1, p2, edge) {\n  if (edge.containsPoint(p1)) return p1\n  if (edge.containsPoint(p2)) return p2\n  if (edge.p1.x === edge.p2.x) {\n    if (p1.x === p2.x) return null\n    const pslope = (p1.y - p2.y) / (p1.x - p2.x)\n    const intersectX = edge.p1.x\n    const intersectY = pslope * (intersectX - p1.x) + p1.y\n    return new _Point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"]([intersectX, intersectY], null)\n  }\n  if (p1.x === p2.x) {\n    const eslope = (edge.p1.y - edge.p2.y) / (edge.p1.x - edge.p2.x)\n    const intersectX = p1.x\n    const intersectY = eslope * (intersectX - edge.p1.x) + edge.p1.y\n    return new _Point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"]([intersectX, intersectY], null)\n  }\n\n  const pslope = (p1.y - p2.y) / (p1.x - p2.x)\n  const eslope = (edge.p1.y - edge.p2.y) / (edge.p1.x - edge.p2.x)\n\n  if (pslope === eslope) return null\n  const intersectX = (eslope * edge.p1.x - pslope * p1.x + p1.y - edge.p1.y) / (eslope - pslope)\n  const intersectY = eslope * (intersectX - edge.p1.x) + edge.p1.y\n  return new _Point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"]([intersectX, intersectY], null)\n}\n\nfunction calcEdgeDistance (p1, p2) {\n  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2))\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL3V0aWxzLmpzPzUwZjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQStCOztBQUV4QjtBQUNBOztBQUVBO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNENBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNENBQUs7QUFDcEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDRDQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQSIsImZpbGUiOiIuLi9zcmMvdXRpbHMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQb2ludCB9IGZyb20gJy4vUG9pbnQnXG5cbmV4cG9ydCBjb25zdCBwaTEgPSBNYXRoLlBJICogMyAvIDJcbmV4cG9ydCBjb25zdCBwaTIgPSBNYXRoLlBJIC8gMlxuXG5leHBvcnQgY29uc3QgSU5GID0gMTAwMDBcbmNvbnN0IENPTElOX1RPTEVSQU5DRSA9IDEzXG5jb25zdCBUID0gTWF0aC5wb3coMTAsIENPTElOX1RPTEVSQU5DRSlcbmNvbnN0IFQyID0gTWF0aC5wb3coMTAuMCwgQ09MSU5fVE9MRVJBTkNFKVxuXG5leHBvcnQgZnVuY3Rpb24gZWRnZUludGVyc2VjdCAocDEsIHExLCBlZGdlKSB7XG4gIGNvbnN0IHAyID0gZWRnZS5wMVxuICBjb25zdCBxMiA9IGVkZ2UucDJcbiAgY29uc3QgbzEgPSBjY3cocDEsIHExLCBwMilcbiAgY29uc3QgbzIgPSBjY3cocDEsIHExLCBxMilcbiAgY29uc3QgbzMgPSBjY3cocDIsIHEyLCBwMSlcbiAgY29uc3QgbzQgPSBjY3cocDIsIHEyLCBxMSlcbiAgaWYgKG8xICE9PSBvMiAmJiBvMyAhPT0gbzQpIHJldHVybiB0cnVlXG4gIGlmIChvMSA9PT0gMCAmJiBvblNlZ21lbnQocDEsIHAyLCBxMSkpIHJldHVybiB0cnVlXG4gIGlmIChvMiA9PT0gMCAmJiBvblNlZ21lbnQocDEsIHEyLCBxMSkpIHJldHVybiB0cnVlXG4gIGlmIChvMyA9PT0gMCAmJiBvblNlZ21lbnQocDIsIHAxLCBxMikpIHJldHVybiB0cnVlXG4gIGlmIChvNCA9PT0gMCAmJiBvblNlZ21lbnQocDIsIHExLCBxMikpIHJldHVybiB0cnVlXG4gIHJldHVybiBmYWxzZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2N3IChhLCBiLCBjKSB7XG4gIGNvbnN0IGFyZWEgPSBNYXRoLnJvdW5kKCgoYi54IC0gYS54KSAqIChjLnkgLSBhLnkpIC0gKGIueSAtIGEueSkgKiAoYy54IC0gYS54KSkgKiBUKSAvIFQyXG4gIGlmIChhcmVhID4gMCkgcmV0dXJuIDFcbiAgaWYgKGFyZWEgPCAwKSByZXR1cm4gLTFcbiAgcmV0dXJuIDBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9uU2VnbWVudCAocCwgcSwgcikge1xuICBpZiAocS54IDw9IE1hdGgubWF4KHAueCwgci54KSAmJiBxLnggPj0gTWF0aC5taW4ocC54LCByLngpKSB7XG4gICAgaWYgKHEueSA8PSBNYXRoLm1heChwLnksIHIueSkgJiYgcS55ID49IE1hdGgubWluKHAueSwgci55KSkgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFuZ2xlMiAocDEsIHAyLCBwMykge1xuICBjb25zdCBhID0gTWF0aC5wb3coKHAzLnggLSBwMi54KSwgMikgKyBNYXRoLnBvdygocDMueSAtIHAyLnkpLCAyKVxuICBjb25zdCBiID0gTWF0aC5wb3coKHAzLnggLSBwMS54KSwgMikgKyBNYXRoLnBvdygocDMueSAtIHAxLnkpLCAyKVxuICBjb25zdCBjID0gTWF0aC5wb3coKHAyLnggLSBwMS54KSwgMikgKyBNYXRoLnBvdygocDIueSAtIHAxLnkpLCAyKVxuICByZXR1cm4gTWF0aC5hY29zKChhICsgYyAtIGIpIC8gKDIgKiBNYXRoLnNxcnQoYSkgKiBNYXRoLnNxcnQoYykpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRFZGdlRGlzdGFuY2UgKHAxLCBwMiwgZWRnZSkge1xuICBjb25zdCBpcCA9IGludGVyc2VjdFBvaW50KHAxLCBwMiwgZWRnZSlcbiAgcmV0dXJuIGlwICE9PSBudWxsID8gY2FsY0VkZ2VEaXN0YW5jZShwMSwgaXApIDogMFxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJzZWN0UG9pbnQgKHAxLCBwMiwgZWRnZSkge1xuICBpZiAoZWRnZS5jb250YWluc1BvaW50KHAxKSkgcmV0dXJuIHAxXG4gIGlmIChlZGdlLmNvbnRhaW5zUG9pbnQocDIpKSByZXR1cm4gcDJcbiAgaWYgKGVkZ2UucDEueCA9PT0gZWRnZS5wMi54KSB7XG4gICAgaWYgKHAxLnggPT09IHAyLngpIHJldHVybiBudWxsXG4gICAgY29uc3QgcHNsb3BlID0gKHAxLnkgLSBwMi55KSAvIChwMS54IC0gcDIueClcbiAgICBjb25zdCBpbnRlcnNlY3RYID0gZWRnZS5wMS54XG4gICAgY29uc3QgaW50ZXJzZWN0WSA9IHBzbG9wZSAqIChpbnRlcnNlY3RYIC0gcDEueCkgKyBwMS55XG4gICAgcmV0dXJuIG5ldyBQb2ludChbaW50ZXJzZWN0WCwgaW50ZXJzZWN0WV0sIG51bGwpXG4gIH1cbiAgaWYgKHAxLnggPT09IHAyLngpIHtcbiAgICBjb25zdCBlc2xvcGUgPSAoZWRnZS5wMS55IC0gZWRnZS5wMi55KSAvIChlZGdlLnAxLnggLSBlZGdlLnAyLngpXG4gICAgY29uc3QgaW50ZXJzZWN0WCA9IHAxLnhcbiAgICBjb25zdCBpbnRlcnNlY3RZID0gZXNsb3BlICogKGludGVyc2VjdFggLSBlZGdlLnAxLngpICsgZWRnZS5wMS55XG4gICAgcmV0dXJuIG5ldyBQb2ludChbaW50ZXJzZWN0WCwgaW50ZXJzZWN0WV0sIG51bGwpXG4gIH1cblxuICBjb25zdCBwc2xvcGUgPSAocDEueSAtIHAyLnkpIC8gKHAxLnggLSBwMi54KVxuICBjb25zdCBlc2xvcGUgPSAoZWRnZS5wMS55IC0gZWRnZS5wMi55KSAvIChlZGdlLnAxLnggLSBlZGdlLnAyLngpXG5cbiAgaWYgKHBzbG9wZSA9PT0gZXNsb3BlKSByZXR1cm4gbnVsbFxuICBjb25zdCBpbnRlcnNlY3RYID0gKGVzbG9wZSAqIGVkZ2UucDEueCAtIHBzbG9wZSAqIHAxLnggKyBwMS55IC0gZWRnZS5wMS55KSAvIChlc2xvcGUgLSBwc2xvcGUpXG4gIGNvbnN0IGludGVyc2VjdFkgPSBlc2xvcGUgKiAoaW50ZXJzZWN0WCAtIGVkZ2UucDEueCkgKyBlZGdlLnAxLnlcbiAgcmV0dXJuIG5ldyBQb2ludChbaW50ZXJzZWN0WCwgaW50ZXJzZWN0WV0sIG51bGwpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxjRWRnZURpc3RhbmNlIChwMSwgcDIpIHtcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwMi54IC0gcDEueCwgMikgKyBNYXRoLnBvdyhwMi55IC0gcDEueSwgMikpXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../src/utils.js\n");

/***/ }),

/***/ "./src/Edge.js":
/*!*********************!*\
  !*** ./src/Edge.js ***!
  \*********************/
/*! exports provided: Edge */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Edge\", function() { return Edge; });\nclass Edge {\n  constructor (p1, p2) {\n    this.p1 = p1\n    this.p2 = p2\n\n    p1.edges.push(this)\n    p2.edges.push(this)\n  }\n\n  getOtherPointInEdge (point) {\n    return this.p1.isPointEqual(point) ? this.p2 : this.p1\n  }\n\n  areEdgesEqual (otherEdge) {\n    if (this.p1.isPointEqual(otherEdge.p1) && this.p2.isPointEqual(otherEdge.p2)) return true\n    if (this.p1.isPointEqual(otherEdge.p2) && this.p2.isPointEqual(otherEdge.p1)) return true\n    return false\n  }\n\n  containsPoint (point) {\n    if (this.p1.isPointEqual(point) || this.p2.isPointEqual(point)) return true\n    return false\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvRWRnZS5qcz80MDBiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL3NyYy9FZGdlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIEVkZ2Uge1xuICBjb25zdHJ1Y3RvciAocDEsIHAyKSB7XG4gICAgdGhpcy5wMSA9IHAxXG4gICAgdGhpcy5wMiA9IHAyXG5cbiAgICBwMS5lZGdlcy5wdXNoKHRoaXMpXG4gICAgcDIuZWRnZXMucHVzaCh0aGlzKVxuICB9XG5cbiAgZ2V0T3RoZXJQb2ludEluRWRnZSAocG9pbnQpIHtcbiAgICByZXR1cm4gdGhpcy5wMS5pc1BvaW50RXF1YWwocG9pbnQpID8gdGhpcy5wMiA6IHRoaXMucDFcbiAgfVxuXG4gIGFyZUVkZ2VzRXF1YWwgKG90aGVyRWRnZSkge1xuICAgIGlmICh0aGlzLnAxLmlzUG9pbnRFcXVhbChvdGhlckVkZ2UucDEpICYmIHRoaXMucDIuaXNQb2ludEVxdWFsKG90aGVyRWRnZS5wMikpIHJldHVybiB0cnVlXG4gICAgaWYgKHRoaXMucDEuaXNQb2ludEVxdWFsKG90aGVyRWRnZS5wMikgJiYgdGhpcy5wMi5pc1BvaW50RXF1YWwob3RoZXJFZGdlLnAxKSkgcmV0dXJuIHRydWVcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNvbnRhaW5zUG9pbnQgKHBvaW50KSB7XG4gICAgaWYgKHRoaXMucDEuaXNQb2ludEVxdWFsKHBvaW50KSB8fCB0aGlzLnAyLmlzUG9pbnRFcXVhbChwb2ludCkpIHJldHVybiB0cnVlXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Edge.js\n");

/***/ }),

/***/ "./src/Point.js":
/*!**********************!*\
  !*** ./src/Point.js ***!
  \**********************/
/*! exports provided: Point */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Point\", function() { return Point; });\n// import { pi1, pi2 } from './utils'\nconst pi1 = Math.PI * 3 / 2\nconst pi2 = Math.PI / 2\n\nclass Point {\n\n  constructor (coords, polygonID) {\n    if (polygonID === null) polygonID = -1\n    this.x = coords[0]\n    this.y = coords[1]\n    this.polygonID = polygonID\n    this.edges = []\n    this.prevPoint = null\n    this.nextPoint = null\n  }\n\n  isPointEqual (otherPoint) {\n    return this.x === otherPoint.x && this.y === otherPoint.y\n  }\n\n  angleToPoint (otherPoint) {\n    if (this.isPointEqual(otherPoint)) return 0\n    const dx = otherPoint.x - this.x\n    const dy = otherPoint.y - this.y\n    if (dx === 0) dy < 1 ? pi1 : pi2\n    if (dy === 0) dx < 0 ? Math.PI : 0\n    if (dx < 0) return Math.PI + Math.atan(dy / dx)\n    if (dy < 0) return 2 * Math.PI + Math.atan(dy / dx)\n    return Math.atan(dy / dx)\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvUG9pbnQuanM/YzYxYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUEsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7O0FBRU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vc3JjL1BvaW50LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gaW1wb3J0IHsgcGkxLCBwaTIgfSBmcm9tICcuL3V0aWxzJ1xuY29uc3QgcGkxID0gTWF0aC5QSSAqIDMgLyAyXG5jb25zdCBwaTIgPSBNYXRoLlBJIC8gMlxuXG5leHBvcnQgY2xhc3MgUG9pbnQge1xuXG4gIGNvbnN0cnVjdG9yIChjb29yZHMsIHBvbHlnb25JRCkge1xuICAgIGlmIChwb2x5Z29uSUQgPT09IG51bGwpIHBvbHlnb25JRCA9IC0xXG4gICAgdGhpcy54ID0gY29vcmRzWzBdXG4gICAgdGhpcy55ID0gY29vcmRzWzFdXG4gICAgdGhpcy5wb2x5Z29uSUQgPSBwb2x5Z29uSURcbiAgICB0aGlzLmVkZ2VzID0gW11cbiAgICB0aGlzLnByZXZQb2ludCA9IG51bGxcbiAgICB0aGlzLm5leHRQb2ludCA9IG51bGxcbiAgfVxuXG4gIGlzUG9pbnRFcXVhbCAob3RoZXJQb2ludCkge1xuICAgIHJldHVybiB0aGlzLnggPT09IG90aGVyUG9pbnQueCAmJiB0aGlzLnkgPT09IG90aGVyUG9pbnQueVxuICB9XG5cbiAgYW5nbGVUb1BvaW50IChvdGhlclBvaW50KSB7XG4gICAgaWYgKHRoaXMuaXNQb2ludEVxdWFsKG90aGVyUG9pbnQpKSByZXR1cm4gMFxuICAgIGNvbnN0IGR4ID0gb3RoZXJQb2ludC54IC0gdGhpcy54XG4gICAgY29uc3QgZHkgPSBvdGhlclBvaW50LnkgLSB0aGlzLnlcbiAgICBpZiAoZHggPT09IDApIGR5IDwgMSA/IHBpMSA6IHBpMlxuICAgIGlmIChkeSA9PT0gMCkgZHggPCAwID8gTWF0aC5QSSA6IDBcbiAgICBpZiAoZHggPCAwKSByZXR1cm4gTWF0aC5QSSArIE1hdGguYXRhbihkeSAvIGR4KVxuICAgIGlmIChkeSA8IDApIHJldHVybiAyICogTWF0aC5QSSArIE1hdGguYXRhbihkeSAvIGR4KVxuICAgIHJldHVybiBNYXRoLmF0YW4oZHkgLyBkeClcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/Point.js\n");

/***/ }),

/***/ "./src/convex-hull.js":
/*!****************************!*\
  !*** ./src/convex-hull.js ***!
  \****************************/
/*! exports provided: makeConvexhull, convexhull */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"makeConvexhull\", function() { return makeConvexhull; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"convexhull\", function() { return convexhull; });\n/* \n * Convex hull algorithm - Library (JavaScript)\n * \n * Copyright (c) 2018 Project Nayuki\n * https://www.nayuki.io/page/convex-hull-algorithm\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program (see COPYING.txt and COPYING.LESSER.txt).\n * If not, see <http://www.gnu.org/licenses/>.\n */\n\n\n\n\n\t// Returns a new array of points representing the convex hull of\n\t// the given set of points. The convex hull excludes collinear points.\n\t// This algorithm runs in O(n log n) time.\nfunction makeConvexhull(points) {\n\t\tvar newPoints = points.slice();\n\t\tnewPoints.sort(POINT_COMPARATOR);\n\t\treturn makeHullPresorted(newPoints);\n\t};\n\nfunction convexhull() {\n\n};\n\n\t// Returns the convex hull, assuming that each points[i] <= points[i + 1]. Runs in O(n) time.\n\tfunction makeHullPresorted(points) {\n\t\tif (points.length <= 1)\n\t\t\treturn points.slice();\n\t\t\n\t\t// Andrew's monotone chain algorithm. Positive y coordinates correspond to \"up\"\n\t\t// as per the mathematical convention, instead of \"down\" as per the computer\n\t\t// graphics convention. This doesn't affect the correctness of the result.\n\t\t\n\t\tvar upperHull = [];\n\t\tfor (var i = 0; i < points.length; i++) {\n\t\t\tvar p = points[i];\n\t\t\twhile (upperHull.length >= 2) {\n\t\t\t\tvar q = upperHull[upperHull.length - 1];\n\t\t\t\tvar r = upperHull[upperHull.length - 2];\n\t\t\t\tif ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x))\n\t\t\t\t\tupperHull.pop();\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tupperHull.push(p);\n\t\t}\n\t\tupperHull.pop();\n\t\t\n\t\tvar lowerHull = [];\n\t\tfor (var i = points.length - 1; i >= 0; i--) {\n\t\t\tvar p = points[i];\n\t\t\twhile (lowerHull.length >= 2) {\n\t\t\t\tvar q = lowerHull[lowerHull.length - 1];\n\t\t\t\tvar r = lowerHull[lowerHull.length - 2];\n\t\t\t\tif ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x))\n\t\t\t\t\tlowerHull.pop();\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlowerHull.push(p);\n\t\t}\n\t\tlowerHull.pop();\n\t\t\n\t\tif (upperHull.length == 1 && lowerHull.length == 1 && upperHull[0].x == lowerHull[0].x && upperHull[0].y == lowerHull[0].y)\n\t\t\treturn upperHull;\n\t\telse\n\t\t\treturn upperHull.concat(lowerHull);\n\t};\n\t\n\t\n\tfunction POINT_COMPARATOR(a, b) {\n\t\tif (a.x < b.x)\n\t\t\treturn -1;\n\t\telse if (a.x > b.x)\n\t\t\treturn +1;\n\t\telse if (a.y < b.y)\n\t\t\treturn -1;\n\t\telse if (a.y > b.y)\n\t\t\treturn +1;\n\t\telse\n\t\t\treturn 0;\n\t};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29udmV4LWh1bGwuanM/NDRlMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7OztBQUdiO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vc3JjL2NvbnZleC1odWxsLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogXG4gKiBDb252ZXggaHVsbCBhbGdvcml0aG0gLSBMaWJyYXJ5IChKYXZhU2NyaXB0KVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTggUHJvamVjdCBOYXl1a2lcbiAqIGh0dHBzOi8vd3d3Lm5heXVraS5pby9wYWdlL2NvbnZleC1odWxsLWFsZ29yaXRobVxuICogXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICogKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiAqIFxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICogR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4gKiBcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0gKHNlZSBDT1BZSU5HLnR4dCBhbmQgQ09QWUlORy5MRVNTRVIudHh0KS5cbiAqIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5cdC8vIFJldHVybnMgYSBuZXcgYXJyYXkgb2YgcG9pbnRzIHJlcHJlc2VudGluZyB0aGUgY29udmV4IGh1bGwgb2Zcblx0Ly8gdGhlIGdpdmVuIHNldCBvZiBwb2ludHMuIFRoZSBjb252ZXggaHVsbCBleGNsdWRlcyBjb2xsaW5lYXIgcG9pbnRzLlxuXHQvLyBUaGlzIGFsZ29yaXRobSBydW5zIGluIE8obiBsb2cgbikgdGltZS5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlQ29udmV4aHVsbChwb2ludHMpIHtcblx0XHR2YXIgbmV3UG9pbnRzID0gcG9pbnRzLnNsaWNlKCk7XG5cdFx0bmV3UG9pbnRzLnNvcnQoUE9JTlRfQ09NUEFSQVRPUik7XG5cdFx0cmV0dXJuIG1ha2VIdWxsUHJlc29ydGVkKG5ld1BvaW50cyk7XG5cdH07XG5cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXhodWxsKCkge1xuXG59O1xuXG5cdC8vIFJldHVybnMgdGhlIGNvbnZleCBodWxsLCBhc3N1bWluZyB0aGF0IGVhY2ggcG9pbnRzW2ldIDw9IHBvaW50c1tpICsgMV0uIFJ1bnMgaW4gTyhuKSB0aW1lLlxuXHRmdW5jdGlvbiBtYWtlSHVsbFByZXNvcnRlZChwb2ludHMpIHtcblx0XHRpZiAocG9pbnRzLmxlbmd0aCA8PSAxKVxuXHRcdFx0cmV0dXJuIHBvaW50cy5zbGljZSgpO1xuXHRcdFxuXHRcdC8vIEFuZHJldydzIG1vbm90b25lIGNoYWluIGFsZ29yaXRobS4gUG9zaXRpdmUgeSBjb29yZGluYXRlcyBjb3JyZXNwb25kIHRvIFwidXBcIlxuXHRcdC8vIGFzIHBlciB0aGUgbWF0aGVtYXRpY2FsIGNvbnZlbnRpb24sIGluc3RlYWQgb2YgXCJkb3duXCIgYXMgcGVyIHRoZSBjb21wdXRlclxuXHRcdC8vIGdyYXBoaWNzIGNvbnZlbnRpb24uIFRoaXMgZG9lc24ndCBhZmZlY3QgdGhlIGNvcnJlY3RuZXNzIG9mIHRoZSByZXN1bHQuXG5cdFx0XG5cdFx0dmFyIHVwcGVySHVsbCA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgcCA9IHBvaW50c1tpXTtcblx0XHRcdHdoaWxlICh1cHBlckh1bGwubGVuZ3RoID49IDIpIHtcblx0XHRcdFx0dmFyIHEgPSB1cHBlckh1bGxbdXBwZXJIdWxsLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHR2YXIgciA9IHVwcGVySHVsbFt1cHBlckh1bGwubGVuZ3RoIC0gMl07XG5cdFx0XHRcdGlmICgocS54IC0gci54KSAqIChwLnkgLSByLnkpID49IChxLnkgLSByLnkpICogKHAueCAtIHIueCkpXG5cdFx0XHRcdFx0dXBwZXJIdWxsLnBvcCgpO1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHR1cHBlckh1bGwucHVzaChwKTtcblx0XHR9XG5cdFx0dXBwZXJIdWxsLnBvcCgpO1xuXHRcdFxuXHRcdHZhciBsb3dlckh1bGwgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gcG9pbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHR2YXIgcCA9IHBvaW50c1tpXTtcblx0XHRcdHdoaWxlIChsb3dlckh1bGwubGVuZ3RoID49IDIpIHtcblx0XHRcdFx0dmFyIHEgPSBsb3dlckh1bGxbbG93ZXJIdWxsLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHR2YXIgciA9IGxvd2VySHVsbFtsb3dlckh1bGwubGVuZ3RoIC0gMl07XG5cdFx0XHRcdGlmICgocS54IC0gci54KSAqIChwLnkgLSByLnkpID49IChxLnkgLSByLnkpICogKHAueCAtIHIueCkpXG5cdFx0XHRcdFx0bG93ZXJIdWxsLnBvcCgpO1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRsb3dlckh1bGwucHVzaChwKTtcblx0XHR9XG5cdFx0bG93ZXJIdWxsLnBvcCgpO1xuXHRcdFxuXHRcdGlmICh1cHBlckh1bGwubGVuZ3RoID09IDEgJiYgbG93ZXJIdWxsLmxlbmd0aCA9PSAxICYmIHVwcGVySHVsbFswXS54ID09IGxvd2VySHVsbFswXS54ICYmIHVwcGVySHVsbFswXS55ID09IGxvd2VySHVsbFswXS55KVxuXHRcdFx0cmV0dXJuIHVwcGVySHVsbDtcblx0XHRlbHNlXG5cdFx0XHRyZXR1cm4gdXBwZXJIdWxsLmNvbmNhdChsb3dlckh1bGwpO1xuXHR9O1xuXHRcblx0XG5cdGZ1bmN0aW9uIFBPSU5UX0NPTVBBUkFUT1IoYSwgYikge1xuXHRcdGlmIChhLnggPCBiLngpXG5cdFx0XHRyZXR1cm4gLTE7XG5cdFx0ZWxzZSBpZiAoYS54ID4gYi54KVxuXHRcdFx0cmV0dXJuICsxO1xuXHRcdGVsc2UgaWYgKGEueSA8IGIueSlcblx0XHRcdHJldHVybiAtMTtcblx0XHRlbHNlIGlmIChhLnkgPiBiLnkpXG5cdFx0XHRyZXR1cm4gKzE7XG5cdFx0ZWxzZVxuXHRcdFx0cmV0dXJuIDA7XG5cdH07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/convex-hull.js\n");

/***/ }),

/***/ "./src/graphHelper.js":
/*!****************************!*\
  !*** ./src/graphHelper.js ***!
  \****************************/
/*! exports provided: loadGraphFromFile, createGraphFromData, findRouteThroughGraph, updateGraphWithDynamicJSON */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadGraphFromFile\", function() { return loadGraphFromFile; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createGraphFromData\", function() { return createGraphFromData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findRouteThroughGraph\", function() { return findRouteThroughGraph; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"updateGraphWithDynamicJSON\", function() { return updateGraphWithDynamicJSON; });\n/* harmony import */ var ngraph_fromjson__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ngraph.fromjson */ \"../node_modules/ngraph.fromjson/index.js\");\n/* harmony import */ var ngraph_fromjson__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ngraph_fromjson__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var ngraph_path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ngraph.path */ \"../node_modules/ngraph.path/index.js\");\n/* harmony import */ var ngraph_path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ngraph_path__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _mapHelpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mapHelpers */ \"./src/mapHelpers.js\");\n\n\n\n// import Worker from './graphCreation.worker.js'\n\n\n\nvar dataJSON = \"\"\n\nfunction loadGraphFromFile (dataWithEdges) {\n  // function reqListener () {\n  //   const startLoad = window.performance.now()\n  //   dataJSON = this.responseText\n  //   const graph = fromjson(dataJSON)\n  //   dataJSON = dataJSON.substring(0, dataJSON.length-2)\n  //   dataJSON = dataJSON.substring(10, dataJSON.length)\n  //   console.log(graph.getNodesCount())\n  //   const endLoad = window.performance.now()\n  //   const timeTakenToLoad = parseInt(endLoad - startLoad)\n  //   console.log('Time to load: ', timeTakenToLoad)\n\n  //   setGraph(graph)\n  //   return findRouteThroughGraph(graph)\n  // }\n  Object(_mapHelpers__WEBPACK_IMPORTED_MODULE_2__[\"clearGraphRelatedData\"])()\n  // if(typeof window != \"undefined\")\n  //   const startLoad = window.performance.now()\n  dataJSON = dataWithEdges\n  const graph = ngraph_fromjson__WEBPACK_IMPORTED_MODULE_0___default()(dataJSON)\n  dataJSON = dataJSON.substring(0, dataJSON.length-2)\n  dataJSON = dataJSON.substring(10, dataJSON.length)\n  console.log(graph.getNodesCount())\n  // if(typeof window != \"undefined\"){\n  //   const endLoad = window.performance.now()\n  //   const timeTakenToLoad = parseInt(endLoad - startLoad)\n  //   console.log('Time to load: ', timeTakenToLoad)\n  // }\n\n  Object(_mapHelpers__WEBPACK_IMPORTED_MODULE_2__[\"setGraph\"])(graph)\n  return findRouteThroughGraph(graph)\n\n\n\n\n\n\n\n  // var oReq = new XMLHttpRequest() //eslint-disable-line\n  // oReq.addEventListener('load', reqListener)\n  // oReq.open('GET', filename)\n  // oReq.send()\n}\n\nfunction createGraphFromData (data) {\n  Object(_mapHelpers__WEBPACK_IMPORTED_MODULE_2__[\"clearGraphRelatedData\"])()\n  const worker = new Worker() //eslint-disable-line\n\n  // if(typeof window != \"undefined\")\n  //   const startCreation = window.performance.now()\n  worker.postMessage(data)\n\n  worker.onmessage = function (e) {\n    // if(typeof window != \"undefined\"){\n    //   const endCreation = window.performance.now()\n    //   const timeTakenToCreate = parseInt(endCreation - startCreation)\n    //   console.log('Time to construct: ', timeTakenToCreate)\n    // }\n    const graph = ngraph_fromjson__WEBPACK_IMPORTED_MODULE_0___default()(e.data)\n    console.log(graph.getNodesCount())\n    Object(_mapHelpers__WEBPACK_IMPORTED_MODULE_2__[\"setGraph\"])(graph)\n    return findRouteThroughGraph(graph)\n  }\n}\n\nfunction findRouteThroughGraph (graph) {\n  const pathFinder = ngraph_path__WEBPACK_IMPORTED_MODULE_1___default.a.nba(graph, {\n    distance (fromNode, toNode) {\n      const dx = fromNode.data.x - toNode.data.x\n      const dy = fromNode.data.y - toNode.data.y\n      return Math.sqrt(dx * dx + dy * dy)\n    }\n  })\n  return Object(_mapHelpers__WEBPACK_IMPORTED_MODULE_2__[\"setPathFinder\"])(pathFinder)\n}\n\nfunction updateGraphWithDynamicJSON (dynamicNodesJSON, dynamicEdgesJSON) {\n    // if(typeof window != \"undefined\")\n    //   const startLoad = window.performance.now()\n    const graph = ngraph_fromjson__WEBPACK_IMPORTED_MODULE_0___default()('{\"nodes\":[' + dynamicNodesJSON + dataJSON + dynamicEdgesJSON + \"]}\")\n    console.log(graph.getNodesCount())\n    // if(typeof window != \"undefined\"){\n    //   const endLoad = window.performance.now()\n    //   const timeTakenToLoad = parseInt(endLoad - startLoad)\n    //   console.log('Time to load: ', timeTakenToLoad)\n    // }\n\n    Object(_mapHelpers__WEBPACK_IMPORTED_MODULE_2__[\"setGraph\"])(graph)\n    findRouteThroughGraph(graph)\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZ3JhcGhIZWxwZXIuanM/MjhkYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFzQztBQUNSOztBQUU5Qjs7QUFFNkU7O0FBRTdFOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRSx5RUFBcUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNEQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSw0REFBUTtBQUNWOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCxFQUFFLHlFQUFxQjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNEQUFRO0FBQzFCO0FBQ0EsSUFBSSw0REFBUTtBQUNaO0FBQ0E7QUFDQTs7QUFFTztBQUNQLHFCQUFxQixrREFBSTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFNBQVMsaUVBQWE7QUFDdEI7O0FBRU87QUFDUDtBQUNBO0FBQ0Esa0JBQWtCLHNEQUFRLEdBQUcsaUVBQWlFO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLDREQUFRO0FBQ1o7QUFDQSIsImZpbGUiOiIuL3NyYy9ncmFwaEhlbHBlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmcm9tanNvbiBmcm9tICduZ3JhcGguZnJvbWpzb24nXG5pbXBvcnQgcGF0aCBmcm9tICduZ3JhcGgucGF0aCdcblxuLy8gaW1wb3J0IFdvcmtlciBmcm9tICcuL2dyYXBoQ3JlYXRpb24ud29ya2VyLmpzJ1xuXG5pbXBvcnQgeyBzZXRQYXRoRmluZGVyLCBzZXRHcmFwaCwgY2xlYXJHcmFwaFJlbGF0ZWREYXRhIH0gZnJvbSAnLi9tYXBIZWxwZXJzJ1xuXG52YXIgZGF0YUpTT04gPSBcIlwiXG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkR3JhcGhGcm9tRmlsZSAoZGF0YVdpdGhFZGdlcykge1xuICAvLyBmdW5jdGlvbiByZXFMaXN0ZW5lciAoKSB7XG4gIC8vICAgY29uc3Qgc3RhcnRMb2FkID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpXG4gIC8vICAgZGF0YUpTT04gPSB0aGlzLnJlc3BvbnNlVGV4dFxuICAvLyAgIGNvbnN0IGdyYXBoID0gZnJvbWpzb24oZGF0YUpTT04pXG4gIC8vICAgZGF0YUpTT04gPSBkYXRhSlNPTi5zdWJzdHJpbmcoMCwgZGF0YUpTT04ubGVuZ3RoLTIpXG4gIC8vICAgZGF0YUpTT04gPSBkYXRhSlNPTi5zdWJzdHJpbmcoMTAsIGRhdGFKU09OLmxlbmd0aClcbiAgLy8gICBjb25zb2xlLmxvZyhncmFwaC5nZXROb2Rlc0NvdW50KCkpXG4gIC8vICAgY29uc3QgZW5kTG9hZCA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKVxuICAvLyAgIGNvbnN0IHRpbWVUYWtlblRvTG9hZCA9IHBhcnNlSW50KGVuZExvYWQgLSBzdGFydExvYWQpXG4gIC8vICAgY29uc29sZS5sb2coJ1RpbWUgdG8gbG9hZDogJywgdGltZVRha2VuVG9Mb2FkKVxuXG4gIC8vICAgc2V0R3JhcGgoZ3JhcGgpXG4gIC8vICAgcmV0dXJuIGZpbmRSb3V0ZVRocm91Z2hHcmFwaChncmFwaClcbiAgLy8gfVxuICBjbGVhckdyYXBoUmVsYXRlZERhdGEoKVxuICAvLyBpZih0eXBlb2Ygd2luZG93ICE9IFwidW5kZWZpbmVkXCIpXG4gIC8vICAgY29uc3Qgc3RhcnRMb2FkID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpXG4gIGRhdGFKU09OID0gZGF0YVdpdGhFZGdlc1xuICBjb25zdCBncmFwaCA9IGZyb21qc29uKGRhdGFKU09OKVxuICBkYXRhSlNPTiA9IGRhdGFKU09OLnN1YnN0cmluZygwLCBkYXRhSlNPTi5sZW5ndGgtMilcbiAgZGF0YUpTT04gPSBkYXRhSlNPTi5zdWJzdHJpbmcoMTAsIGRhdGFKU09OLmxlbmd0aClcbiAgY29uc29sZS5sb2coZ3JhcGguZ2V0Tm9kZXNDb3VudCgpKVxuICAvLyBpZih0eXBlb2Ygd2luZG93ICE9IFwidW5kZWZpbmVkXCIpe1xuICAvLyAgIGNvbnN0IGVuZExvYWQgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KClcbiAgLy8gICBjb25zdCB0aW1lVGFrZW5Ub0xvYWQgPSBwYXJzZUludChlbmRMb2FkIC0gc3RhcnRMb2FkKVxuICAvLyAgIGNvbnNvbGUubG9nKCdUaW1lIHRvIGxvYWQ6ICcsIHRpbWVUYWtlblRvTG9hZClcbiAgLy8gfVxuXG4gIHNldEdyYXBoKGdyYXBoKVxuICByZXR1cm4gZmluZFJvdXRlVGhyb3VnaEdyYXBoKGdyYXBoKVxuXG5cblxuXG5cblxuXG4gIC8vIHZhciBvUmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCkgLy9lc2xpbnQtZGlzYWJsZS1saW5lXG4gIC8vIG9SZXEuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHJlcUxpc3RlbmVyKVxuICAvLyBvUmVxLm9wZW4oJ0dFVCcsIGZpbGVuYW1lKVxuICAvLyBvUmVxLnNlbmQoKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlR3JhcGhGcm9tRGF0YSAoZGF0YSkge1xuICBjbGVhckdyYXBoUmVsYXRlZERhdGEoKVxuICBjb25zdCB3b3JrZXIgPSBuZXcgV29ya2VyKCkgLy9lc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgLy8gaWYodHlwZW9mIHdpbmRvdyAhPSBcInVuZGVmaW5lZFwiKVxuICAvLyAgIGNvbnN0IHN0YXJ0Q3JlYXRpb24gPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KClcbiAgd29ya2VyLnBvc3RNZXNzYWdlKGRhdGEpXG5cbiAgd29ya2VyLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgLy8gaWYodHlwZW9mIHdpbmRvdyAhPSBcInVuZGVmaW5lZFwiKXtcbiAgICAvLyAgIGNvbnN0IGVuZENyZWF0aW9uID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpXG4gICAgLy8gICBjb25zdCB0aW1lVGFrZW5Ub0NyZWF0ZSA9IHBhcnNlSW50KGVuZENyZWF0aW9uIC0gc3RhcnRDcmVhdGlvbilcbiAgICAvLyAgIGNvbnNvbGUubG9nKCdUaW1lIHRvIGNvbnN0cnVjdDogJywgdGltZVRha2VuVG9DcmVhdGUpXG4gICAgLy8gfVxuICAgIGNvbnN0IGdyYXBoID0gZnJvbWpzb24oZS5kYXRhKVxuICAgIGNvbnNvbGUubG9nKGdyYXBoLmdldE5vZGVzQ291bnQoKSlcbiAgICBzZXRHcmFwaChncmFwaClcbiAgICByZXR1cm4gZmluZFJvdXRlVGhyb3VnaEdyYXBoKGdyYXBoKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kUm91dGVUaHJvdWdoR3JhcGggKGdyYXBoKSB7XG4gIGNvbnN0IHBhdGhGaW5kZXIgPSBwYXRoLm5iYShncmFwaCwge1xuICAgIGRpc3RhbmNlIChmcm9tTm9kZSwgdG9Ob2RlKSB7XG4gICAgICBjb25zdCBkeCA9IGZyb21Ob2RlLmRhdGEueCAtIHRvTm9kZS5kYXRhLnhcbiAgICAgIGNvbnN0IGR5ID0gZnJvbU5vZGUuZGF0YS55IC0gdG9Ob2RlLmRhdGEueVxuICAgICAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSlcbiAgICB9XG4gIH0pXG4gIHJldHVybiBzZXRQYXRoRmluZGVyKHBhdGhGaW5kZXIpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVHcmFwaFdpdGhEeW5hbWljSlNPTiAoZHluYW1pY05vZGVzSlNPTiwgZHluYW1pY0VkZ2VzSlNPTikge1xuICAgIC8vIGlmKHR5cGVvZiB3aW5kb3cgIT0gXCJ1bmRlZmluZWRcIilcbiAgICAvLyAgIGNvbnN0IHN0YXJ0TG9hZCA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKVxuICAgIGNvbnN0IGdyYXBoID0gZnJvbWpzb24oJ3tcIm5vZGVzXCI6WycgKyBkeW5hbWljTm9kZXNKU09OICsgZGF0YUpTT04gKyBkeW5hbWljRWRnZXNKU09OICsgXCJdfVwiKVxuICAgIGNvbnNvbGUubG9nKGdyYXBoLmdldE5vZGVzQ291bnQoKSlcbiAgICAvLyBpZih0eXBlb2Ygd2luZG93ICE9IFwidW5kZWZpbmVkXCIpe1xuICAgIC8vICAgY29uc3QgZW5kTG9hZCA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKVxuICAgIC8vICAgY29uc3QgdGltZVRha2VuVG9Mb2FkID0gcGFyc2VJbnQoZW5kTG9hZCAtIHN0YXJ0TG9hZClcbiAgICAvLyAgIGNvbnNvbGUubG9nKCdUaW1lIHRvIGxvYWQ6ICcsIHRpbWVUYWtlblRvTG9hZClcbiAgICAvLyB9XG5cbiAgICBzZXRHcmFwaChncmFwaClcbiAgICBmaW5kUm91dGVUaHJvdWdoR3JhcGgoZ3JhcGgpXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/graphHelper.js\n");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _mapHelpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mapHelpers */ \"./src/mapHelpers.js\");\n/* harmony import */ var _graphHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./graphHelper */ \"./src/graphHelper.js\");\n// import createGraph from 'ngraph.graph'\n\n\n\n\n\n\n\n// import Vue from 'vue'\n// import App from './App.vue'\n// import VueWorker from 'vue-worker'\n\n// Vue.use(VueWorker)\n// new Vue({\n//   el: '#app',\n//   render: h => h(App)\n// })\n\n\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5qcz81NmQ3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ2lFO0FBQ0s7Ozs7OztBQU10RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJIiwiZmlsZSI6Ii4vc3JjL21haW4uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBpbXBvcnQgY3JlYXRlR3JhcGggZnJvbSAnbmdyYXBoLmdyYXBoJ1xuaW1wb3J0IHsgc2V0dXBNYXAsIHNldERhdGEsIHNldHVwUm91dGVMYXllciB9IGZyb20gJy4vbWFwSGVscGVycydcbmltcG9ydCB7IGxvYWRHcmFwaEZyb21GaWxlLCBjcmVhdGVHcmFwaEZyb21EYXRhIH0gZnJvbSAnLi9ncmFwaEhlbHBlcidcblxuXG5cblxuXG4vLyBpbXBvcnQgVnVlIGZyb20gJ3Z1ZSdcbi8vIGltcG9ydCBBcHAgZnJvbSAnLi9BcHAudnVlJ1xuLy8gaW1wb3J0IFZ1ZVdvcmtlciBmcm9tICd2dWUtd29ya2VyJ1xuXG4vLyBWdWUudXNlKFZ1ZVdvcmtlcilcbi8vIG5ldyBWdWUoe1xuLy8gICBlbDogJyNhcHAnLFxuLy8gICByZW5kZXI6IGggPT4gaChBcHApXG4vLyB9KVxuXG5cblxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/main.js\n");

/***/ }),

/***/ "./src/mapHelpers.js":
/*!***************************!*\
  !*** ./src/mapHelpers.js ***!
  \***************************/
/*! exports provided: setupMap, setData, clearGraphRelatedData, setupRouteLayer, setPathFinder, setGraph */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setupMap\", function() { return setupMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setData\", function() { return setData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clearGraphRelatedData\", function() { return clearGraphRelatedData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setupRouteLayer\", function() { return setupRouteLayer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setPathFinder\", function() { return setPathFinder; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setGraph\", function() { return setGraph; });\n/* harmony import */ var _Point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Point */ \"./src/Point.js\");\n/* harmony import */ var _setupStructure__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./setupStructure */ \"./src/setupStructure.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n/* harmony import */ var _src_main__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../src/main */ \"../src/main.js\");\n/* harmony import */ var _convex_hull__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./convex-hull */ \"./src/convex-hull.js\");\n/* harmony import */ var _graphHelper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./graphHelper */ \"./src/graphHelper.js\");\n// import createGraph from './ngraph.graph'\n\n\n\n\n\n\n\n\nlet map = null\nlet startMarker = null\nlet endMarker = null\nlet selectionLayer = null\nlet polyLayer = null\nlet points = null\nlet pointsLyr = null\nlet graphData = null\nlet foundPath = null\nlet pathFinder = null\nlet routeLayer = null\nlet points1 = []\nlet points2 = []\nlet pointsArr = []\nlet turfPolygons = []\nvar output = \"\"\nvar multiplier = 1000 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000\nvar updatingPathMarkers = false\nvar allTangents = []\nvar startPoint = null\nvar endPoint = null\n\n\nfunction setupMap (start, end, showMap) {\n  if(showMap){\n    map = L.map('map', {\n      minZoom: 1,\n      maxZoom: 20,\n      center: [0, 0],\n      zoom: 2,\n      crs: L.CRS.Simple\n    })\n\n    L.NumberedDivIcon = createNumberDiv()\n  }\n\n  if(start == null){\n    // var start = [73.19374999403954,0.6548828072845936]\n    // var end = [73.198449611664,0.691950189807585]\n\n    // var start = [73.20313720591366,0.66888427734375]\n    // var end = [73.22689209133387,0.6780517548322678]\n\n    // var start = [73.2007812410593,0.6654785238206387]\n    // var end = [73.2010742276907,0.7003906257450581]\n\n    // var start = [73.14657642738,0.6639903635426379]\n    // var end = [73.2010742276907,0.7003906257450581]\n\n\n    var start = [73.19707030057907,0.6677734404802322]\n    var end = [73.17901611328125,0.6834106449969113]\n\n\n\n\n\n    var start = [73.18628847599,0.6605490743581441]\n    var end = [73.169002590224,0.6689311701630487]\n\n\n\n\n    var start = [73.234375,0.14453119039535522]\n    var end = [73.169002590224,0.6689311701630487]\n  }\n\n\n  startPoint = new _Point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"](start);\n  endPoint = new _Point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"](end);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  // var start = [73.196550607681,0.6745385270131692]\n  // var end = [73.195617198944,0.6747423607673824]\n\n  // var start = [73.18461914360523,0.6880859322845936]\n  // var end = [73.198449611664,0.691950189807585]\n\n  if(showMap){\n    startMarker = L.marker([start[1],start[0]], {\n      draggable: true,\n      icon: new L.NumberedDivIcon()\n    }).addTo(map)\n\n    endMarker = L.marker([end[1],end[0]], {\n      draggable: true,\n      icon: new L.NumberedDivIcon()\n    }).addTo(map)\n\n    startMarker.on('drag', updatePathMarkers)\n    endMarker.on('drag', updatePathMarkers)\n    selectionLayer = L.layerGroup([]).addTo(map)\n  }\n}\n\nfunction setData (data, showMap) {\n  if(showMap){\n    polyLayer = L.geoJson(data, {\n      noClip: true,\n      stroke: false,\n      fillColor: '#8B99AE'\n    }).addTo(map)\n\n    map.fitBounds(polyLayer.getBounds(), {\n      padding: [20, 20]\n    })\n\n    points = turf.featureCollection([])\n\n    pointsLyr = L.layerGroup([], {\n      pane: 'popupPane'\n    }).addTo(map)\n\n    turf.meta.coordEach(data, function (currentCoord) {\n      points.features.push(turf.point([currentCoord[0], currentCoord[1]]))\n\n      var layer = L.circleMarker([currentCoord[1], currentCoord[0]], {\n        radius: 3,\n        opacity: 0,\n        fillOpacity: 0.5,\n        origPoint: [currentCoord[0], currentCoord[1]]\n      }).addTo(pointsLyr)\n      layer.on('mouseover', highlightFeature)\n      layer.on('mouseout', unhighlightFeature)\n\n    }, true)\n  }\n\n\n\n\n\n\n\n\n  Object(_src_main__WEBPACK_IMPORTED_MODULE_3__[\"loadPoints\"])(data)\n\n  for (var i = data.features.length - 1; i >= 0; i--) {\n    const edges = []\n    const polygons = []\n    points1 = []\n    Object(_setupStructure__WEBPACK_IMPORTED_MODULE_1__[\"setupStructure\"])(data.features[i], edges, points1, polygons, i)\n    pointsArr.push(points1.slice(0))\n  }\n\n  // for (var i = data.geometry.coordinates.length - 1; i >= 0; i--) {\n  //   const edges = []\n  //   const polygons = []\n  //   points1 = []\n  //   setupStructure(data.geometry.coordinates[i], edges, points1, polygons, i)\n  //   pointsArr.push(points1.slice(0))\n  // }\n\n  // loadTurfPolygons(data)\n\n\n\n\n\n\n\n\n  // var tangents = getPolygonTangents(new Point([73.14657642738,0.6639903635426379]), pointsArr[11])\n\n  // console.log(\"\\tvar start = [\"+createNodeId2(new Point([73.14657642738,0.6639903635426379]))+\"]\\n\\tvar end = [\"+createNodeId2(tangents[1])+\"]\\n\\n\")\n\n\n\n\n\n    console.log('starting')\n\n  // for (var i = pointsArr.length - 1; i >= 0; i--) {\n  // // for (var i = 19 - 1; i >= 0; i--) {\n  //   // var i = 4;\n  //   // var j = 11;\n\n  //   // var i = 4;\n  //   // var j = 9;\n\n  //   // var i = 11;\n  //   // var j = 0;\n\n  //   for (var j = i - 1; j >= 0; j--) {\n  //   // for (var j = 5; j >= 2; j--) {\n  //   //   if(i == j) continue\n  //     // console.log('test')\n  //   // console.log('i: ' + i + ' j: ' + j)\n  //     // find4Tangents(pointsArr[i], pointsArr[j], turfPolygons[i], turfPolygons[j])\n  //     find4Tangents(pointsArr[i], pointsArr[j])\n\n  //   }\n\n\n  //   // find shortcuts to skip concave parts of polygons\n  //   var pArr = pointsArr[i]\n  //   var hull = makeConvexhull(pArr);\n  //   console.log('test')\n  //   var l = 0\n  //   for (var k = 0; k < hull.length; k++) {\n  //     var nextPoint = hull[ (k+1) % hull.length ]\n\n  //     // find the point that matches the point in the hull\n  //     while( !pArr[l].isPointEqual(hull[k])){\n  //       l = (l+1) % pArr.length\n  //     }\n      \n  //     // if the next point is different we need the line between\n  //     if( !pArr[l].nextPoint.isPointEqual(nextPoint)){\n  //       // if(isVisible(hull[k],nextPoint))\n  //         output += ',{\"fromId\":\"'+ createNodeId2(hull[k]) +'\",\"toId\":\"'+createNodeId2(nextPoint)+'\"}'\n  //     }\n  //   }\n  // }\n\n  // console.log(allTangents.length)\n  // for (var i = allTangents.length - 1; i >= 0; i--) {\n  //   console.log('test')\n  //   var p1 = allTangents[i]\n\n  //   var nodesVisible = getVisibleNodes(p1)\n\n  //   for (var k = nodesVisible.length - 1; k >= 0; k--) {\n  //     for (var j = i - 1; j >= 0; j--) {\n  //       var p2 = allTangents[j]\n\n  //       if(nodesVisible[k].x == p2.x && nodesVisible[k].y == p2.y ){\n  //         output += ',{\"fromId\":\"'+ createNodeId2(p1) +'\",\"toId\":\"'+createNodeId2(p2)+'\"}'\n  //       }\n\n  //       // if(isVisible(p1, p2))\n  //       //   output += ',{\"fromId\":\"'+ createNodeId2(p1) +'\",\"toId\":\"'+createNodeId2(p2)+'\"}'\n  //     }\n  //   }\n\n  // }\n\n\n  console.log(output)\n\n}\n\nfunction loadTurfPolygons(data){\n  for (var i = 0; i < pointsArr.length; i++) {\n    var aAsInt = []\n    var a = pointsArr[i]\n\n    for (var j = 0; j < a.length; j++) {\n      aAsInt.push([Math.round(a[j].x * multiplier), Math.round(a[j].y * multiplier)])\n    }\n    aAsInt.push([Math.round(a[0].x * multiplier), Math.round(a[0].y * multiplier)]) // just to make sure last is equal to first\n\n    turfPolygons.push(turf.polygon([aAsInt]));\n  }\n}\n\n  \n// determines the quadrant of a point \n// (used in compare()) \nfunction quad(p) \n{ \n    if (p.x >= 0 && p.y >= 0) \n        return 1; \n    if (p.x <= 0 && p.y >= 0) \n        return 2; \n    if (p.x <= 0 && p.y <= 0) \n        return 3; \n    return 4; \n} \n  \n// Checks whether the line is crossing the polygon \nfunction orientation( a, b, c) \n{ \n    var res = (b.y-a.y)*(c.x-b.x) - \n              (c.y-b.y)*(b.x-a.x); \n  \n    if (res == 0) \n        return 0; \n    if (res > 0) \n        return 1; \n    return -1; \n} \n  \nfunction clonePoints (points) {\n  return points.slice(0)\n}\n\nfunction sortPoints (point, clonedPoints) {\n  clonedPoints.sort((a, b) => {\n    var p = new _Point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"]([a.x - mid.x, \n                                a.y - mid.y]); \n    var q = new _Point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"]([b.x - mid.x, \n                                b.y - mid.y]); \n  \n    var one = quad(p); \n    var two = quad(q); \n  \n    if (one != two) \n        return (one < two ? -1 : 1); \n    return (p.y*q.x < q.y*p.x ? -1 : 1); \n  })\n}\n\n// function sortPoints (point, clonedPoints) {\n//   clonedPoints.sort((a, b) => {\n//     const angle1 = point.angleToPoint(a)\n//     const angle2 = point.angleToPoint(b)\n//     if (angle1 < angle2) return -1\n//     if (angle1 > angle2) return 1\n//     const dist1 = calcEdgeDistance(point, a)\n//     const dist2 = calcEdgeDistance(point, b)\n//     if (dist1 < dist2) return -1\n//     if (dist1 > dist2) return 1\n//     return 0\n//   })\n// }\n\nfunction getPolygonTangents(srcPoint, pointsArr){\n    // initialize using first point\n    var firstPoint = pointsArr[pointsArr.length - 1]\n    var angle = srcPoint.angleToPoint(firstPoint)\n    var leftMostAngle = angle\n    var rightMostAngle = angle\n    var leftMostPoint = firstPoint\n    var rightMostPoint = firstPoint\n        // routeLayer.setLatLngs([srcPoint, firstPoint])\n\n    for (var i =  pointsArr.length - 2;  i >= 0; i--) {\n        // is this point more towards left than left most point?\n        var angle = srcPoint.angleToPoint(pointsArr[i])\n        var diff1 = rightMostAngle - angle\n        diff1 = diff1 < 0 ? ((diff1 < -Math.PI) ? diff1 + Math.PI*2 : Math.PI * 3) : diff1\n        // diff1 = diff1 < 0 ? diff1 + Math.PI*2 : diff1\n\n        // is this point more towards right than right most point?\n        var angle = srcPoint.angleToPoint(pointsArr[i])\n        var diff2 = angle - leftMostAngle\n        diff2 = diff2 < 0 ? ((diff2 < -Math.PI) ? diff2 + Math.PI*2 : Math.PI * 3) : diff2\n        // diff2 = diff2 < 0 ? diff2 + Math.PI*2 : diff2\n\n        // if(i == 56)\n        //   i = i\n\n\n        /* if unchartered angle */\n        if(diff1 < Math.PI/2 || diff2 < Math.PI/2){\n          if(diff1 < diff2){\n            /* if closer to left most point */\n            rightMostAngle = angle\n            rightMostPoint = pointsArr[i]\n          }else{\n            leftMostAngle = angle\n            leftMostPoint = pointsArr[i]\n            // break\n          }\n        }\n    }\n\n    return [leftMostPoint, rightMostPoint]\n}\n\nfunction getDynamicEdgesJSON(startPoint, endPoint)\n{\n  var dynamicEdgesJSON = \"\"\n  // var startPoint = new Point([startPoint.geometry.coordinates[0], startPoint.geometry.coordinates[1]]);\n  // var endPoint = new Point([endPoint.geometry.coordinates[0], endPoint.geometry.coordinates[1]]);\n  Object(_src_main__WEBPACK_IMPORTED_MODULE_3__[\"addStartingAndEndingNodes\"])(startPoint, endPoint)\n\n\n  var pointsToConnect = []\n  var polygonIds = []\n  pointsToConnect.push([endPoint, startPoint])\n  pointsToConnect.push([startPoint, endPoint])\n  polygonIds.push(-1)\n  polygonIds.push(-1)\n  var k = 0\n\n  while(pointsToConnect.length != 0){\n    var oldPointsToConnect = pointsToConnect.slice(0)\n    var oldPolygonIds = polygonIds.slice(0)\n    pointsToConnect = []\n    polygonIds = []\n\n    for (var i = oldPointsToConnect.length - 1; i >= 0; i--) {\n      var srcPoint = oldPointsToConnect[i][0]\n      var destPoint = oldPointsToConnect[i][1]\n\n      var angle = srcPoint.angleToPoint(destPoint)\n      var noObstructingPolygons = true\n\n      for (var j = pointsArr.length - 1; j >= 0; j--) {\n        var tangents = getPolygonTangents(oldPointsToConnect[i][0], pointsArr[j])\n        var angle1 = srcPoint.angleToPoint(tangents[0])\n        var angle2 = srcPoint.angleToPoint(tangents[1])\n\n        // make all angles relative to right most angle (angle2) by making right most angle 0 (starting angle)\n        var angle0 = angle - angle2\n        angle1 -= angle2\n        angle2 -= angle2\n\n        if(angle2 < angle0 && angle0 < angle1){\n          var obstructingEdge = Object(_src_main__WEBPACK_IMPORTED_MODULE_3__[\"getObstructingEdge\"])(oldPointsToConnect[i][0], oldPointsToConnect[i][1], pointsArr[j])\n\n          if(obstructingEdge != null){\n            noObstructingPolygons = false\n            pointsToConnect.push([oldPointsToConnect[i][0], tangents[0]])\n            pointsToConnect.push([oldPointsToConnect[i][0], tangents[1]])\n            break;\n          }\n        }\n      }\n\n      if(noObstructingPolygons)\n        dynamicEdgesJSON += ',{\"fromId\":\"'+createNodeId2(oldPointsToConnect[i][0])+'\",\"toId\":\"'+createNodeId2(oldPointsToConnect[i][1])+'\"}'\n    }\n    k++\n  }\n\n  return dynamicEdgesJSON\n}\n\n// function getDynamicEdgesJSON(startPoint, endPoint)\n// {\n//   var dynamicEdgesJSON = \"\"\n//   // var nearestPoint\n//   // var start = turf.point([Math.round(startPoint.geometry.coordinates[0] * multiplier), Math.round(startPoint.geometry.coordinates[1] * multiplier)]);\n//   // var end = turf.point([Math.round(endPoint.geometry.coordinates[0] * multiplier), Math.round(endPoint.geometry.coordinates[1] * multiplier)]);\n//   var startPoint = new Point([startPoint.geometry.coordinates[0], startPoint.geometry.coordinates[1]]);\n//   var endPoint = new Point([endPoint.geometry.coordinates[0], endPoint.geometry.coordinates[1]]);\n//   addStartingAndEndingNodes(startPoint, endPoint)\n\n//   var pointsToConnect = []\n//   var polygonIds = []\n//   pointsToConnect.push([endPoint, startPoint])\n//   // pointsToConnect.push([startPoint, endPoint])\n//   polygonIds.push(-1)\n//   // polygonIds.push(-1)\n//   var k = 0\n\n//   while(pointsToConnect.length != 0){\n//     var oldPointsToConnect = pointsToConnect.slice(0)\n//     var oldPolygonIds = polygonIds.slice(0)\n//     pointsToConnect = []\n//     polygonIds = []\n//     for (var i = oldPointsToConnect.length - 1; i >= 0; i--) {\n//       // var turfPoint = turf.point([Math.round(oldPointsToConnect[i][0].x * multiplier), Math.round(oldPointsToConnect[i][0].y * multiplier)]);\n//       var obstructingEdge = getObstructingEdge(oldPointsToConnect[i][0], oldPointsToConnect[i][1])\n//       if(obstructingEdge == null){\n//         // if(isVisible(oldPointsToConnect[i][0], oldPointsToConnect[i][1]))\n//           dynamicEdgesJSON += ',{\"fromId\":\"'+createNodeId2(oldPointsToConnect[i][0])+'\",\"toId\":\"'+createNodeId2(oldPointsToConnect[i][1])+'\"}'\n//       }else{\n//         var j = turfPolygons.length - obstructingEdge.p1.polygonID - 1\n//         if(j == oldPolygonIds[i])\n//           dynamicEdgesJSON += ',{\"fromId\":\"'+createNodeId2(oldPointsToConnect[i][0])+'\",\"toId\":\"'+createNodeId2(oldPointsToConnect[i][1])+'\"}'\n//         else{\n//           var tangents = getPolygonTangents(oldPointsToConnect[i][0], pointsArr[j])\n//           pointsToConnect.push([oldPointsToConnect[i][0], tangents[0]])\n//           pointsToConnect.push([oldPointsToConnect[i][0], tangents[1]])\n//           polygonIds.push(j)\n//           polygonIds.push(j)\n\n\n\n\n\n\n\n\n\n\n\n//           // var features1 = turf.polygonTangents(turfPoint, turfPolygons[j]).features\n//           // if(features1.length > 2)\n//           //   alert('More than 2 tangents')\n\n//           // var nearestPoint = turf.nearestPoint(turf.point([features1[0].geometry.coordinates[0]/multiplier, features1[0].geometry.coordinates[1]/multiplier]), points)\n//           // var tangent1 = new Point([nearestPoint.geometry.coordinates[0], nearestPoint.geometry.coordinates[1]])\n//           // nearestPoint = turf.nearestPoint(turf.point([features1[1].geometry.coordinates[0]/multiplier, features1[1].geometry.coordinates[1]/multiplier]), points)\n//           // var tangent2 = new Point([nearestPoint.geometry.coordinates[0], nearestPoint.geometry.coordinates[1]])\n//           // pointsToConnect.push([oldPointsToConnect[i][0], tangent1])\n//           // pointsToConnect.push([oldPointsToConnect[i][0], tangent2])\n//           // polygonIds.push(j)\n//           // polygonIds.push(j)\n\n\n\n\n\n\n\n\n\n//           if(k==0){\n//             pointsToConnect.push([oldPointsToConnect[oldPointsToConnect.length-1-i][0], tangents[0]])\n//             pointsToConnect.push([oldPointsToConnect[oldPointsToConnect.length-1-i][0], tangents[1]])\n//             polygonIds.push(-1)\n//             polygonIds.push(-1)\n//           }\n\n\n//           // if(k==0){\n//           //   console.log(\"\\tvar start = [\"+createNodeId2(oldPointsToConnect[i][0])+\"]\\n\\tvar end = [\"+createNodeId2(tangents[0])+\"]\\n\\n\")\n//           //   console.log(\"\\tvar start = [\"+createNodeId2(oldPointsToConnect[i][0])+\"]\\n\\tvar end = [\"+createNodeId2(tangents[1])+\"]\\n\\n\")\n//           //   if(i==0)\n//           //     return dynamicEdgesJSON;\n//           // }\n\n//         }\n//       }\n//     }\n//     k++\n//   }\n\n//   // var nodesVisible1 = getVisibleNodes(startPoint, startPoint, endPoint)\n//   // var nodesVisible2 = getVisibleNodes(endPoint)\n//   // var startTangents = []\n//   // var endTangents = []\n\n//   // for (var i = 0; i < turfPolygons.length; i++) {\n//   //   console.log('test');\n\n//   //   var features1 = turf.polygonTangents(start, turfPolygons[i]).features\n//   //   var features2 = turf.polygonTangents(end, turfPolygons[i]).features\n\n//   //   var startTangent1 = new Point([features1[0].geometry.coordinates[0]/multiplier, features1[0].geometry.coordinates[1]/multiplier])\n//   //   var startTangent2 = new Point([features1[1].geometry.coordinates[0]/multiplier, features1[1].geometry.coordinates[1]/multiplier])\n//   //   startTangents.push(startTangent1)\n//   //   startTangents.push(startTangent2)\n\n//   //   var endTangent1 = new Point([features2[0].geometry.coordinates[0]/multiplier, features2[0].geometry.coordinates[1]/multiplier])\n//   //   var endTangent2 = new Point([features2[1].geometry.coordinates[0]/multiplier, features2[1].geometry.coordinates[1]/multiplier])\n//   //   endTangents.push(endTangent1)\n//   //   endTangents.push(endTangent2)\n\n//   //   if(i==11){\n//   //     console.log(\"\\tvar start = [\"+createNodeId2(startPoint)+\"]\\n\\tvar end = [\"+createNodeId(turf.nearestPoint(turf.point([startTangent1.x, startTangent1.y]), points))+\"]\\n\\n\")\n//   //     console.log(\"\\tvar start = [\"+createNodeId2(startPoint)+\"]\\n\\tvar end = [\"+createNodeId(turf.nearestPoint(turf.point([startTangent2.x, startTangent2.y]), points))+\"]\\n\\n\")\n//   //     console.log(\"\\tvar start = [\"+createNodeId2(endPoint)+\"]\\n\\tvar end = [\"+createNodeId(turf.nearestPoint(turf.point([endTangent1.x, endTangent1.y]), points))+\"]\\n\\n\")\n//   //     console.log(\"\\tvar start = [\"+createNodeId2(endPoint)+\"]\\n\\tvar end = [\"+createNodeId(turf.nearestPoint(turf.point([endTangent2.x, endTangent2.y]), points))+\"]\\n\\n\")\n//   //   }\n\n//   // }\n\n//   // for (var j = nodesVisible1.length - 1; j >= 0; j--) {\n//   //   for (var i = startTangents.length - 1; i >= 0; i--) {\n//   //     if(nodesVisible1[j].x == startTangents[i].x && nodesVisible1[j].y == startTangents[i].y ){\n//   //       nearestPoint = turf.nearestPoint(turf.point([startTangents[i].x, startTangents[i].y]), points)\n//   //       dynamicEdgesJSON += ',{\"fromId\":\"'+createNodeId2(startPoint)+'\",\"toId\":\"'+createNodeId(nearestPoint)+'\"}'\n//   //     }\n//   //   }\n//   //   // if(nodesVisible1[j].x == startTangent2.x && nodesVisible1[j].y == startTangent2.y ){\n//   //   //   nearestPoint = turf.nearestPoint(turf.point([startTangent2.x, startTangent2.y]), points)\n//   //   //   dynamicEdgesJSON += ',{\"fromId\":\"'+createNodeId2(startPoint)+'\",\"toId\":\"'+createNodeId(nearestPoint)+'\"}'\n//   //   // }\n//   // }\n\n//   // for (var j = nodesVisible2.length - 1; j >= 0; j--) {\n//   //   for (var i = endTangents.length - 1; i >= 0; i--) {\n//   //     if(nodesVisible2[j].x == endTangents[i].x && nodesVisible2[j].y == endTangents[i].y ){\n//   //       nearestPoint = turf.nearestPoint(turf.point([endTangents[i].x, endTangents[i].y]), points)\n//   //       dynamicEdgesJSON += ',{\"fromId\":\"'+createNodeId2(endPoint)+'\",\"toId\":\"'+createNodeId(nearestPoint)+'\"}'\n//   //     }\n//   //   }\n//   //   // if(nodesVisible2[j].x == endTangent1.x && nodesVisible2[j].y == endTangent1.y ){\n//   //   //   nearestPoint = turf.nearestPoint(turf.point([endTangent1.x, endTangent1.y]), points)\n//   //   //   dynamicEdgesJSON += ',{\"fromId\":\"'+createNodeId2(endPoint)+'\",\"toId\":\"'+createNodeId(nearestPoint)+'\"}'\n//   //   // }\n//   //   // if(nodesVisible2[j].x == endTangent2.x && nodesVisible2[j].y == endTangent2.y ){\n//   //   //   nearestPoint = turf.nearestPoint(turf.point([endTangent2.x, endTangent2.y]), points)\n//   //   //   dynamicEdgesJSON += ',{\"fromId\":\"'+createNodeId2(endPoint)+'\",\"toId\":\"'+createNodeId(nearestPoint)+'\"}'\n//   //   // }\n//   // }\n\n//   return dynamicEdgesJSON\n// }\n\n\nfunction getDynamicNodesJSON(startPoint, endPoint)\n{\n  var dynamicNodesJSON = \"\"\n  // var startPoint = new Point([startPoint.geometry.coordinates[0], startPoint.geometry.coordinates[1]]);\n  // var endPoint = new Point([endPoint.geometry.coordinates[0], endPoint.geometry.coordinates[1]]);\n\n  dynamicNodesJSON += '{\"id\":\"'+createNodeId2(startPoint)+'\",\"data\":{\"x\":'+startPoint.x+',\"y\":'+startPoint.y+'}},'\n  dynamicNodesJSON += '{\"id\":\"'+createNodeId2(endPoint)+'\",\"data\":{\"x\":'+endPoint.x+',\"y\":'+endPoint.y+'}},'\n\n  // points.push(startPoint)\n  // points.push(endPoint)\n\n  return dynamicNodesJSON\n}\n\n\n\n// Finds upper tangent of two polygons 'a' and 'b' \nfunction find4Tangents(a, b) \n// function find4Tangents(a, b, polygon1, polygon2) \n{ \n  // var aAsInt = []\n  // var bAsInt = []\n\n  // for (var i = 0; i < a.length; i++) {\n  //   aAsInt.push([Math.round(a[i].x * multiplier), Math.round(a[i].y * multiplier)])\n  // }\n  // aAsInt.push([Math.round(a[0].x * multiplier), Math.round(a[0].y * multiplier)]) // just to make sure last is equal to first\n\n  // for (var i = 0; i < b.length; i++) {\n  //   bAsInt.push([Math.round(b[i].x * multiplier), Math.round(b[i].y * multiplier)])\n  // }\n  // bAsInt.push([Math.round(b[0].x * multiplier), Math.round(b[0].y * multiplier)]) // just to make sure last is equal to first\n\n  // var polygon1 = turf.polygon([aAsInt]);\n  // var polygon2 = turf.polygon([bAsInt]);\n\n\n\n\n\n\n\n  var tangents1 = []\n  var tangents2 = []\n  tangents1.push([a[0].x, a[0].y])\n\n\n\n\n\n\n  var findTangentOfB = 1\n  var tangentPairs = []\n  var done1 = 0;\n  var done2 = 0;\n  var iterationsRemaining = 10\n\n  while( iterationsRemaining > 0){\n    var tangents = []\n    var srcTangets = findTangentOfB ? tangents1 : tangents2\n    var oldTangents = findTangentOfB ? tangents2.slice(0) : tangents1.slice(0)\n    var polygon = findTangentOfB ? b : a\n    var matches = 0\n    var oldTangentPairs = tangentPairs.slice(0)\n    tangentPairs = []\n\n    for (var i = 0; i < srcTangets.length; i++) {\n      var rawTangents = []\n      var point = new _Point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"](srcTangets[i]);\n      var rawTangents = getPolygonTangents(point, polygon)\n      // tangents = []\n\n      // for (var j = 0; j < features.length; j++)\n      //   rawTangents.push(features[j])\n\n      var srcPoint = new _Point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"](srcTangets[i])\n      var p1 = rawTangents[0]\n      var p2 = rawTangents[1]\n      var angle1 = srcPoint.angleToPoint(p1)\n      var angle2 = srcPoint.angleToPoint(p2)\n      var diff = angle1 - angle2\n      diff = diff < 0 ? diff + Math.PI*2 : diff\n\n      var rightTangent = rawTangents[1]\n      var leftTangent = rawTangents[0]\n\n      if(diff > Math.PI){\n        rightTangent = rawTangents[0]\n        leftTangent = rawTangents[1]\n      }\n\n\n      if(srcTangets.length <= 2){\n        tangents.push([leftTangent.x, leftTangent.y])\n        tangents.push([rightTangent.x, rightTangent.y])\n      }else{\n        if(typeof oldTangentPairs[i] == 'undefined')\n          continue;\n\n        var oldSource = new _Point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"]([oldTangentPairs[i][1][0], oldTangentPairs[i][1][1]])\n        var dist1 = Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"calcEdgeDistance\"])(p1, oldSource)\n        var dist2 = Object(_utils__WEBPACK_IMPORTED_MODULE_2__[\"calcEdgeDistance\"])(p2, oldSource)\n\n        // var angle = srcPoint.angleToPoint(oldSource)\n        // var diff1 = angle1 - angle\n        // var diff2 = angle2 - angle\n        // diff1 = diff1 < 0 ? diff1 + Math.PI*2 : diff1\n        // diff2 = diff2 < 0 ? diff2 + Math.PI*2 : diff2\n\n        tangents.push(dist1 < dist2 ? [rawTangents[0].x, rawTangents[0].y] : [rawTangents[1].x, rawTangents[1].y])\n        // if(i == 0)\n        //   tangents.push(findTangentOfB ? leftTangent : leftTangent)\n        // else if(i == 1)\n        //   tangents.push(findTangentOfB ? leftTangent : rightTangent)\n        // else if(i == 2)\n        //   tangents.push(findTangentOfB ? rightTangent : leftTangent)\n        // else if(i == 3)\n        //   tangents.push(findTangentOfB ? rightTangent : rightTangent)\n      }\n\n\n      // if(srcTangets.length <= 2){\n      //   tangents.push(leftTangent)\n      //   tangents.push(rightTangent)\n      // }else{\n      //   if(i == 0)\n      //     tangents.push(findTangentOfB ? leftTangent : leftTangent)\n      //   else if(i == 1)\n      //     tangents.push(findTangentOfB ? leftTangent : rightTangent)\n      //   else if(i == 2)\n      //     tangents.push(findTangentOfB ? rightTangent : leftTangent)\n      //   else if(i == 3)\n      //     tangents.push(findTangentOfB ? rightTangent : rightTangent)\n      // }\n\n\n        for (var m = 0; m < tangents.length; m++) {\n        // for (var k = oldTangents.length - 1; k >= 0; k--) {\n          var tangent = tangents[m]\n          if(srcTangets.length > 2)\n            tangent = tangents[i]\n          // if(tangent[0] == oldTangents[k][0] && tangent[1] == oldTangents[k][1]){\n            // if(matches < 4){\n              // check for duplicates\n              var isUnique = true\n              for (var l = tangentPairs.length - 1; l >= 0; l--) {\n                if(tangentPairs[l][0][0] == tangent[0] && tangentPairs[l][0][1] == tangent[1])\n                  isUnique = false\n              }\n\n              if(isUnique){\n                tangentPairs.push([tangent, srcTangets[i]])\n              }\n              matches++\n\n              if(srcTangets.length > 2)\n                break\n            // }\n          // }\n        // }\n        }\n    }\n\n    if(findTangentOfB){\n      done2 = matches == 4 ? true : false\n      tangents2 = tangents.slice(0)\n    }else{\n      done1 = matches == 4 ? true : false\n      tangents1 = tangents.slice(0)\n    }\n\n    // if(iterationsRemaining == 7)\n    //   break\n\n    // if(matches < 4)\n    //   iterationsRemaining = 10\n\n    findTangentOfB = !findTangentOfB\n    iterationsRemaining--\n  }\n\n  for (var i = 0; i < tangentPairs.length; i++) {\n    // var tp1 = turf.point([tangentPairs[i][0][0],tangentPairs[i][0][1]]);\n    // var tp2 = turf.point([tangentPairs[i][1][0],tangentPairs[i][1][1]]);\n    // var nearestStart = turf.nearestPoint(tp1, points)\n    // var nearestEnd = turf.nearestPoint(tp2, points)\n    let p1 = new _Point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"](tangentPairs[i][0])\n    let p2 = new _Point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"](tangentPairs[i][1])\n\n\n\n    allTangents.push(p1)\n    allTangents.push(p2)\n\n    if(Object(_src_main__WEBPACK_IMPORTED_MODULE_3__[\"isVisible\"])(p1,p2))\n      output += ',{\"fromId\":\"'+createNodeId2(p1)+'\",\"toId\":\"'+createNodeId2(p2)+'\"}'\n    // if(i==0)\n      // console.log(\"\\tvar start = [\"+createNodeId2(p1)+\"]\\n\\tvar end = [\"+createNodeId2(p2)+\"]\\n\\n\")\n    // else{\n    //   var isVisible = true\n    //   var angle = p1.angleToPoint(p2)\n\n    //   for (var j = turfPolygons.length - 1; j >= 0; j--) {\n    //     var tpm1 = turf.point([tangentPairs[i][0][0] * multiplier,tangentPairs[i][0][1] * multiplier]);\n    //     var tpm2 = turf.point([tangentPairs[i][1][0] * multiplier,tangentPairs[i][1][1] * multiplier]);\n    //     if(turf.booleanPointInPolygon(tpm2, turfPolygons[i]))\n    //       continue\n\n    //     var features = turf.polygonTangents(tpm1, turfPolygons[j]).features\n    //     var t1 = new Point([features[0].geometry.coordinates[0]/multiplier, features[0].geometry.coordinates[1]/multiplier])\n    //     var t2 = new Point([features[1].geometry.coordinates[0]/multiplier, features[1].geometry.coordinates[1]/multiplier])\n    //     var angle1 = p1.angleToPoint(t1)\n    //     var angle2 = p1.angleToPoint(t2)\n    //     var diff = angle1 - angle2\n    //     diff = diff < 0 ? diff + Math.PI : diff\n\n    //     // ensure angle2 is the left one\n    //     if(diff > Math.PI/2){\n    //       var temp = angle1\n    //       angle1 = angle2\n    //       angle2 = temp\n    //     }\n\n    //     var diff1 = angle1 - angle\n    //     diff1 = diff1 < 0 ? diff1 + Math.PI : diff1\n\n    //     var diff2 = angle - angle2\n    //     diff2 = diff2 < 0 ? diff2 + Math.PI : diff2\n\n    //     // angle is between angle1 and angle2\n    //     if(diff1 < Math.PI/2 && diff2 < Math.PI/2){\n    //       const dist = calcEdgeDistance(p1, p2)\n    //       const dist1 = calcEdgeDistance(p1, t1)\n    //       const dist2 = calcEdgeDistance(p1, t2)\n\n    //       // if both tangents are closer\n    //       if(dist1<dist && dist2<dist){\n    //         isVisible = false\n    //         break;\n    //       }\n    //     }\n    //   }\n\n    //   if(isVisible)\n        // output += ',{\"fromId\":\"'+createNodeId(nearestStart)+'\",\"toId\":\"'+createNodeId(nearestEnd)+'\"}'\n    // }\n  }\n\n\n\n\n  // var m1 = L.marker([tangentPairs[0][0][0],tangentPairs[0][0][1], {\n  //   draggable: true,\n  //   icon: new L.NumberedDivIcon()\n  // })\n\n  // var m2 = L.marker(tangentPairs[0][1][0],tangentPairs[0][1][1], {\n  //   draggable: true,\n  //   icon: new L.NumberedDivIcon()\n  // })\n\n\n\n\n  // routeLayer.setLatLngs([])\n  // var nearestStart = turf.nearestPoint(t1, points)\n  // var nearestEnd = turf.nearestPoint(t2, points)\n  // foundPath = pathFinder.find(createNodeId(nearestStart), createNodeId(nearestEnd))\n  // drawPath()\n\n\n\n\n\n\n\n  // var tangents2 = [[features[0].geometry.coordinates[0]/multiplier, features[0].geometry.coordinates[1]/multiplier], \n  //                   [features[1].geometry.coordinates[0]/multiplier, features[1].geometry.coordinates[1]/multiplier]]\n\n\n\n\n\n  // var point = turf.point([Math.round(tangents2[0][0] * multiplier), Math.round(tangents2[0][1] * multiplier)]);\n  // var features = turf.polygonTangents(point, polygon1)\n  // var tangents1 = [[features[0].geometry.coordinates[0]/multiplier, features[0].geometry.coordinates[1]/multiplier], \n  //                   [features[1].geometry.coordinates[0]/multiplier, features[1].geometry.coordinates[1]/multiplier]]\n\n\n\n\n\n\n\n  // startMarker = L.marker([ a[0].x, a[0].y], {\n  //   draggable: true,\n  //   icon: new L.NumberedDivIcon()\n  // }).addTo(map)\n\n  // var tangent = [ tangents.features[0].geometry.coordinates[0]/multiplier, tangents.features[0].geometry.coordinates[1]/multiplier]\n\n  // endMarker = L.marker(tangent, {\n  //   draggable: true,\n  //   icon: new L.NumberedDivIcon()\n  // }).addTo(map)\n\n  // var nearestStart = turf.nearestPoint(startMarker.toGeoJSON(), points)\n  // var nearestEnd = turf.nearestPoint(endMarker.toGeoJSON(), points)\n  // foundPath = pathFinder.find(createNodeId(nearestStart), createNodeId(nearestEnd))\n  // drawPath()\n\n\n  // console.log(a[0].x + \",\" + a[0].y + \" \" + tangent[0] + \",\" + tangent[1])\n  // console.log('')\n\n\n\n\n\n\n\n\n\n\n    // // n1 -> number of points in polygon a \n    // // n2 -> number of points in polygon b \n    // var n1 = a.length, n2 = b.length; \n  \n    // // To find a point inside the convex polygon(centroid), \n    // // we sum up all the coordinates and then divide  by \n    // // n(number of points). But this would be a floating-point \n    // // value. So to get rid of this we multiply points \n    // // initially with n1 and then find the centre and \n    // // then divided it by n1 again. \n    // // Similarly we do divide and multiply for n2 (i.e., \n    // // elements of b) \n  \n    // // maxa and minb are used to check if polygon a \n    // // is left of b. \n    // var maxa = Number.MIN_SAFE_INTEGER; \n    // for (var i=0; i<n1; i++) \n    // { \n    //     maxa = Math.max(maxa, a[i].x); \n    //     mid.x  += a[i].x;\n    //     mid.y += a[i].y; \n    //     a[i].x *= n1; \n    //     a[i].y *= n1; \n    // } \n  \n    // // sorting the points in counter clockwise order \n    // // for polygon a \n    // const clonedA = clonePoints(a)\n    // sortPoints(a[0], clonedA)\n    // a = clonedA\n  \n    // for (var i=0; i<n1; i++) \n    // { \n    //     a[i].x /= n1; \n    //     a[i].y /= n1; \n    // } \n  \n    // mid = new Point([0,0])\n  \n    // var minb = Number.MAX_SAFE_INTEGER; \n    // for (var i=0; i<n2; i++) \n    // { \n    //     mid.x += b[i].x; \n    //     mid.y += b[i].y; \n    //     minb = Math.min(minb, b[i].x); \n    //     b[i].x *= n2; \n    //     b[i].y *= n2; \n    // } \n  \n    // // sorting the points in counter clockwise \n    // // order for polygon b \n    // const clonedB = clonePoints(b)\n    // sortPoints(b[0], clonedB)\n    // b = clonedB\n  \n    // for (var i=0; i<n2; i++) \n    // { \n    //     b[i].x/=n2; \n    //     b[i].y/=n2; \n    // } \n  \n    // // If a is to the right of b, swap a and b \n    // // This makes sure a is left of b. \n    // if (minb < maxa) \n    // { \n    //     b = [a, a = b][0];  // swap a and b    \n    //     n1 = a.length;\n    //     n2 = b.length;\n    // } \n  \n    // // ia -> rightmost point of a \n    // var ia = 0, ib = 0; \n    // for (var i=1; i<n1; i++) \n    //     if (a[i].x > a[ia].x) \n    //         ia = i; \n  \n    // // ib -> leftmost point of b \n    // for (var i=1; i<n2; i++) \n    //     if (b[i].x < b[ib].x) \n    //         ib=i; \n  \n    // // finding the upper tangent \n    // var inda = ia, indb = ib; \n    // var done = 0; \n    // while (!done) \n    // { \n    //     done = 1; \n    //     // const g = createGraph()\n    //     // g.addNode(createNodeId2(b[indb]), { x: b[indb].x, y: b[indb].y })\n    //     // g.addNode(createNodeId2(a[inda]), { x: a[inda].x, y: a[inda].y })\n    //     // g.addNode(createNodeId2(a[(inda+1)%n1]), { x: a[(inda+1)%n1].x, y: a[(inda+1)%n1].y })\n    //     // g.addLink(createNodeId2(b[indb]), createNodeId2(a[inda]))\n    //     // g.addLink(createNodeId2(a[inda]), createNodeId2(a[(inda+1)%n1]))\n    //     // setGraph(g)\n    //     // routeLayer.setLatLngs([b[indb], a[inda]])\n    //     // drawPath()\n\n    //     // routeLayer.setLatLngs([])\n\n\n    //     while (orientation(b[indb], a[inda], a[(inda+1)%n1]) > 0) \n    //         inda = (inda + 1) % n1; \n  \n    //     while (orientation(a[inda], b[indb], b[(n2+indb-1)%n2]) < 0) \n    //     { \n    //         indb = (n2+indb-1)%n2; \n    //         done = 0; \n    //     } \n    // } \n    // console.log(a[inda].x + \",\" + a[inda].y)\n  \n    // // cout << \"upper tangent (\" << a[inda].x << \",\"\n    // //     << a[inda].y << \") (\" << b[indb].x \n    // //     << \",\" << b[indb].y << \")\\n\"; \n} \n\n  function createNodeId2 (p) {\n    return p.x + ',' + p.y\n  }\n\nfunction clearGraphRelatedData () {\n  if (routeLayer !== null) routeLayer.setLatLngs([])\n  if (selectionLayer !== null) selectionLayer.clearLayers()\n}\n\nfunction setupRouteLayer () {\n  routeLayer = L.polyline([], {\n    color: '#EB3223'\n  }).addTo(map)\n}\n\nfunction setPathFinder (pathGraph) {\n  pathFinder = pathGraph\n  return updatePathMarkers()\n}\n\nfunction updatePathMarkers () {\n  if(updatingPathMarkers){\n    updatingPathMarkers = 0\n    return\n  }\n\n  updatingPathMarkers = true\n  // const startCreation = window.performance.now()\n\n  if(routeLayer != null)\n    routeLayer.setLatLngs([])\n  Object(_src_main__WEBPACK_IMPORTED_MODULE_3__[\"restoreOriginalPointsAndEdges\"])()\n\n  if(routeLayer != null){\n    startPoint = new _Point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"]([startMarker.toGeoJSON().geometry.coordinates[0], startMarker.toGeoJSON().geometry.coordinates[1]]);\n    endPoint = new _Point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"]([endMarker.toGeoJSON().geometry.coordinates[0], endMarker.toGeoJSON().geometry.coordinates[1]]);\n  }\n\n  var dynamicNodesJSON = getDynamicNodesJSON(startPoint, endPoint)\n  var dynamicEdgesJSON = getDynamicEdgesJSON(startPoint, endPoint)\n  Object(_graphHelper__WEBPACK_IMPORTED_MODULE_5__[\"updateGraphWithDynamicJSON\"])(dynamicNodesJSON, dynamicEdgesJSON)\n\n  if(routeLayer != null){\n    var nearestStart = turf.nearestPoint(startMarker.toGeoJSON(), points)\n    var nearestEnd = turf.nearestPoint(endMarker.toGeoJSON(), points)\n    nearestStart = startMarker.toGeoJSON()\n    nearestEnd = endMarker.toGeoJSON()\n    foundPath = pathFinder.find(createNodeId(nearestStart), createNodeId(nearestEnd))\n    drawPath()\n  }else{\n    foundPath = pathFinder.find(createNodeId2(startPoint), createNodeId2(endPoint))\n  }\n  console.log(\"\\tvar start = [\"+createNodeId2(startPoint)+\"]\\n\\tvar end = [\"+createNodeId2(endPoint)+\"]\\n\\n\")\n\n  // const endCreation = window.performance.now()\n  // const timeTakenToCreate = parseInt(endCreation - startCreation)\n  // console.log('Time to find path: ', timeTakenToCreate)\n\n  updatingPathMarkers = false\n\n  return foundPath\n}\n\nfunction drawPath () {\n  const pathLatLngs = foundPath.map(function (node) {\n    return [node.data.y, node.data.x]\n  })\n  routeLayer.setLatLngs(pathLatLngs)\n}\n\nfunction createNodeId (p) {\n  return p.geometry.coordinates[0] + ',' + p.geometry.coordinates[1]\n}\n\nfunction unhighlightFeature () {\n  selectionLayer.clearLayers()\n}\n\nfunction setGraph (gd) {\n  graphData = gd\n}\n\nfunction highlightFeature (e) {\n  selectionLayer.clearLayers()\n\n  const node = graphData.getNode(e.target._latlng.lng + ',' + e.target._latlng.lat)\n\n  graphData.forEachLinkedNode(e.target._latlng.lng + ',' + e.target._latlng.lat, function (linkedNode, link) {\n    L.polyline([[linkedNode.data.y, linkedNode.data.x], [node.data.y, node.data.x]], {\n      weight: 0.5,\n      opacity: 0.8,\n      pane: 'shadowPane',\n      interactive: false\n    }).addTo(selectionLayer)\n  })\n}\n\nfunction createNumberDiv () {\n  return L.Icon.extend({\n    options: {\n      iconSize: new L.Point(15, 15),\n      className: 'leaflet-div-icon'\n    },\n    createIcon: function () {\n      var div = document.createElement('div')\n      var numdiv = document.createElement('div')\n      numdiv.setAttribute('class', 'number')\n      numdiv.innerHTML = this.options['number'] || ''\n      div.appendChild(numdiv)\n      this._setIconStyles(div, 'icon')\n      return div\n    }\n  })\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFwSGVscGVycy5qcz9mYzY1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDK0I7QUFDa0I7QUFDNkI7QUFDdUU7QUFDdkc7QUFDWTs7O0FBRzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7QUFHQSxtQkFBbUIsNENBQUs7QUFDeEIsaUJBQWlCLDRDQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyQnRCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsS0FBSztBQUNMOzs7Ozs7Ozs7QUFTQSxFQUFFLDREQUFVOztBQUVaLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLElBQUksc0VBQWM7QUFDbEI7QUFDQTs7QUFFQSx1REFBdUQsUUFBUTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7OztBQVNBOztBQUVBOzs7Ozs7QUFNQTs7QUFFQSx1Q0FBdUMsUUFBUTtBQUMvQyw0QkFBNEIsUUFBUTtBQUNwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQkFBMEIsUUFBUTtBQUNsQyx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsOEVBQThFO0FBQ3hHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7O0FBRUE7O0FBRUEsNENBQTRDLFFBQVE7QUFDcEQsNEJBQTRCLFFBQVE7QUFDcEM7O0FBRUE7QUFDQSwwQkFBMEIsa0VBQWtFO0FBQzVGOztBQUVBO0FBQ0EsNkJBQTZCLGtFQUFrRTtBQUMvRjtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTs7QUFFQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxDO0FBQ0E7QUFDQSxpQjtBQUNBO0FBQ0EsaUI7QUFDQTtBQUNBLGlCO0FBQ0EsYTtBQUNBLEM7O0FBRUE7QUFDQTtBQUNBLEM7QUFDQTtBQUNBLGtDOztBQUVBO0FBQ0EsaUI7QUFDQTtBQUNBLGlCO0FBQ0EsYztBQUNBLEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsNENBQUs7QUFDckIsOEM7QUFDQSxnQkFBZ0IsNENBQUs7QUFDckIsOEM7O0FBRUEsc0I7QUFDQSxzQjs7QUFFQTtBQUNBLG9DO0FBQ0Esd0M7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSwyRUFBeUI7OztBQUczQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0Msb0VBQWtCOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLDRHQUE0RztBQUMzSTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxRQUFRO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDRHQUE0RztBQUNoSixVQUFVO0FBQ1Y7QUFDQTtBQUNBLG9DQUFvQyw0R0FBNEc7QUFDaEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLHlCQUF5QjtBQUNoRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw4Q0FBOEMsUUFBUTtBQUN0RCxnREFBZ0QsUUFBUTtBQUN4RDtBQUNBO0FBQ0EscUNBQXFDLGlGQUFpRjtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxpRkFBaUY7QUFDdkg7QUFDQTs7QUFFQSw4Q0FBOEMsUUFBUTtBQUN0RCw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0EscUNBQXFDLCtFQUErRTtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywrRUFBK0U7QUFDckg7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLCtFQUErRTtBQUNySDtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLDZDQUE2QywyQ0FBMkM7QUFDaEgsd0JBQXdCLDJDQUEyQyx1Q0FBdUM7O0FBRTFHO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBLEM7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBLHNCQUFzQiw0Q0FBSztBQUMzQjtBQUNBOztBQUVBLHdCQUF3QixxQkFBcUI7QUFDN0M7O0FBRUEseUJBQXlCLDRDQUFLO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw0QkFBNEIsNENBQUs7QUFDakMsb0JBQW9CLCtEQUFnQjtBQUNwQyxvQkFBb0IsK0RBQWdCOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSx1QkFBdUIscUJBQXFCO0FBQzVDLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDRDQUFLO0FBQ3RCLGlCQUFpQiw0Q0FBSzs7OztBQUl0QjtBQUNBOztBQUVBLE9BQU8sMkRBQVM7QUFDaEIsbUJBQW1CLGdFQUFnRTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixnRkFBZ0Y7QUFDeEc7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLE1BQU07Ozs7O0FBS047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBLHdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUIsUTtBQUNBLHlDO0FBQ0E7QUFDQSwyQjtBQUNBLHdCO0FBQ0Esd0I7QUFDQSxROztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLE1BQU07QUFDMUIsUTtBQUNBLHdCO0FBQ0Esd0I7QUFDQSxROztBQUVBOztBQUVBLDBDO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUIsUTtBQUNBLDJCO0FBQ0EsMkI7QUFDQSx5QztBQUNBLHdCO0FBQ0Esd0I7QUFDQSxROztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLE1BQU07QUFDMUIsUTtBQUNBLHNCO0FBQ0Esc0I7QUFDQSxROztBQUVBO0FBQ0E7QUFDQTtBQUNBLFE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLFE7O0FBRUE7QUFDQSwwQjtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0Esc0I7O0FBRUE7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBLG9COztBQUVBO0FBQ0EsZ0M7QUFDQSxvQjtBQUNBO0FBQ0EsUTtBQUNBLG9CO0FBQ0E7QUFDQSxpREFBaUQsNkJBQTZCO0FBQzlFLGlEQUFpRCw2QkFBNkI7QUFDOUUsd0RBQXdELDJDQUEyQztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBLHNDOztBQUVBO0FBQ0EsWTtBQUNBLHFDO0FBQ0Esd0I7QUFDQSxZO0FBQ0EsUTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQztBQUNBLEM7O0FBRUE7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUUsK0VBQTZCOztBQUUvQjtBQUNBLHFCQUFxQiw0Q0FBSztBQUMxQixtQkFBbUIsNENBQUs7QUFDeEI7O0FBRUE7QUFDQTtBQUNBLEVBQUUsK0VBQTBCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIIiwiZmlsZSI6Ii4vc3JjL21hcEhlbHBlcnMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBpbXBvcnQgY3JlYXRlR3JhcGggZnJvbSAnLi9uZ3JhcGguZ3JhcGgnXG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4vUG9pbnQnXG5pbXBvcnQgeyBzZXR1cFN0cnVjdHVyZSB9IGZyb20gJy4vc2V0dXBTdHJ1Y3R1cmUnXG5pbXBvcnQgeyBJTkYsIGVkZ2VJbnRlcnNlY3QsIG9uU2VnbWVudCwgY2N3LCBjYWxjRWRnZURpc3RhbmNlIH0gZnJvbSAnLi91dGlscydcbmltcG9ydCB7IGlzVmlzaWJsZSwgZ2V0VmlzaWJsZU5vZGVzLCBsb2FkUG9pbnRzLCByZXN0b3JlT3JpZ2luYWxQb2ludHNBbmRFZGdlcywgZ2V0T2JzdHJ1Y3RpbmdFZGdlLCBhZGRTdGFydGluZ0FuZEVuZGluZ05vZGVzIH0gZnJvbSAnLi4vLi4vc3JjL21haW4nXG5pbXBvcnQgeyBtYWtlQ29udmV4aHVsbCB9IGZyb20gJy4vY29udmV4LWh1bGwnXG5pbXBvcnQgeyB1cGRhdGVHcmFwaFdpdGhEeW5hbWljSlNPTiB9IGZyb20gJy4vZ3JhcGhIZWxwZXInXG5cblxubGV0IG1hcCA9IG51bGxcbmxldCBzdGFydE1hcmtlciA9IG51bGxcbmxldCBlbmRNYXJrZXIgPSBudWxsXG5sZXQgc2VsZWN0aW9uTGF5ZXIgPSBudWxsXG5sZXQgcG9seUxheWVyID0gbnVsbFxubGV0IHBvaW50cyA9IG51bGxcbmxldCBwb2ludHNMeXIgPSBudWxsXG5sZXQgZ3JhcGhEYXRhID0gbnVsbFxubGV0IGZvdW5kUGF0aCA9IG51bGxcbmxldCBwYXRoRmluZGVyID0gbnVsbFxubGV0IHJvdXRlTGF5ZXIgPSBudWxsXG5sZXQgcG9pbnRzMSA9IFtdXG5sZXQgcG9pbnRzMiA9IFtdXG5sZXQgcG9pbnRzQXJyID0gW11cbmxldCB0dXJmUG9seWdvbnMgPSBbXVxudmFyIG91dHB1dCA9IFwiXCJcbnZhciBtdWx0aXBsaWVyID0gMTAwMCAqIDEwMDAgKiAxMDAwICogMTAwMCAqIDEwMDAgKiAxMDAwICogMTAwMCAqIDEwMDBcbnZhciB1cGRhdGluZ1BhdGhNYXJrZXJzID0gZmFsc2VcbnZhciBhbGxUYW5nZW50cyA9IFtdXG52YXIgc3RhcnRQb2ludCA9IG51bGxcbnZhciBlbmRQb2ludCA9IG51bGxcblxuXG5leHBvcnQgZnVuY3Rpb24gc2V0dXBNYXAgKHN0YXJ0LCBlbmQsIHNob3dNYXApIHtcbiAgaWYoc2hvd01hcCl7XG4gICAgbWFwID0gTC5tYXAoJ21hcCcsIHtcbiAgICAgIG1pblpvb206IDEsXG4gICAgICBtYXhab29tOiAyMCxcbiAgICAgIGNlbnRlcjogWzAsIDBdLFxuICAgICAgem9vbTogMixcbiAgICAgIGNyczogTC5DUlMuU2ltcGxlXG4gICAgfSlcblxuICAgIEwuTnVtYmVyZWREaXZJY29uID0gY3JlYXRlTnVtYmVyRGl2KClcbiAgfVxuXG4gIGlmKHN0YXJ0ID09IG51bGwpe1xuICAgIC8vIHZhciBzdGFydCA9IFs3My4xOTM3NDk5OTQwMzk1NCwwLjY1NDg4MjgwNzI4NDU5MzZdXG4gICAgLy8gdmFyIGVuZCA9IFs3My4xOTg0NDk2MTE2NjQsMC42OTE5NTAxODk4MDc1ODVdXG5cbiAgICAvLyB2YXIgc3RhcnQgPSBbNzMuMjAzMTM3MjA1OTEzNjYsMC42Njg4ODQyNzczNDM3NV1cbiAgICAvLyB2YXIgZW5kID0gWzczLjIyNjg5MjA5MTMzMzg3LDAuNjc4MDUxNzU0ODMyMjY3OF1cblxuICAgIC8vIHZhciBzdGFydCA9IFs3My4yMDA3ODEyNDEwNTkzLDAuNjY1NDc4NTIzODIwNjM4N11cbiAgICAvLyB2YXIgZW5kID0gWzczLjIwMTA3NDIyNzY5MDcsMC43MDAzOTA2MjU3NDUwNTgxXVxuXG4gICAgLy8gdmFyIHN0YXJ0ID0gWzczLjE0NjU3NjQyNzM4LDAuNjYzOTkwMzYzNTQyNjM3OV1cbiAgICAvLyB2YXIgZW5kID0gWzczLjIwMTA3NDIyNzY5MDcsMC43MDAzOTA2MjU3NDUwNTgxXVxuXG5cbiAgICB2YXIgc3RhcnQgPSBbNzMuMTk3MDcwMzAwNTc5MDcsMC42Njc3NzM0NDA0ODAyMzIyXVxuICAgIHZhciBlbmQgPSBbNzMuMTc5MDE2MTEzMjgxMjUsMC42ODM0MTA2NDQ5OTY5MTEzXVxuXG5cblxuXG5cbiAgICB2YXIgc3RhcnQgPSBbNzMuMTg2Mjg4NDc1OTksMC42NjA1NDkwNzQzNTgxNDQxXVxuICAgIHZhciBlbmQgPSBbNzMuMTY5MDAyNTkwMjI0LDAuNjY4OTMxMTcwMTYzMDQ4N11cblxuXG5cblxuICAgIHZhciBzdGFydCA9IFs3My4yMzQzNzUsMC4xNDQ1MzExOTAzOTUzNTUyMl1cbiAgICB2YXIgZW5kID0gWzczLjE2OTAwMjU5MDIyNCwwLjY2ODkzMTE3MDE2MzA0ODddXG4gIH1cblxuXG4gIHN0YXJ0UG9pbnQgPSBuZXcgUG9pbnQoc3RhcnQpO1xuICBlbmRQb2ludCA9IG5ldyBQb2ludChlbmQpO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbiAgLy8gdmFyIHN0YXJ0ID0gWzczLjE5NjU1MDYwNzY4MSwwLjY3NDUzODUyNzAxMzE2OTJdXG4gIC8vIHZhciBlbmQgPSBbNzMuMTk1NjE3MTk4OTQ0LDAuNjc0NzQyMzYwNzY3MzgyNF1cblxuICAvLyB2YXIgc3RhcnQgPSBbNzMuMTg0NjE5MTQzNjA1MjMsMC42ODgwODU5MzIyODQ1OTM2XVxuICAvLyB2YXIgZW5kID0gWzczLjE5ODQ0OTYxMTY2NCwwLjY5MTk1MDE4OTgwNzU4NV1cblxuICBpZihzaG93TWFwKXtcbiAgICBzdGFydE1hcmtlciA9IEwubWFya2VyKFtzdGFydFsxXSxzdGFydFswXV0sIHtcbiAgICAgIGRyYWdnYWJsZTogdHJ1ZSxcbiAgICAgIGljb246IG5ldyBMLk51bWJlcmVkRGl2SWNvbigpXG4gICAgfSkuYWRkVG8obWFwKVxuXG4gICAgZW5kTWFya2VyID0gTC5tYXJrZXIoW2VuZFsxXSxlbmRbMF1dLCB7XG4gICAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgICBpY29uOiBuZXcgTC5OdW1iZXJlZERpdkljb24oKVxuICAgIH0pLmFkZFRvKG1hcClcblxuICAgIHN0YXJ0TWFya2VyLm9uKCdkcmFnJywgdXBkYXRlUGF0aE1hcmtlcnMpXG4gICAgZW5kTWFya2VyLm9uKCdkcmFnJywgdXBkYXRlUGF0aE1hcmtlcnMpXG4gICAgc2VsZWN0aW9uTGF5ZXIgPSBMLmxheWVyR3JvdXAoW10pLmFkZFRvKG1hcClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0RGF0YSAoZGF0YSwgc2hvd01hcCkge1xuICBpZihzaG93TWFwKXtcbiAgICBwb2x5TGF5ZXIgPSBMLmdlb0pzb24oZGF0YSwge1xuICAgICAgbm9DbGlwOiB0cnVlLFxuICAgICAgc3Ryb2tlOiBmYWxzZSxcbiAgICAgIGZpbGxDb2xvcjogJyM4Qjk5QUUnXG4gICAgfSkuYWRkVG8obWFwKVxuXG4gICAgbWFwLmZpdEJvdW5kcyhwb2x5TGF5ZXIuZ2V0Qm91bmRzKCksIHtcbiAgICAgIHBhZGRpbmc6IFsyMCwgMjBdXG4gICAgfSlcblxuICAgIHBvaW50cyA9IHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW10pXG5cbiAgICBwb2ludHNMeXIgPSBMLmxheWVyR3JvdXAoW10sIHtcbiAgICAgIHBhbmU6ICdwb3B1cFBhbmUnXG4gICAgfSkuYWRkVG8obWFwKVxuXG4gICAgdHVyZi5tZXRhLmNvb3JkRWFjaChkYXRhLCBmdW5jdGlvbiAoY3VycmVudENvb3JkKSB7XG4gICAgICBwb2ludHMuZmVhdHVyZXMucHVzaCh0dXJmLnBvaW50KFtjdXJyZW50Q29vcmRbMF0sIGN1cnJlbnRDb29yZFsxXV0pKVxuXG4gICAgICB2YXIgbGF5ZXIgPSBMLmNpcmNsZU1hcmtlcihbY3VycmVudENvb3JkWzFdLCBjdXJyZW50Q29vcmRbMF1dLCB7XG4gICAgICAgIHJhZGl1czogMyxcbiAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgZmlsbE9wYWNpdHk6IDAuNSxcbiAgICAgICAgb3JpZ1BvaW50OiBbY3VycmVudENvb3JkWzBdLCBjdXJyZW50Q29vcmRbMV1dXG4gICAgICB9KS5hZGRUbyhwb2ludHNMeXIpXG4gICAgICBsYXllci5vbignbW91c2VvdmVyJywgaGlnaGxpZ2h0RmVhdHVyZSlcbiAgICAgIGxheWVyLm9uKCdtb3VzZW91dCcsIHVuaGlnaGxpZ2h0RmVhdHVyZSlcblxuICAgIH0sIHRydWUpXG4gIH1cblxuXG5cblxuXG5cblxuXG4gIGxvYWRQb2ludHMoZGF0YSlcblxuICBmb3IgKHZhciBpID0gZGF0YS5mZWF0dXJlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IGVkZ2VzID0gW11cbiAgICBjb25zdCBwb2x5Z29ucyA9IFtdXG4gICAgcG9pbnRzMSA9IFtdXG4gICAgc2V0dXBTdHJ1Y3R1cmUoZGF0YS5mZWF0dXJlc1tpXSwgZWRnZXMsIHBvaW50czEsIHBvbHlnb25zLCBpKVxuICAgIHBvaW50c0Fyci5wdXNoKHBvaW50czEuc2xpY2UoMCkpXG4gIH1cblxuICAvLyBmb3IgKHZhciBpID0gZGF0YS5nZW9tZXRyeS5jb29yZGluYXRlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAvLyAgIGNvbnN0IGVkZ2VzID0gW11cbiAgLy8gICBjb25zdCBwb2x5Z29ucyA9IFtdXG4gIC8vICAgcG9pbnRzMSA9IFtdXG4gIC8vICAgc2V0dXBTdHJ1Y3R1cmUoZGF0YS5nZW9tZXRyeS5jb29yZGluYXRlc1tpXSwgZWRnZXMsIHBvaW50czEsIHBvbHlnb25zLCBpKVxuICAvLyAgIHBvaW50c0Fyci5wdXNoKHBvaW50czEuc2xpY2UoMCkpXG4gIC8vIH1cblxuICAvLyBsb2FkVHVyZlBvbHlnb25zKGRhdGEpXG5cblxuXG5cblxuXG5cblxuICAvLyB2YXIgdGFuZ2VudHMgPSBnZXRQb2x5Z29uVGFuZ2VudHMobmV3IFBvaW50KFs3My4xNDY1NzY0MjczOCwwLjY2Mzk5MDM2MzU0MjYzNzldKSwgcG9pbnRzQXJyWzExXSlcblxuICAvLyBjb25zb2xlLmxvZyhcIlxcdHZhciBzdGFydCA9IFtcIitjcmVhdGVOb2RlSWQyKG5ldyBQb2ludChbNzMuMTQ2NTc2NDI3MzgsMC42NjM5OTAzNjM1NDI2Mzc5XSkpK1wiXVxcblxcdHZhciBlbmQgPSBbXCIrY3JlYXRlTm9kZUlkMih0YW5nZW50c1sxXSkrXCJdXFxuXFxuXCIpXG5cblxuXG5cblxuICAgIGNvbnNvbGUubG9nKCdzdGFydGluZycpXG5cbiAgLy8gZm9yICh2YXIgaSA9IHBvaW50c0Fyci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAvLyAvLyBmb3IgKHZhciBpID0gMTkgLSAxOyBpID49IDA7IGktLSkge1xuICAvLyAgIC8vIHZhciBpID0gNDtcbiAgLy8gICAvLyB2YXIgaiA9IDExO1xuXG4gIC8vICAgLy8gdmFyIGkgPSA0O1xuICAvLyAgIC8vIHZhciBqID0gOTtcblxuICAvLyAgIC8vIHZhciBpID0gMTE7XG4gIC8vICAgLy8gdmFyIGogPSAwO1xuXG4gIC8vICAgZm9yICh2YXIgaiA9IGkgLSAxOyBqID49IDA7IGotLSkge1xuICAvLyAgIC8vIGZvciAodmFyIGogPSA1OyBqID49IDI7IGotLSkge1xuICAvLyAgIC8vICAgaWYoaSA9PSBqKSBjb250aW51ZVxuICAvLyAgICAgLy8gY29uc29sZS5sb2coJ3Rlc3QnKVxuICAvLyAgIC8vIGNvbnNvbGUubG9nKCdpOiAnICsgaSArICcgajogJyArIGopXG4gIC8vICAgICAvLyBmaW5kNFRhbmdlbnRzKHBvaW50c0FycltpXSwgcG9pbnRzQXJyW2pdLCB0dXJmUG9seWdvbnNbaV0sIHR1cmZQb2x5Z29uc1tqXSlcbiAgLy8gICAgIGZpbmQ0VGFuZ2VudHMocG9pbnRzQXJyW2ldLCBwb2ludHNBcnJbal0pXG5cbiAgLy8gICB9XG5cblxuICAvLyAgIC8vIGZpbmQgc2hvcnRjdXRzIHRvIHNraXAgY29uY2F2ZSBwYXJ0cyBvZiBwb2x5Z29uc1xuICAvLyAgIHZhciBwQXJyID0gcG9pbnRzQXJyW2ldXG4gIC8vICAgdmFyIGh1bGwgPSBtYWtlQ29udmV4aHVsbChwQXJyKTtcbiAgLy8gICBjb25zb2xlLmxvZygndGVzdCcpXG4gIC8vICAgdmFyIGwgPSAwXG4gIC8vICAgZm9yICh2YXIgayA9IDA7IGsgPCBodWxsLmxlbmd0aDsgaysrKSB7XG4gIC8vICAgICB2YXIgbmV4dFBvaW50ID0gaHVsbFsgKGsrMSkgJSBodWxsLmxlbmd0aCBdXG5cbiAgLy8gICAgIC8vIGZpbmQgdGhlIHBvaW50IHRoYXQgbWF0Y2hlcyB0aGUgcG9pbnQgaW4gdGhlIGh1bGxcbiAgLy8gICAgIHdoaWxlKCAhcEFycltsXS5pc1BvaW50RXF1YWwoaHVsbFtrXSkpe1xuICAvLyAgICAgICBsID0gKGwrMSkgJSBwQXJyLmxlbmd0aFxuICAvLyAgICAgfVxuICAgICAgXG4gIC8vICAgICAvLyBpZiB0aGUgbmV4dCBwb2ludCBpcyBkaWZmZXJlbnQgd2UgbmVlZCB0aGUgbGluZSBiZXR3ZWVuXG4gIC8vICAgICBpZiggIXBBcnJbbF0ubmV4dFBvaW50LmlzUG9pbnRFcXVhbChuZXh0UG9pbnQpKXtcbiAgLy8gICAgICAgLy8gaWYoaXNWaXNpYmxlKGh1bGxba10sbmV4dFBvaW50KSlcbiAgLy8gICAgICAgICBvdXRwdXQgKz0gJyx7XCJmcm9tSWRcIjpcIicrIGNyZWF0ZU5vZGVJZDIoaHVsbFtrXSkgKydcIixcInRvSWRcIjpcIicrY3JlYXRlTm9kZUlkMihuZXh0UG9pbnQpKydcIn0nXG4gIC8vICAgICB9XG4gIC8vICAgfVxuICAvLyB9XG5cbiAgLy8gY29uc29sZS5sb2coYWxsVGFuZ2VudHMubGVuZ3RoKVxuICAvLyBmb3IgKHZhciBpID0gYWxsVGFuZ2VudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgLy8gICBjb25zb2xlLmxvZygndGVzdCcpXG4gIC8vICAgdmFyIHAxID0gYWxsVGFuZ2VudHNbaV1cblxuICAvLyAgIHZhciBub2Rlc1Zpc2libGUgPSBnZXRWaXNpYmxlTm9kZXMocDEpXG5cbiAgLy8gICBmb3IgKHZhciBrID0gbm9kZXNWaXNpYmxlLmxlbmd0aCAtIDE7IGsgPj0gMDsgay0tKSB7XG4gIC8vICAgICBmb3IgKHZhciBqID0gaSAtIDE7IGogPj0gMDsgai0tKSB7XG4gIC8vICAgICAgIHZhciBwMiA9IGFsbFRhbmdlbnRzW2pdXG5cbiAgLy8gICAgICAgaWYobm9kZXNWaXNpYmxlW2tdLnggPT0gcDIueCAmJiBub2Rlc1Zpc2libGVba10ueSA9PSBwMi55ICl7XG4gIC8vICAgICAgICAgb3V0cHV0ICs9ICcse1wiZnJvbUlkXCI6XCInKyBjcmVhdGVOb2RlSWQyKHAxKSArJ1wiLFwidG9JZFwiOlwiJytjcmVhdGVOb2RlSWQyKHAyKSsnXCJ9J1xuICAvLyAgICAgICB9XG5cbiAgLy8gICAgICAgLy8gaWYoaXNWaXNpYmxlKHAxLCBwMikpXG4gIC8vICAgICAgIC8vICAgb3V0cHV0ICs9ICcse1wiZnJvbUlkXCI6XCInKyBjcmVhdGVOb2RlSWQyKHAxKSArJ1wiLFwidG9JZFwiOlwiJytjcmVhdGVOb2RlSWQyKHAyKSsnXCJ9J1xuICAvLyAgICAgfVxuICAvLyAgIH1cblxuICAvLyB9XG5cblxuICBjb25zb2xlLmxvZyhvdXRwdXQpXG5cbn1cblxuZnVuY3Rpb24gbG9hZFR1cmZQb2x5Z29ucyhkYXRhKXtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHNBcnIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYUFzSW50ID0gW11cbiAgICB2YXIgYSA9IHBvaW50c0FycltpXVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBhLmxlbmd0aDsgaisrKSB7XG4gICAgICBhQXNJbnQucHVzaChbTWF0aC5yb3VuZChhW2pdLnggKiBtdWx0aXBsaWVyKSwgTWF0aC5yb3VuZChhW2pdLnkgKiBtdWx0aXBsaWVyKV0pXG4gICAgfVxuICAgIGFBc0ludC5wdXNoKFtNYXRoLnJvdW5kKGFbMF0ueCAqIG11bHRpcGxpZXIpLCBNYXRoLnJvdW5kKGFbMF0ueSAqIG11bHRpcGxpZXIpXSkgLy8ganVzdCB0byBtYWtlIHN1cmUgbGFzdCBpcyBlcXVhbCB0byBmaXJzdFxuXG4gICAgdHVyZlBvbHlnb25zLnB1c2godHVyZi5wb2x5Z29uKFthQXNJbnRdKSk7XG4gIH1cbn1cblxuICBcbi8vIGRldGVybWluZXMgdGhlIHF1YWRyYW50IG9mIGEgcG9pbnQgXG4vLyAodXNlZCBpbiBjb21wYXJlKCkpIFxuZnVuY3Rpb24gcXVhZChwKSBcbnsgXG4gICAgaWYgKHAueCA+PSAwICYmIHAueSA+PSAwKSBcbiAgICAgICAgcmV0dXJuIDE7IFxuICAgIGlmIChwLnggPD0gMCAmJiBwLnkgPj0gMCkgXG4gICAgICAgIHJldHVybiAyOyBcbiAgICBpZiAocC54IDw9IDAgJiYgcC55IDw9IDApIFxuICAgICAgICByZXR1cm4gMzsgXG4gICAgcmV0dXJuIDQ7IFxufSBcbiAgXG4vLyBDaGVja3Mgd2hldGhlciB0aGUgbGluZSBpcyBjcm9zc2luZyB0aGUgcG9seWdvbiBcbmZ1bmN0aW9uIG9yaWVudGF0aW9uKCBhLCBiLCBjKSBcbnsgXG4gICAgdmFyIHJlcyA9IChiLnktYS55KSooYy54LWIueCkgLSBcbiAgICAgICAgICAgICAgKGMueS1iLnkpKihiLngtYS54KTsgXG4gIFxuICAgIGlmIChyZXMgPT0gMCkgXG4gICAgICAgIHJldHVybiAwOyBcbiAgICBpZiAocmVzID4gMCkgXG4gICAgICAgIHJldHVybiAxOyBcbiAgICByZXR1cm4gLTE7IFxufSBcbiAgXG5mdW5jdGlvbiBjbG9uZVBvaW50cyAocG9pbnRzKSB7XG4gIHJldHVybiBwb2ludHMuc2xpY2UoMClcbn1cblxuZnVuY3Rpb24gc29ydFBvaW50cyAocG9pbnQsIGNsb25lZFBvaW50cykge1xuICBjbG9uZWRQb2ludHMuc29ydCgoYSwgYikgPT4ge1xuICAgIHZhciBwID0gbmV3IFBvaW50KFthLnggLSBtaWQueCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEueSAtIG1pZC55XSk7IFxuICAgIHZhciBxID0gbmV3IFBvaW50KFtiLnggLSBtaWQueCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIueSAtIG1pZC55XSk7IFxuICBcbiAgICB2YXIgb25lID0gcXVhZChwKTsgXG4gICAgdmFyIHR3byA9IHF1YWQocSk7IFxuICBcbiAgICBpZiAob25lICE9IHR3bykgXG4gICAgICAgIHJldHVybiAob25lIDwgdHdvID8gLTEgOiAxKTsgXG4gICAgcmV0dXJuIChwLnkqcS54IDwgcS55KnAueCA/IC0xIDogMSk7IFxuICB9KVxufVxuXG4vLyBmdW5jdGlvbiBzb3J0UG9pbnRzIChwb2ludCwgY2xvbmVkUG9pbnRzKSB7XG4vLyAgIGNsb25lZFBvaW50cy5zb3J0KChhLCBiKSA9PiB7XG4vLyAgICAgY29uc3QgYW5nbGUxID0gcG9pbnQuYW5nbGVUb1BvaW50KGEpXG4vLyAgICAgY29uc3QgYW5nbGUyID0gcG9pbnQuYW5nbGVUb1BvaW50KGIpXG4vLyAgICAgaWYgKGFuZ2xlMSA8IGFuZ2xlMikgcmV0dXJuIC0xXG4vLyAgICAgaWYgKGFuZ2xlMSA+IGFuZ2xlMikgcmV0dXJuIDFcbi8vICAgICBjb25zdCBkaXN0MSA9IGNhbGNFZGdlRGlzdGFuY2UocG9pbnQsIGEpXG4vLyAgICAgY29uc3QgZGlzdDIgPSBjYWxjRWRnZURpc3RhbmNlKHBvaW50LCBiKVxuLy8gICAgIGlmIChkaXN0MSA8IGRpc3QyKSByZXR1cm4gLTFcbi8vICAgICBpZiAoZGlzdDEgPiBkaXN0MikgcmV0dXJuIDFcbi8vICAgICByZXR1cm4gMFxuLy8gICB9KVxuLy8gfVxuXG5mdW5jdGlvbiBnZXRQb2x5Z29uVGFuZ2VudHMoc3JjUG9pbnQsIHBvaW50c0Fycil7XG4gICAgLy8gaW5pdGlhbGl6ZSB1c2luZyBmaXJzdCBwb2ludFxuICAgIHZhciBmaXJzdFBvaW50ID0gcG9pbnRzQXJyW3BvaW50c0Fyci5sZW5ndGggLSAxXVxuICAgIHZhciBhbmdsZSA9IHNyY1BvaW50LmFuZ2xlVG9Qb2ludChmaXJzdFBvaW50KVxuICAgIHZhciBsZWZ0TW9zdEFuZ2xlID0gYW5nbGVcbiAgICB2YXIgcmlnaHRNb3N0QW5nbGUgPSBhbmdsZVxuICAgIHZhciBsZWZ0TW9zdFBvaW50ID0gZmlyc3RQb2ludFxuICAgIHZhciByaWdodE1vc3RQb2ludCA9IGZpcnN0UG9pbnRcbiAgICAgICAgLy8gcm91dGVMYXllci5zZXRMYXRMbmdzKFtzcmNQb2ludCwgZmlyc3RQb2ludF0pXG5cbiAgICBmb3IgKHZhciBpID0gIHBvaW50c0Fyci5sZW5ndGggLSAyOyAgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgLy8gaXMgdGhpcyBwb2ludCBtb3JlIHRvd2FyZHMgbGVmdCB0aGFuIGxlZnQgbW9zdCBwb2ludD9cbiAgICAgICAgdmFyIGFuZ2xlID0gc3JjUG9pbnQuYW5nbGVUb1BvaW50KHBvaW50c0FycltpXSlcbiAgICAgICAgdmFyIGRpZmYxID0gcmlnaHRNb3N0QW5nbGUgLSBhbmdsZVxuICAgICAgICBkaWZmMSA9IGRpZmYxIDwgMCA/ICgoZGlmZjEgPCAtTWF0aC5QSSkgPyBkaWZmMSArIE1hdGguUEkqMiA6IE1hdGguUEkgKiAzKSA6IGRpZmYxXG4gICAgICAgIC8vIGRpZmYxID0gZGlmZjEgPCAwID8gZGlmZjEgKyBNYXRoLlBJKjIgOiBkaWZmMVxuXG4gICAgICAgIC8vIGlzIHRoaXMgcG9pbnQgbW9yZSB0b3dhcmRzIHJpZ2h0IHRoYW4gcmlnaHQgbW9zdCBwb2ludD9cbiAgICAgICAgdmFyIGFuZ2xlID0gc3JjUG9pbnQuYW5nbGVUb1BvaW50KHBvaW50c0FycltpXSlcbiAgICAgICAgdmFyIGRpZmYyID0gYW5nbGUgLSBsZWZ0TW9zdEFuZ2xlXG4gICAgICAgIGRpZmYyID0gZGlmZjIgPCAwID8gKChkaWZmMiA8IC1NYXRoLlBJKSA/IGRpZmYyICsgTWF0aC5QSSoyIDogTWF0aC5QSSAqIDMpIDogZGlmZjJcbiAgICAgICAgLy8gZGlmZjIgPSBkaWZmMiA8IDAgPyBkaWZmMiArIE1hdGguUEkqMiA6IGRpZmYyXG5cbiAgICAgICAgLy8gaWYoaSA9PSA1NilcbiAgICAgICAgLy8gICBpID0gaVxuXG5cbiAgICAgICAgLyogaWYgdW5jaGFydGVyZWQgYW5nbGUgKi9cbiAgICAgICAgaWYoZGlmZjEgPCBNYXRoLlBJLzIgfHwgZGlmZjIgPCBNYXRoLlBJLzIpe1xuICAgICAgICAgIGlmKGRpZmYxIDwgZGlmZjIpe1xuICAgICAgICAgICAgLyogaWYgY2xvc2VyIHRvIGxlZnQgbW9zdCBwb2ludCAqL1xuICAgICAgICAgICAgcmlnaHRNb3N0QW5nbGUgPSBhbmdsZVxuICAgICAgICAgICAgcmlnaHRNb3N0UG9pbnQgPSBwb2ludHNBcnJbaV1cbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIGxlZnRNb3N0QW5nbGUgPSBhbmdsZVxuICAgICAgICAgICAgbGVmdE1vc3RQb2ludCA9IHBvaW50c0FycltpXVxuICAgICAgICAgICAgLy8gYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW2xlZnRNb3N0UG9pbnQsIHJpZ2h0TW9zdFBvaW50XVxufVxuXG5mdW5jdGlvbiBnZXREeW5hbWljRWRnZXNKU09OKHN0YXJ0UG9pbnQsIGVuZFBvaW50KVxue1xuICB2YXIgZHluYW1pY0VkZ2VzSlNPTiA9IFwiXCJcbiAgLy8gdmFyIHN0YXJ0UG9pbnQgPSBuZXcgUG9pbnQoW3N0YXJ0UG9pbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0sIHN0YXJ0UG9pbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV1dKTtcbiAgLy8gdmFyIGVuZFBvaW50ID0gbmV3IFBvaW50KFtlbmRQb2ludC5nZW9tZXRyeS5jb29yZGluYXRlc1swXSwgZW5kUG9pbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV1dKTtcbiAgYWRkU3RhcnRpbmdBbmRFbmRpbmdOb2RlcyhzdGFydFBvaW50LCBlbmRQb2ludClcblxuXG4gIHZhciBwb2ludHNUb0Nvbm5lY3QgPSBbXVxuICB2YXIgcG9seWdvbklkcyA9IFtdXG4gIHBvaW50c1RvQ29ubmVjdC5wdXNoKFtlbmRQb2ludCwgc3RhcnRQb2ludF0pXG4gIHBvaW50c1RvQ29ubmVjdC5wdXNoKFtzdGFydFBvaW50LCBlbmRQb2ludF0pXG4gIHBvbHlnb25JZHMucHVzaCgtMSlcbiAgcG9seWdvbklkcy5wdXNoKC0xKVxuICB2YXIgayA9IDBcblxuICB3aGlsZShwb2ludHNUb0Nvbm5lY3QubGVuZ3RoICE9IDApe1xuICAgIHZhciBvbGRQb2ludHNUb0Nvbm5lY3QgPSBwb2ludHNUb0Nvbm5lY3Quc2xpY2UoMClcbiAgICB2YXIgb2xkUG9seWdvbklkcyA9IHBvbHlnb25JZHMuc2xpY2UoMClcbiAgICBwb2ludHNUb0Nvbm5lY3QgPSBbXVxuICAgIHBvbHlnb25JZHMgPSBbXVxuXG4gICAgZm9yICh2YXIgaSA9IG9sZFBvaW50c1RvQ29ubmVjdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIHNyY1BvaW50ID0gb2xkUG9pbnRzVG9Db25uZWN0W2ldWzBdXG4gICAgICB2YXIgZGVzdFBvaW50ID0gb2xkUG9pbnRzVG9Db25uZWN0W2ldWzFdXG5cbiAgICAgIHZhciBhbmdsZSA9IHNyY1BvaW50LmFuZ2xlVG9Qb2ludChkZXN0UG9pbnQpXG4gICAgICB2YXIgbm9PYnN0cnVjdGluZ1BvbHlnb25zID0gdHJ1ZVxuXG4gICAgICBmb3IgKHZhciBqID0gcG9pbnRzQXJyLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgIHZhciB0YW5nZW50cyA9IGdldFBvbHlnb25UYW5nZW50cyhvbGRQb2ludHNUb0Nvbm5lY3RbaV1bMF0sIHBvaW50c0FycltqXSlcbiAgICAgICAgdmFyIGFuZ2xlMSA9IHNyY1BvaW50LmFuZ2xlVG9Qb2ludCh0YW5nZW50c1swXSlcbiAgICAgICAgdmFyIGFuZ2xlMiA9IHNyY1BvaW50LmFuZ2xlVG9Qb2ludCh0YW5nZW50c1sxXSlcblxuICAgICAgICAvLyBtYWtlIGFsbCBhbmdsZXMgcmVsYXRpdmUgdG8gcmlnaHQgbW9zdCBhbmdsZSAoYW5nbGUyKSBieSBtYWtpbmcgcmlnaHQgbW9zdCBhbmdsZSAwIChzdGFydGluZyBhbmdsZSlcbiAgICAgICAgdmFyIGFuZ2xlMCA9IGFuZ2xlIC0gYW5nbGUyXG4gICAgICAgIGFuZ2xlMSAtPSBhbmdsZTJcbiAgICAgICAgYW5nbGUyIC09IGFuZ2xlMlxuXG4gICAgICAgIGlmKGFuZ2xlMiA8IGFuZ2xlMCAmJiBhbmdsZTAgPCBhbmdsZTEpe1xuICAgICAgICAgIHZhciBvYnN0cnVjdGluZ0VkZ2UgPSBnZXRPYnN0cnVjdGluZ0VkZ2Uob2xkUG9pbnRzVG9Db25uZWN0W2ldWzBdLCBvbGRQb2ludHNUb0Nvbm5lY3RbaV1bMV0sIHBvaW50c0FycltqXSlcblxuICAgICAgICAgIGlmKG9ic3RydWN0aW5nRWRnZSAhPSBudWxsKXtcbiAgICAgICAgICAgIG5vT2JzdHJ1Y3RpbmdQb2x5Z29ucyA9IGZhbHNlXG4gICAgICAgICAgICBwb2ludHNUb0Nvbm5lY3QucHVzaChbb2xkUG9pbnRzVG9Db25uZWN0W2ldWzBdLCB0YW5nZW50c1swXV0pXG4gICAgICAgICAgICBwb2ludHNUb0Nvbm5lY3QucHVzaChbb2xkUG9pbnRzVG9Db25uZWN0W2ldWzBdLCB0YW5nZW50c1sxXV0pXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYobm9PYnN0cnVjdGluZ1BvbHlnb25zKVxuICAgICAgICBkeW5hbWljRWRnZXNKU09OICs9ICcse1wiZnJvbUlkXCI6XCInK2NyZWF0ZU5vZGVJZDIob2xkUG9pbnRzVG9Db25uZWN0W2ldWzBdKSsnXCIsXCJ0b0lkXCI6XCInK2NyZWF0ZU5vZGVJZDIob2xkUG9pbnRzVG9Db25uZWN0W2ldWzFdKSsnXCJ9J1xuICAgIH1cbiAgICBrKytcbiAgfVxuXG4gIHJldHVybiBkeW5hbWljRWRnZXNKU09OXG59XG5cbi8vIGZ1bmN0aW9uIGdldER5bmFtaWNFZGdlc0pTT04oc3RhcnRQb2ludCwgZW5kUG9pbnQpXG4vLyB7XG4vLyAgIHZhciBkeW5hbWljRWRnZXNKU09OID0gXCJcIlxuLy8gICAvLyB2YXIgbmVhcmVzdFBvaW50XG4vLyAgIC8vIHZhciBzdGFydCA9IHR1cmYucG9pbnQoW01hdGgucm91bmQoc3RhcnRQb2ludC5nZW9tZXRyeS5jb29yZGluYXRlc1swXSAqIG11bHRpcGxpZXIpLCBNYXRoLnJvdW5kKHN0YXJ0UG9pbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV0gKiBtdWx0aXBsaWVyKV0pO1xuLy8gICAvLyB2YXIgZW5kID0gdHVyZi5wb2ludChbTWF0aC5yb3VuZChlbmRQb2ludC5nZW9tZXRyeS5jb29yZGluYXRlc1swXSAqIG11bHRpcGxpZXIpLCBNYXRoLnJvdW5kKGVuZFBvaW50Lmdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdICogbXVsdGlwbGllcildKTtcbi8vICAgdmFyIHN0YXJ0UG9pbnQgPSBuZXcgUG9pbnQoW3N0YXJ0UG9pbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0sIHN0YXJ0UG9pbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV1dKTtcbi8vICAgdmFyIGVuZFBvaW50ID0gbmV3IFBvaW50KFtlbmRQb2ludC5nZW9tZXRyeS5jb29yZGluYXRlc1swXSwgZW5kUG9pbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV1dKTtcbi8vICAgYWRkU3RhcnRpbmdBbmRFbmRpbmdOb2RlcyhzdGFydFBvaW50LCBlbmRQb2ludClcblxuLy8gICB2YXIgcG9pbnRzVG9Db25uZWN0ID0gW11cbi8vICAgdmFyIHBvbHlnb25JZHMgPSBbXVxuLy8gICBwb2ludHNUb0Nvbm5lY3QucHVzaChbZW5kUG9pbnQsIHN0YXJ0UG9pbnRdKVxuLy8gICAvLyBwb2ludHNUb0Nvbm5lY3QucHVzaChbc3RhcnRQb2ludCwgZW5kUG9pbnRdKVxuLy8gICBwb2x5Z29uSWRzLnB1c2goLTEpXG4vLyAgIC8vIHBvbHlnb25JZHMucHVzaCgtMSlcbi8vICAgdmFyIGsgPSAwXG5cbi8vICAgd2hpbGUocG9pbnRzVG9Db25uZWN0Lmxlbmd0aCAhPSAwKXtcbi8vICAgICB2YXIgb2xkUG9pbnRzVG9Db25uZWN0ID0gcG9pbnRzVG9Db25uZWN0LnNsaWNlKDApXG4vLyAgICAgdmFyIG9sZFBvbHlnb25JZHMgPSBwb2x5Z29uSWRzLnNsaWNlKDApXG4vLyAgICAgcG9pbnRzVG9Db25uZWN0ID0gW11cbi8vICAgICBwb2x5Z29uSWRzID0gW11cbi8vICAgICBmb3IgKHZhciBpID0gb2xkUG9pbnRzVG9Db25uZWN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4vLyAgICAgICAvLyB2YXIgdHVyZlBvaW50ID0gdHVyZi5wb2ludChbTWF0aC5yb3VuZChvbGRQb2ludHNUb0Nvbm5lY3RbaV1bMF0ueCAqIG11bHRpcGxpZXIpLCBNYXRoLnJvdW5kKG9sZFBvaW50c1RvQ29ubmVjdFtpXVswXS55ICogbXVsdGlwbGllcildKTtcbi8vICAgICAgIHZhciBvYnN0cnVjdGluZ0VkZ2UgPSBnZXRPYnN0cnVjdGluZ0VkZ2Uob2xkUG9pbnRzVG9Db25uZWN0W2ldWzBdLCBvbGRQb2ludHNUb0Nvbm5lY3RbaV1bMV0pXG4vLyAgICAgICBpZihvYnN0cnVjdGluZ0VkZ2UgPT0gbnVsbCl7XG4vLyAgICAgICAgIC8vIGlmKGlzVmlzaWJsZShvbGRQb2ludHNUb0Nvbm5lY3RbaV1bMF0sIG9sZFBvaW50c1RvQ29ubmVjdFtpXVsxXSkpXG4vLyAgICAgICAgICAgZHluYW1pY0VkZ2VzSlNPTiArPSAnLHtcImZyb21JZFwiOlwiJytjcmVhdGVOb2RlSWQyKG9sZFBvaW50c1RvQ29ubmVjdFtpXVswXSkrJ1wiLFwidG9JZFwiOlwiJytjcmVhdGVOb2RlSWQyKG9sZFBvaW50c1RvQ29ubmVjdFtpXVsxXSkrJ1wifSdcbi8vICAgICAgIH1lbHNle1xuLy8gICAgICAgICB2YXIgaiA9IHR1cmZQb2x5Z29ucy5sZW5ndGggLSBvYnN0cnVjdGluZ0VkZ2UucDEucG9seWdvbklEIC0gMVxuLy8gICAgICAgICBpZihqID09IG9sZFBvbHlnb25JZHNbaV0pXG4vLyAgICAgICAgICAgZHluYW1pY0VkZ2VzSlNPTiArPSAnLHtcImZyb21JZFwiOlwiJytjcmVhdGVOb2RlSWQyKG9sZFBvaW50c1RvQ29ubmVjdFtpXVswXSkrJ1wiLFwidG9JZFwiOlwiJytjcmVhdGVOb2RlSWQyKG9sZFBvaW50c1RvQ29ubmVjdFtpXVsxXSkrJ1wifSdcbi8vICAgICAgICAgZWxzZXtcbi8vICAgICAgICAgICB2YXIgdGFuZ2VudHMgPSBnZXRQb2x5Z29uVGFuZ2VudHMob2xkUG9pbnRzVG9Db25uZWN0W2ldWzBdLCBwb2ludHNBcnJbal0pXG4vLyAgICAgICAgICAgcG9pbnRzVG9Db25uZWN0LnB1c2goW29sZFBvaW50c1RvQ29ubmVjdFtpXVswXSwgdGFuZ2VudHNbMF1dKVxuLy8gICAgICAgICAgIHBvaW50c1RvQ29ubmVjdC5wdXNoKFtvbGRQb2ludHNUb0Nvbm5lY3RbaV1bMF0sIHRhbmdlbnRzWzFdXSlcbi8vICAgICAgICAgICBwb2x5Z29uSWRzLnB1c2goailcbi8vICAgICAgICAgICBwb2x5Z29uSWRzLnB1c2goailcblxuXG5cblxuXG5cblxuXG5cblxuXG4vLyAgICAgICAgICAgLy8gdmFyIGZlYXR1cmVzMSA9IHR1cmYucG9seWdvblRhbmdlbnRzKHR1cmZQb2ludCwgdHVyZlBvbHlnb25zW2pdKS5mZWF0dXJlc1xuLy8gICAgICAgICAgIC8vIGlmKGZlYXR1cmVzMS5sZW5ndGggPiAyKVxuLy8gICAgICAgICAgIC8vICAgYWxlcnQoJ01vcmUgdGhhbiAyIHRhbmdlbnRzJylcblxuLy8gICAgICAgICAgIC8vIHZhciBuZWFyZXN0UG9pbnQgPSB0dXJmLm5lYXJlc3RQb2ludCh0dXJmLnBvaW50KFtmZWF0dXJlczFbMF0uZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0vbXVsdGlwbGllciwgZmVhdHVyZXMxWzBdLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdL211bHRpcGxpZXJdKSwgcG9pbnRzKVxuLy8gICAgICAgICAgIC8vIHZhciB0YW5nZW50MSA9IG5ldyBQb2ludChbbmVhcmVzdFBvaW50Lmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdLCBuZWFyZXN0UG9pbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV1dKVxuLy8gICAgICAgICAgIC8vIG5lYXJlc3RQb2ludCA9IHR1cmYubmVhcmVzdFBvaW50KHR1cmYucG9pbnQoW2ZlYXR1cmVzMVsxXS5nZW9tZXRyeS5jb29yZGluYXRlc1swXS9tdWx0aXBsaWVyLCBmZWF0dXJlczFbMV0uZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV0vbXVsdGlwbGllcl0pLCBwb2ludHMpXG4vLyAgICAgICAgICAgLy8gdmFyIHRhbmdlbnQyID0gbmV3IFBvaW50KFtuZWFyZXN0UG9pbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0sIG5lYXJlc3RQb2ludC5nZW9tZXRyeS5jb29yZGluYXRlc1sxXV0pXG4vLyAgICAgICAgICAgLy8gcG9pbnRzVG9Db25uZWN0LnB1c2goW29sZFBvaW50c1RvQ29ubmVjdFtpXVswXSwgdGFuZ2VudDFdKVxuLy8gICAgICAgICAgIC8vIHBvaW50c1RvQ29ubmVjdC5wdXNoKFtvbGRQb2ludHNUb0Nvbm5lY3RbaV1bMF0sIHRhbmdlbnQyXSlcbi8vICAgICAgICAgICAvLyBwb2x5Z29uSWRzLnB1c2goailcbi8vICAgICAgICAgICAvLyBwb2x5Z29uSWRzLnB1c2goailcblxuXG5cblxuXG5cblxuXG5cbi8vICAgICAgICAgICBpZihrPT0wKXtcbi8vICAgICAgICAgICAgIHBvaW50c1RvQ29ubmVjdC5wdXNoKFtvbGRQb2ludHNUb0Nvbm5lY3Rbb2xkUG9pbnRzVG9Db25uZWN0Lmxlbmd0aC0xLWldWzBdLCB0YW5nZW50c1swXV0pXG4vLyAgICAgICAgICAgICBwb2ludHNUb0Nvbm5lY3QucHVzaChbb2xkUG9pbnRzVG9Db25uZWN0W29sZFBvaW50c1RvQ29ubmVjdC5sZW5ndGgtMS1pXVswXSwgdGFuZ2VudHNbMV1dKVxuLy8gICAgICAgICAgICAgcG9seWdvbklkcy5wdXNoKC0xKVxuLy8gICAgICAgICAgICAgcG9seWdvbklkcy5wdXNoKC0xKVxuLy8gICAgICAgICAgIH1cblxuXG4vLyAgICAgICAgICAgLy8gaWYoaz09MCl7XG4vLyAgICAgICAgICAgLy8gICBjb25zb2xlLmxvZyhcIlxcdHZhciBzdGFydCA9IFtcIitjcmVhdGVOb2RlSWQyKG9sZFBvaW50c1RvQ29ubmVjdFtpXVswXSkrXCJdXFxuXFx0dmFyIGVuZCA9IFtcIitjcmVhdGVOb2RlSWQyKHRhbmdlbnRzWzBdKStcIl1cXG5cXG5cIilcbi8vICAgICAgICAgICAvLyAgIGNvbnNvbGUubG9nKFwiXFx0dmFyIHN0YXJ0ID0gW1wiK2NyZWF0ZU5vZGVJZDIob2xkUG9pbnRzVG9Db25uZWN0W2ldWzBdKStcIl1cXG5cXHR2YXIgZW5kID0gW1wiK2NyZWF0ZU5vZGVJZDIodGFuZ2VudHNbMV0pK1wiXVxcblxcblwiKVxuLy8gICAgICAgICAgIC8vICAgaWYoaT09MClcbi8vICAgICAgICAgICAvLyAgICAgcmV0dXJuIGR5bmFtaWNFZGdlc0pTT047XG4vLyAgICAgICAgICAgLy8gfVxuXG4vLyAgICAgICAgIH1cbi8vICAgICAgIH1cbi8vICAgICB9XG4vLyAgICAgaysrXG4vLyAgIH1cblxuLy8gICAvLyB2YXIgbm9kZXNWaXNpYmxlMSA9IGdldFZpc2libGVOb2RlcyhzdGFydFBvaW50LCBzdGFydFBvaW50LCBlbmRQb2ludClcbi8vICAgLy8gdmFyIG5vZGVzVmlzaWJsZTIgPSBnZXRWaXNpYmxlTm9kZXMoZW5kUG9pbnQpXG4vLyAgIC8vIHZhciBzdGFydFRhbmdlbnRzID0gW11cbi8vICAgLy8gdmFyIGVuZFRhbmdlbnRzID0gW11cblxuLy8gICAvLyBmb3IgKHZhciBpID0gMDsgaSA8IHR1cmZQb2x5Z29ucy5sZW5ndGg7IGkrKykge1xuLy8gICAvLyAgIGNvbnNvbGUubG9nKCd0ZXN0Jyk7XG5cbi8vICAgLy8gICB2YXIgZmVhdHVyZXMxID0gdHVyZi5wb2x5Z29uVGFuZ2VudHMoc3RhcnQsIHR1cmZQb2x5Z29uc1tpXSkuZmVhdHVyZXNcbi8vICAgLy8gICB2YXIgZmVhdHVyZXMyID0gdHVyZi5wb2x5Z29uVGFuZ2VudHMoZW5kLCB0dXJmUG9seWdvbnNbaV0pLmZlYXR1cmVzXG5cbi8vICAgLy8gICB2YXIgc3RhcnRUYW5nZW50MSA9IG5ldyBQb2ludChbZmVhdHVyZXMxWzBdLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdL211bHRpcGxpZXIsIGZlYXR1cmVzMVswXS5nZW9tZXRyeS5jb29yZGluYXRlc1sxXS9tdWx0aXBsaWVyXSlcbi8vICAgLy8gICB2YXIgc3RhcnRUYW5nZW50MiA9IG5ldyBQb2ludChbZmVhdHVyZXMxWzFdLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdL211bHRpcGxpZXIsIGZlYXR1cmVzMVsxXS5nZW9tZXRyeS5jb29yZGluYXRlc1sxXS9tdWx0aXBsaWVyXSlcbi8vICAgLy8gICBzdGFydFRhbmdlbnRzLnB1c2goc3RhcnRUYW5nZW50MSlcbi8vICAgLy8gICBzdGFydFRhbmdlbnRzLnB1c2goc3RhcnRUYW5nZW50MilcblxuLy8gICAvLyAgIHZhciBlbmRUYW5nZW50MSA9IG5ldyBQb2ludChbZmVhdHVyZXMyWzBdLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdL211bHRpcGxpZXIsIGZlYXR1cmVzMlswXS5nZW9tZXRyeS5jb29yZGluYXRlc1sxXS9tdWx0aXBsaWVyXSlcbi8vICAgLy8gICB2YXIgZW5kVGFuZ2VudDIgPSBuZXcgUG9pbnQoW2ZlYXR1cmVzMlsxXS5nZW9tZXRyeS5jb29yZGluYXRlc1swXS9tdWx0aXBsaWVyLCBmZWF0dXJlczJbMV0uZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV0vbXVsdGlwbGllcl0pXG4vLyAgIC8vICAgZW5kVGFuZ2VudHMucHVzaChlbmRUYW5nZW50MSlcbi8vICAgLy8gICBlbmRUYW5nZW50cy5wdXNoKGVuZFRhbmdlbnQyKVxuXG4vLyAgIC8vICAgaWYoaT09MTEpe1xuLy8gICAvLyAgICAgY29uc29sZS5sb2coXCJcXHR2YXIgc3RhcnQgPSBbXCIrY3JlYXRlTm9kZUlkMihzdGFydFBvaW50KStcIl1cXG5cXHR2YXIgZW5kID0gW1wiK2NyZWF0ZU5vZGVJZCh0dXJmLm5lYXJlc3RQb2ludCh0dXJmLnBvaW50KFtzdGFydFRhbmdlbnQxLngsIHN0YXJ0VGFuZ2VudDEueV0pLCBwb2ludHMpKStcIl1cXG5cXG5cIilcbi8vICAgLy8gICAgIGNvbnNvbGUubG9nKFwiXFx0dmFyIHN0YXJ0ID0gW1wiK2NyZWF0ZU5vZGVJZDIoc3RhcnRQb2ludCkrXCJdXFxuXFx0dmFyIGVuZCA9IFtcIitjcmVhdGVOb2RlSWQodHVyZi5uZWFyZXN0UG9pbnQodHVyZi5wb2ludChbc3RhcnRUYW5nZW50Mi54LCBzdGFydFRhbmdlbnQyLnldKSwgcG9pbnRzKSkrXCJdXFxuXFxuXCIpXG4vLyAgIC8vICAgICBjb25zb2xlLmxvZyhcIlxcdHZhciBzdGFydCA9IFtcIitjcmVhdGVOb2RlSWQyKGVuZFBvaW50KStcIl1cXG5cXHR2YXIgZW5kID0gW1wiK2NyZWF0ZU5vZGVJZCh0dXJmLm5lYXJlc3RQb2ludCh0dXJmLnBvaW50KFtlbmRUYW5nZW50MS54LCBlbmRUYW5nZW50MS55XSksIHBvaW50cykpK1wiXVxcblxcblwiKVxuLy8gICAvLyAgICAgY29uc29sZS5sb2coXCJcXHR2YXIgc3RhcnQgPSBbXCIrY3JlYXRlTm9kZUlkMihlbmRQb2ludCkrXCJdXFxuXFx0dmFyIGVuZCA9IFtcIitjcmVhdGVOb2RlSWQodHVyZi5uZWFyZXN0UG9pbnQodHVyZi5wb2ludChbZW5kVGFuZ2VudDIueCwgZW5kVGFuZ2VudDIueV0pLCBwb2ludHMpKStcIl1cXG5cXG5cIilcbi8vICAgLy8gICB9XG5cbi8vICAgLy8gfVxuXG4vLyAgIC8vIGZvciAodmFyIGogPSBub2Rlc1Zpc2libGUxLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4vLyAgIC8vICAgZm9yICh2YXIgaSA9IHN0YXJ0VGFuZ2VudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbi8vICAgLy8gICAgIGlmKG5vZGVzVmlzaWJsZTFbal0ueCA9PSBzdGFydFRhbmdlbnRzW2ldLnggJiYgbm9kZXNWaXNpYmxlMVtqXS55ID09IHN0YXJ0VGFuZ2VudHNbaV0ueSApe1xuLy8gICAvLyAgICAgICBuZWFyZXN0UG9pbnQgPSB0dXJmLm5lYXJlc3RQb2ludCh0dXJmLnBvaW50KFtzdGFydFRhbmdlbnRzW2ldLngsIHN0YXJ0VGFuZ2VudHNbaV0ueV0pLCBwb2ludHMpXG4vLyAgIC8vICAgICAgIGR5bmFtaWNFZGdlc0pTT04gKz0gJyx7XCJmcm9tSWRcIjpcIicrY3JlYXRlTm9kZUlkMihzdGFydFBvaW50KSsnXCIsXCJ0b0lkXCI6XCInK2NyZWF0ZU5vZGVJZChuZWFyZXN0UG9pbnQpKydcIn0nXG4vLyAgIC8vICAgICB9XG4vLyAgIC8vICAgfVxuLy8gICAvLyAgIC8vIGlmKG5vZGVzVmlzaWJsZTFbal0ueCA9PSBzdGFydFRhbmdlbnQyLnggJiYgbm9kZXNWaXNpYmxlMVtqXS55ID09IHN0YXJ0VGFuZ2VudDIueSApe1xuLy8gICAvLyAgIC8vICAgbmVhcmVzdFBvaW50ID0gdHVyZi5uZWFyZXN0UG9pbnQodHVyZi5wb2ludChbc3RhcnRUYW5nZW50Mi54LCBzdGFydFRhbmdlbnQyLnldKSwgcG9pbnRzKVxuLy8gICAvLyAgIC8vICAgZHluYW1pY0VkZ2VzSlNPTiArPSAnLHtcImZyb21JZFwiOlwiJytjcmVhdGVOb2RlSWQyKHN0YXJ0UG9pbnQpKydcIixcInRvSWRcIjpcIicrY3JlYXRlTm9kZUlkKG5lYXJlc3RQb2ludCkrJ1wifSdcbi8vICAgLy8gICAvLyB9XG4vLyAgIC8vIH1cblxuLy8gICAvLyBmb3IgKHZhciBqID0gbm9kZXNWaXNpYmxlMi5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuLy8gICAvLyAgIGZvciAodmFyIGkgPSBlbmRUYW5nZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuLy8gICAvLyAgICAgaWYobm9kZXNWaXNpYmxlMltqXS54ID09IGVuZFRhbmdlbnRzW2ldLnggJiYgbm9kZXNWaXNpYmxlMltqXS55ID09IGVuZFRhbmdlbnRzW2ldLnkgKXtcbi8vICAgLy8gICAgICAgbmVhcmVzdFBvaW50ID0gdHVyZi5uZWFyZXN0UG9pbnQodHVyZi5wb2ludChbZW5kVGFuZ2VudHNbaV0ueCwgZW5kVGFuZ2VudHNbaV0ueV0pLCBwb2ludHMpXG4vLyAgIC8vICAgICAgIGR5bmFtaWNFZGdlc0pTT04gKz0gJyx7XCJmcm9tSWRcIjpcIicrY3JlYXRlTm9kZUlkMihlbmRQb2ludCkrJ1wiLFwidG9JZFwiOlwiJytjcmVhdGVOb2RlSWQobmVhcmVzdFBvaW50KSsnXCJ9J1xuLy8gICAvLyAgICAgfVxuLy8gICAvLyAgIH1cbi8vICAgLy8gICAvLyBpZihub2Rlc1Zpc2libGUyW2pdLnggPT0gZW5kVGFuZ2VudDEueCAmJiBub2Rlc1Zpc2libGUyW2pdLnkgPT0gZW5kVGFuZ2VudDEueSApe1xuLy8gICAvLyAgIC8vICAgbmVhcmVzdFBvaW50ID0gdHVyZi5uZWFyZXN0UG9pbnQodHVyZi5wb2ludChbZW5kVGFuZ2VudDEueCwgZW5kVGFuZ2VudDEueV0pLCBwb2ludHMpXG4vLyAgIC8vICAgLy8gICBkeW5hbWljRWRnZXNKU09OICs9ICcse1wiZnJvbUlkXCI6XCInK2NyZWF0ZU5vZGVJZDIoZW5kUG9pbnQpKydcIixcInRvSWRcIjpcIicrY3JlYXRlTm9kZUlkKG5lYXJlc3RQb2ludCkrJ1wifSdcbi8vICAgLy8gICAvLyB9XG4vLyAgIC8vICAgLy8gaWYobm9kZXNWaXNpYmxlMltqXS54ID09IGVuZFRhbmdlbnQyLnggJiYgbm9kZXNWaXNpYmxlMltqXS55ID09IGVuZFRhbmdlbnQyLnkgKXtcbi8vICAgLy8gICAvLyAgIG5lYXJlc3RQb2ludCA9IHR1cmYubmVhcmVzdFBvaW50KHR1cmYucG9pbnQoW2VuZFRhbmdlbnQyLngsIGVuZFRhbmdlbnQyLnldKSwgcG9pbnRzKVxuLy8gICAvLyAgIC8vICAgZHluYW1pY0VkZ2VzSlNPTiArPSAnLHtcImZyb21JZFwiOlwiJytjcmVhdGVOb2RlSWQyKGVuZFBvaW50KSsnXCIsXCJ0b0lkXCI6XCInK2NyZWF0ZU5vZGVJZChuZWFyZXN0UG9pbnQpKydcIn0nXG4vLyAgIC8vICAgLy8gfVxuLy8gICAvLyB9XG5cbi8vICAgcmV0dXJuIGR5bmFtaWNFZGdlc0pTT05cbi8vIH1cblxuXG5mdW5jdGlvbiBnZXREeW5hbWljTm9kZXNKU09OKHN0YXJ0UG9pbnQsIGVuZFBvaW50KVxue1xuICB2YXIgZHluYW1pY05vZGVzSlNPTiA9IFwiXCJcbiAgLy8gdmFyIHN0YXJ0UG9pbnQgPSBuZXcgUG9pbnQoW3N0YXJ0UG9pbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0sIHN0YXJ0UG9pbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV1dKTtcbiAgLy8gdmFyIGVuZFBvaW50ID0gbmV3IFBvaW50KFtlbmRQb2ludC5nZW9tZXRyeS5jb29yZGluYXRlc1swXSwgZW5kUG9pbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV1dKTtcblxuICBkeW5hbWljTm9kZXNKU09OICs9ICd7XCJpZFwiOlwiJytjcmVhdGVOb2RlSWQyKHN0YXJ0UG9pbnQpKydcIixcImRhdGFcIjp7XCJ4XCI6JytzdGFydFBvaW50LngrJyxcInlcIjonK3N0YXJ0UG9pbnQueSsnfX0sJ1xuICBkeW5hbWljTm9kZXNKU09OICs9ICd7XCJpZFwiOlwiJytjcmVhdGVOb2RlSWQyKGVuZFBvaW50KSsnXCIsXCJkYXRhXCI6e1wieFwiOicrZW5kUG9pbnQueCsnLFwieVwiOicrZW5kUG9pbnQueSsnfX0sJ1xuXG4gIC8vIHBvaW50cy5wdXNoKHN0YXJ0UG9pbnQpXG4gIC8vIHBvaW50cy5wdXNoKGVuZFBvaW50KVxuXG4gIHJldHVybiBkeW5hbWljTm9kZXNKU09OXG59XG5cblxuXG4vLyBGaW5kcyB1cHBlciB0YW5nZW50IG9mIHR3byBwb2x5Z29ucyAnYScgYW5kICdiJyBcbmZ1bmN0aW9uIGZpbmQ0VGFuZ2VudHMoYSwgYikgXG4vLyBmdW5jdGlvbiBmaW5kNFRhbmdlbnRzKGEsIGIsIHBvbHlnb24xLCBwb2x5Z29uMikgXG57IFxuICAvLyB2YXIgYUFzSW50ID0gW11cbiAgLy8gdmFyIGJBc0ludCA9IFtdXG5cbiAgLy8gZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gIC8vICAgYUFzSW50LnB1c2goW01hdGgucm91bmQoYVtpXS54ICogbXVsdGlwbGllciksIE1hdGgucm91bmQoYVtpXS55ICogbXVsdGlwbGllcildKVxuICAvLyB9XG4gIC8vIGFBc0ludC5wdXNoKFtNYXRoLnJvdW5kKGFbMF0ueCAqIG11bHRpcGxpZXIpLCBNYXRoLnJvdW5kKGFbMF0ueSAqIG11bHRpcGxpZXIpXSkgLy8ganVzdCB0byBtYWtlIHN1cmUgbGFzdCBpcyBlcXVhbCB0byBmaXJzdFxuXG4gIC8vIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAvLyAgIGJBc0ludC5wdXNoKFtNYXRoLnJvdW5kKGJbaV0ueCAqIG11bHRpcGxpZXIpLCBNYXRoLnJvdW5kKGJbaV0ueSAqIG11bHRpcGxpZXIpXSlcbiAgLy8gfVxuICAvLyBiQXNJbnQucHVzaChbTWF0aC5yb3VuZChiWzBdLnggKiBtdWx0aXBsaWVyKSwgTWF0aC5yb3VuZChiWzBdLnkgKiBtdWx0aXBsaWVyKV0pIC8vIGp1c3QgdG8gbWFrZSBzdXJlIGxhc3QgaXMgZXF1YWwgdG8gZmlyc3RcblxuICAvLyB2YXIgcG9seWdvbjEgPSB0dXJmLnBvbHlnb24oW2FBc0ludF0pO1xuICAvLyB2YXIgcG9seWdvbjIgPSB0dXJmLnBvbHlnb24oW2JBc0ludF0pO1xuXG5cblxuXG5cblxuXG4gIHZhciB0YW5nZW50czEgPSBbXVxuICB2YXIgdGFuZ2VudHMyID0gW11cbiAgdGFuZ2VudHMxLnB1c2goW2FbMF0ueCwgYVswXS55XSlcblxuXG5cblxuXG5cbiAgdmFyIGZpbmRUYW5nZW50T2ZCID0gMVxuICB2YXIgdGFuZ2VudFBhaXJzID0gW11cbiAgdmFyIGRvbmUxID0gMDtcbiAgdmFyIGRvbmUyID0gMDtcbiAgdmFyIGl0ZXJhdGlvbnNSZW1haW5pbmcgPSAxMFxuXG4gIHdoaWxlKCBpdGVyYXRpb25zUmVtYWluaW5nID4gMCl7XG4gICAgdmFyIHRhbmdlbnRzID0gW11cbiAgICB2YXIgc3JjVGFuZ2V0cyA9IGZpbmRUYW5nZW50T2ZCID8gdGFuZ2VudHMxIDogdGFuZ2VudHMyXG4gICAgdmFyIG9sZFRhbmdlbnRzID0gZmluZFRhbmdlbnRPZkIgPyB0YW5nZW50czIuc2xpY2UoMCkgOiB0YW5nZW50czEuc2xpY2UoMClcbiAgICB2YXIgcG9seWdvbiA9IGZpbmRUYW5nZW50T2ZCID8gYiA6IGFcbiAgICB2YXIgbWF0Y2hlcyA9IDBcbiAgICB2YXIgb2xkVGFuZ2VudFBhaXJzID0gdGFuZ2VudFBhaXJzLnNsaWNlKDApXG4gICAgdGFuZ2VudFBhaXJzID0gW11cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3JjVGFuZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJhd1RhbmdlbnRzID0gW11cbiAgICAgIHZhciBwb2ludCA9IG5ldyBQb2ludChzcmNUYW5nZXRzW2ldKTtcbiAgICAgIHZhciByYXdUYW5nZW50cyA9IGdldFBvbHlnb25UYW5nZW50cyhwb2ludCwgcG9seWdvbilcbiAgICAgIC8vIHRhbmdlbnRzID0gW11cblxuICAgICAgLy8gZm9yICh2YXIgaiA9IDA7IGogPCBmZWF0dXJlcy5sZW5ndGg7IGorKylcbiAgICAgIC8vICAgcmF3VGFuZ2VudHMucHVzaChmZWF0dXJlc1tqXSlcblxuICAgICAgdmFyIHNyY1BvaW50ID0gbmV3IFBvaW50KHNyY1RhbmdldHNbaV0pXG4gICAgICB2YXIgcDEgPSByYXdUYW5nZW50c1swXVxuICAgICAgdmFyIHAyID0gcmF3VGFuZ2VudHNbMV1cbiAgICAgIHZhciBhbmdsZTEgPSBzcmNQb2ludC5hbmdsZVRvUG9pbnQocDEpXG4gICAgICB2YXIgYW5nbGUyID0gc3JjUG9pbnQuYW5nbGVUb1BvaW50KHAyKVxuICAgICAgdmFyIGRpZmYgPSBhbmdsZTEgLSBhbmdsZTJcbiAgICAgIGRpZmYgPSBkaWZmIDwgMCA/IGRpZmYgKyBNYXRoLlBJKjIgOiBkaWZmXG5cbiAgICAgIHZhciByaWdodFRhbmdlbnQgPSByYXdUYW5nZW50c1sxXVxuICAgICAgdmFyIGxlZnRUYW5nZW50ID0gcmF3VGFuZ2VudHNbMF1cblxuICAgICAgaWYoZGlmZiA+IE1hdGguUEkpe1xuICAgICAgICByaWdodFRhbmdlbnQgPSByYXdUYW5nZW50c1swXVxuICAgICAgICBsZWZ0VGFuZ2VudCA9IHJhd1RhbmdlbnRzWzFdXG4gICAgICB9XG5cblxuICAgICAgaWYoc3JjVGFuZ2V0cy5sZW5ndGggPD0gMil7XG4gICAgICAgIHRhbmdlbnRzLnB1c2goW2xlZnRUYW5nZW50LngsIGxlZnRUYW5nZW50LnldKVxuICAgICAgICB0YW5nZW50cy5wdXNoKFtyaWdodFRhbmdlbnQueCwgcmlnaHRUYW5nZW50LnldKVxuICAgICAgfWVsc2V7XG4gICAgICAgIGlmKHR5cGVvZiBvbGRUYW5nZW50UGFpcnNbaV0gPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgdmFyIG9sZFNvdXJjZSA9IG5ldyBQb2ludChbb2xkVGFuZ2VudFBhaXJzW2ldWzFdWzBdLCBvbGRUYW5nZW50UGFpcnNbaV1bMV1bMV1dKVxuICAgICAgICB2YXIgZGlzdDEgPSBjYWxjRWRnZURpc3RhbmNlKHAxLCBvbGRTb3VyY2UpXG4gICAgICAgIHZhciBkaXN0MiA9IGNhbGNFZGdlRGlzdGFuY2UocDIsIG9sZFNvdXJjZSlcblxuICAgICAgICAvLyB2YXIgYW5nbGUgPSBzcmNQb2ludC5hbmdsZVRvUG9pbnQob2xkU291cmNlKVxuICAgICAgICAvLyB2YXIgZGlmZjEgPSBhbmdsZTEgLSBhbmdsZVxuICAgICAgICAvLyB2YXIgZGlmZjIgPSBhbmdsZTIgLSBhbmdsZVxuICAgICAgICAvLyBkaWZmMSA9IGRpZmYxIDwgMCA/IGRpZmYxICsgTWF0aC5QSSoyIDogZGlmZjFcbiAgICAgICAgLy8gZGlmZjIgPSBkaWZmMiA8IDAgPyBkaWZmMiArIE1hdGguUEkqMiA6IGRpZmYyXG5cbiAgICAgICAgdGFuZ2VudHMucHVzaChkaXN0MSA8IGRpc3QyID8gW3Jhd1RhbmdlbnRzWzBdLngsIHJhd1RhbmdlbnRzWzBdLnldIDogW3Jhd1RhbmdlbnRzWzFdLngsIHJhd1RhbmdlbnRzWzFdLnldKVxuICAgICAgICAvLyBpZihpID09IDApXG4gICAgICAgIC8vICAgdGFuZ2VudHMucHVzaChmaW5kVGFuZ2VudE9mQiA/IGxlZnRUYW5nZW50IDogbGVmdFRhbmdlbnQpXG4gICAgICAgIC8vIGVsc2UgaWYoaSA9PSAxKVxuICAgICAgICAvLyAgIHRhbmdlbnRzLnB1c2goZmluZFRhbmdlbnRPZkIgPyBsZWZ0VGFuZ2VudCA6IHJpZ2h0VGFuZ2VudClcbiAgICAgICAgLy8gZWxzZSBpZihpID09IDIpXG4gICAgICAgIC8vICAgdGFuZ2VudHMucHVzaChmaW5kVGFuZ2VudE9mQiA/IHJpZ2h0VGFuZ2VudCA6IGxlZnRUYW5nZW50KVxuICAgICAgICAvLyBlbHNlIGlmKGkgPT0gMylcbiAgICAgICAgLy8gICB0YW5nZW50cy5wdXNoKGZpbmRUYW5nZW50T2ZCID8gcmlnaHRUYW5nZW50IDogcmlnaHRUYW5nZW50KVxuICAgICAgfVxuXG5cbiAgICAgIC8vIGlmKHNyY1RhbmdldHMubGVuZ3RoIDw9IDIpe1xuICAgICAgLy8gICB0YW5nZW50cy5wdXNoKGxlZnRUYW5nZW50KVxuICAgICAgLy8gICB0YW5nZW50cy5wdXNoKHJpZ2h0VGFuZ2VudClcbiAgICAgIC8vIH1lbHNle1xuICAgICAgLy8gICBpZihpID09IDApXG4gICAgICAvLyAgICAgdGFuZ2VudHMucHVzaChmaW5kVGFuZ2VudE9mQiA/IGxlZnRUYW5nZW50IDogbGVmdFRhbmdlbnQpXG4gICAgICAvLyAgIGVsc2UgaWYoaSA9PSAxKVxuICAgICAgLy8gICAgIHRhbmdlbnRzLnB1c2goZmluZFRhbmdlbnRPZkIgPyBsZWZ0VGFuZ2VudCA6IHJpZ2h0VGFuZ2VudClcbiAgICAgIC8vICAgZWxzZSBpZihpID09IDIpXG4gICAgICAvLyAgICAgdGFuZ2VudHMucHVzaChmaW5kVGFuZ2VudE9mQiA/IHJpZ2h0VGFuZ2VudCA6IGxlZnRUYW5nZW50KVxuICAgICAgLy8gICBlbHNlIGlmKGkgPT0gMylcbiAgICAgIC8vICAgICB0YW5nZW50cy5wdXNoKGZpbmRUYW5nZW50T2ZCID8gcmlnaHRUYW5nZW50IDogcmlnaHRUYW5nZW50KVxuICAgICAgLy8gfVxuXG5cbiAgICAgICAgZm9yICh2YXIgbSA9IDA7IG0gPCB0YW5nZW50cy5sZW5ndGg7IG0rKykge1xuICAgICAgICAvLyBmb3IgKHZhciBrID0gb2xkVGFuZ2VudHMubGVuZ3RoIC0gMTsgayA+PSAwOyBrLS0pIHtcbiAgICAgICAgICB2YXIgdGFuZ2VudCA9IHRhbmdlbnRzW21dXG4gICAgICAgICAgaWYoc3JjVGFuZ2V0cy5sZW5ndGggPiAyKVxuICAgICAgICAgICAgdGFuZ2VudCA9IHRhbmdlbnRzW2ldXG4gICAgICAgICAgLy8gaWYodGFuZ2VudFswXSA9PSBvbGRUYW5nZW50c1trXVswXSAmJiB0YW5nZW50WzFdID09IG9sZFRhbmdlbnRzW2tdWzFdKXtcbiAgICAgICAgICAgIC8vIGlmKG1hdGNoZXMgPCA0KXtcbiAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGR1cGxpY2F0ZXNcbiAgICAgICAgICAgICAgdmFyIGlzVW5pcXVlID0gdHJ1ZVxuICAgICAgICAgICAgICBmb3IgKHZhciBsID0gdGFuZ2VudFBhaXJzLmxlbmd0aCAtIDE7IGwgPj0gMDsgbC0tKSB7XG4gICAgICAgICAgICAgICAgaWYodGFuZ2VudFBhaXJzW2xdWzBdWzBdID09IHRhbmdlbnRbMF0gJiYgdGFuZ2VudFBhaXJzW2xdWzBdWzFdID09IHRhbmdlbnRbMV0pXG4gICAgICAgICAgICAgICAgICBpc1VuaXF1ZSA9IGZhbHNlXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZihpc1VuaXF1ZSl7XG4gICAgICAgICAgICAgICAgdGFuZ2VudFBhaXJzLnB1c2goW3RhbmdlbnQsIHNyY1RhbmdldHNbaV1dKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG1hdGNoZXMrK1xuXG4gICAgICAgICAgICAgIGlmKHNyY1RhbmdldHMubGVuZ3RoID4gMilcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgIC8vIH1cbiAgICAgICAgLy8gfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYoZmluZFRhbmdlbnRPZkIpe1xuICAgICAgZG9uZTIgPSBtYXRjaGVzID09IDQgPyB0cnVlIDogZmFsc2VcbiAgICAgIHRhbmdlbnRzMiA9IHRhbmdlbnRzLnNsaWNlKDApXG4gICAgfWVsc2V7XG4gICAgICBkb25lMSA9IG1hdGNoZXMgPT0gNCA/IHRydWUgOiBmYWxzZVxuICAgICAgdGFuZ2VudHMxID0gdGFuZ2VudHMuc2xpY2UoMClcbiAgICB9XG5cbiAgICAvLyBpZihpdGVyYXRpb25zUmVtYWluaW5nID09IDcpXG4gICAgLy8gICBicmVha1xuXG4gICAgLy8gaWYobWF0Y2hlcyA8IDQpXG4gICAgLy8gICBpdGVyYXRpb25zUmVtYWluaW5nID0gMTBcblxuICAgIGZpbmRUYW5nZW50T2ZCID0gIWZpbmRUYW5nZW50T2ZCXG4gICAgaXRlcmF0aW9uc1JlbWFpbmluZy0tXG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRhbmdlbnRQYWlycy5sZW5ndGg7IGkrKykge1xuICAgIC8vIHZhciB0cDEgPSB0dXJmLnBvaW50KFt0YW5nZW50UGFpcnNbaV1bMF1bMF0sdGFuZ2VudFBhaXJzW2ldWzBdWzFdXSk7XG4gICAgLy8gdmFyIHRwMiA9IHR1cmYucG9pbnQoW3RhbmdlbnRQYWlyc1tpXVsxXVswXSx0YW5nZW50UGFpcnNbaV1bMV1bMV1dKTtcbiAgICAvLyB2YXIgbmVhcmVzdFN0YXJ0ID0gdHVyZi5uZWFyZXN0UG9pbnQodHAxLCBwb2ludHMpXG4gICAgLy8gdmFyIG5lYXJlc3RFbmQgPSB0dXJmLm5lYXJlc3RQb2ludCh0cDIsIHBvaW50cylcbiAgICBsZXQgcDEgPSBuZXcgUG9pbnQodGFuZ2VudFBhaXJzW2ldWzBdKVxuICAgIGxldCBwMiA9IG5ldyBQb2ludCh0YW5nZW50UGFpcnNbaV1bMV0pXG5cblxuXG4gICAgYWxsVGFuZ2VudHMucHVzaChwMSlcbiAgICBhbGxUYW5nZW50cy5wdXNoKHAyKVxuXG4gICAgaWYoaXNWaXNpYmxlKHAxLHAyKSlcbiAgICAgIG91dHB1dCArPSAnLHtcImZyb21JZFwiOlwiJytjcmVhdGVOb2RlSWQyKHAxKSsnXCIsXCJ0b0lkXCI6XCInK2NyZWF0ZU5vZGVJZDIocDIpKydcIn0nXG4gICAgLy8gaWYoaT09MClcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiXFx0dmFyIHN0YXJ0ID0gW1wiK2NyZWF0ZU5vZGVJZDIocDEpK1wiXVxcblxcdHZhciBlbmQgPSBbXCIrY3JlYXRlTm9kZUlkMihwMikrXCJdXFxuXFxuXCIpXG4gICAgLy8gZWxzZXtcbiAgICAvLyAgIHZhciBpc1Zpc2libGUgPSB0cnVlXG4gICAgLy8gICB2YXIgYW5nbGUgPSBwMS5hbmdsZVRvUG9pbnQocDIpXG5cbiAgICAvLyAgIGZvciAodmFyIGogPSB0dXJmUG9seWdvbnMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAvLyAgICAgdmFyIHRwbTEgPSB0dXJmLnBvaW50KFt0YW5nZW50UGFpcnNbaV1bMF1bMF0gKiBtdWx0aXBsaWVyLHRhbmdlbnRQYWlyc1tpXVswXVsxXSAqIG11bHRpcGxpZXJdKTtcbiAgICAvLyAgICAgdmFyIHRwbTIgPSB0dXJmLnBvaW50KFt0YW5nZW50UGFpcnNbaV1bMV1bMF0gKiBtdWx0aXBsaWVyLHRhbmdlbnRQYWlyc1tpXVsxXVsxXSAqIG11bHRpcGxpZXJdKTtcbiAgICAvLyAgICAgaWYodHVyZi5ib29sZWFuUG9pbnRJblBvbHlnb24odHBtMiwgdHVyZlBvbHlnb25zW2ldKSlcbiAgICAvLyAgICAgICBjb250aW51ZVxuXG4gICAgLy8gICAgIHZhciBmZWF0dXJlcyA9IHR1cmYucG9seWdvblRhbmdlbnRzKHRwbTEsIHR1cmZQb2x5Z29uc1tqXSkuZmVhdHVyZXNcbiAgICAvLyAgICAgdmFyIHQxID0gbmV3IFBvaW50KFtmZWF0dXJlc1swXS5nZW9tZXRyeS5jb29yZGluYXRlc1swXS9tdWx0aXBsaWVyLCBmZWF0dXJlc1swXS5nZW9tZXRyeS5jb29yZGluYXRlc1sxXS9tdWx0aXBsaWVyXSlcbiAgICAvLyAgICAgdmFyIHQyID0gbmV3IFBvaW50KFtmZWF0dXJlc1sxXS5nZW9tZXRyeS5jb29yZGluYXRlc1swXS9tdWx0aXBsaWVyLCBmZWF0dXJlc1sxXS5nZW9tZXRyeS5jb29yZGluYXRlc1sxXS9tdWx0aXBsaWVyXSlcbiAgICAvLyAgICAgdmFyIGFuZ2xlMSA9IHAxLmFuZ2xlVG9Qb2ludCh0MSlcbiAgICAvLyAgICAgdmFyIGFuZ2xlMiA9IHAxLmFuZ2xlVG9Qb2ludCh0MilcbiAgICAvLyAgICAgdmFyIGRpZmYgPSBhbmdsZTEgLSBhbmdsZTJcbiAgICAvLyAgICAgZGlmZiA9IGRpZmYgPCAwID8gZGlmZiArIE1hdGguUEkgOiBkaWZmXG5cbiAgICAvLyAgICAgLy8gZW5zdXJlIGFuZ2xlMiBpcyB0aGUgbGVmdCBvbmVcbiAgICAvLyAgICAgaWYoZGlmZiA+IE1hdGguUEkvMil7XG4gICAgLy8gICAgICAgdmFyIHRlbXAgPSBhbmdsZTFcbiAgICAvLyAgICAgICBhbmdsZTEgPSBhbmdsZTJcbiAgICAvLyAgICAgICBhbmdsZTIgPSB0ZW1wXG4gICAgLy8gICAgIH1cblxuICAgIC8vICAgICB2YXIgZGlmZjEgPSBhbmdsZTEgLSBhbmdsZVxuICAgIC8vICAgICBkaWZmMSA9IGRpZmYxIDwgMCA/IGRpZmYxICsgTWF0aC5QSSA6IGRpZmYxXG5cbiAgICAvLyAgICAgdmFyIGRpZmYyID0gYW5nbGUgLSBhbmdsZTJcbiAgICAvLyAgICAgZGlmZjIgPSBkaWZmMiA8IDAgPyBkaWZmMiArIE1hdGguUEkgOiBkaWZmMlxuXG4gICAgLy8gICAgIC8vIGFuZ2xlIGlzIGJldHdlZW4gYW5nbGUxIGFuZCBhbmdsZTJcbiAgICAvLyAgICAgaWYoZGlmZjEgPCBNYXRoLlBJLzIgJiYgZGlmZjIgPCBNYXRoLlBJLzIpe1xuICAgIC8vICAgICAgIGNvbnN0IGRpc3QgPSBjYWxjRWRnZURpc3RhbmNlKHAxLCBwMilcbiAgICAvLyAgICAgICBjb25zdCBkaXN0MSA9IGNhbGNFZGdlRGlzdGFuY2UocDEsIHQxKVxuICAgIC8vICAgICAgIGNvbnN0IGRpc3QyID0gY2FsY0VkZ2VEaXN0YW5jZShwMSwgdDIpXG5cbiAgICAvLyAgICAgICAvLyBpZiBib3RoIHRhbmdlbnRzIGFyZSBjbG9zZXJcbiAgICAvLyAgICAgICBpZihkaXN0MTxkaXN0ICYmIGRpc3QyPGRpc3Qpe1xuICAgIC8vICAgICAgICAgaXNWaXNpYmxlID0gZmFsc2VcbiAgICAvLyAgICAgICAgIGJyZWFrO1xuICAgIC8vICAgICAgIH1cbiAgICAvLyAgICAgfVxuICAgIC8vICAgfVxuXG4gICAgLy8gICBpZihpc1Zpc2libGUpXG4gICAgICAgIC8vIG91dHB1dCArPSAnLHtcImZyb21JZFwiOlwiJytjcmVhdGVOb2RlSWQobmVhcmVzdFN0YXJ0KSsnXCIsXCJ0b0lkXCI6XCInK2NyZWF0ZU5vZGVJZChuZWFyZXN0RW5kKSsnXCJ9J1xuICAgIC8vIH1cbiAgfVxuXG5cblxuXG4gIC8vIHZhciBtMSA9IEwubWFya2VyKFt0YW5nZW50UGFpcnNbMF1bMF1bMF0sdGFuZ2VudFBhaXJzWzBdWzBdWzFdLCB7XG4gIC8vICAgZHJhZ2dhYmxlOiB0cnVlLFxuICAvLyAgIGljb246IG5ldyBMLk51bWJlcmVkRGl2SWNvbigpXG4gIC8vIH0pXG5cbiAgLy8gdmFyIG0yID0gTC5tYXJrZXIodGFuZ2VudFBhaXJzWzBdWzFdWzBdLHRhbmdlbnRQYWlyc1swXVsxXVsxXSwge1xuICAvLyAgIGRyYWdnYWJsZTogdHJ1ZSxcbiAgLy8gICBpY29uOiBuZXcgTC5OdW1iZXJlZERpdkljb24oKVxuICAvLyB9KVxuXG5cblxuXG4gIC8vIHJvdXRlTGF5ZXIuc2V0TGF0TG5ncyhbXSlcbiAgLy8gdmFyIG5lYXJlc3RTdGFydCA9IHR1cmYubmVhcmVzdFBvaW50KHQxLCBwb2ludHMpXG4gIC8vIHZhciBuZWFyZXN0RW5kID0gdHVyZi5uZWFyZXN0UG9pbnQodDIsIHBvaW50cylcbiAgLy8gZm91bmRQYXRoID0gcGF0aEZpbmRlci5maW5kKGNyZWF0ZU5vZGVJZChuZWFyZXN0U3RhcnQpLCBjcmVhdGVOb2RlSWQobmVhcmVzdEVuZCkpXG4gIC8vIGRyYXdQYXRoKClcblxuXG5cblxuXG5cblxuICAvLyB2YXIgdGFuZ2VudHMyID0gW1tmZWF0dXJlc1swXS5nZW9tZXRyeS5jb29yZGluYXRlc1swXS9tdWx0aXBsaWVyLCBmZWF0dXJlc1swXS5nZW9tZXRyeS5jb29yZGluYXRlc1sxXS9tdWx0aXBsaWVyXSwgXG4gIC8vICAgICAgICAgICAgICAgICAgIFtmZWF0dXJlc1sxXS5nZW9tZXRyeS5jb29yZGluYXRlc1swXS9tdWx0aXBsaWVyLCBmZWF0dXJlc1sxXS5nZW9tZXRyeS5jb29yZGluYXRlc1sxXS9tdWx0aXBsaWVyXV1cblxuXG5cblxuXG4gIC8vIHZhciBwb2ludCA9IHR1cmYucG9pbnQoW01hdGgucm91bmQodGFuZ2VudHMyWzBdWzBdICogbXVsdGlwbGllciksIE1hdGgucm91bmQodGFuZ2VudHMyWzBdWzFdICogbXVsdGlwbGllcildKTtcbiAgLy8gdmFyIGZlYXR1cmVzID0gdHVyZi5wb2x5Z29uVGFuZ2VudHMocG9pbnQsIHBvbHlnb24xKVxuICAvLyB2YXIgdGFuZ2VudHMxID0gW1tmZWF0dXJlc1swXS5nZW9tZXRyeS5jb29yZGluYXRlc1swXS9tdWx0aXBsaWVyLCBmZWF0dXJlc1swXS5nZW9tZXRyeS5jb29yZGluYXRlc1sxXS9tdWx0aXBsaWVyXSwgXG4gIC8vICAgICAgICAgICAgICAgICAgIFtmZWF0dXJlc1sxXS5nZW9tZXRyeS5jb29yZGluYXRlc1swXS9tdWx0aXBsaWVyLCBmZWF0dXJlc1sxXS5nZW9tZXRyeS5jb29yZGluYXRlc1sxXS9tdWx0aXBsaWVyXV1cblxuXG5cblxuXG5cblxuICAvLyBzdGFydE1hcmtlciA9IEwubWFya2VyKFsgYVswXS54LCBhWzBdLnldLCB7XG4gIC8vICAgZHJhZ2dhYmxlOiB0cnVlLFxuICAvLyAgIGljb246IG5ldyBMLk51bWJlcmVkRGl2SWNvbigpXG4gIC8vIH0pLmFkZFRvKG1hcClcblxuICAvLyB2YXIgdGFuZ2VudCA9IFsgdGFuZ2VudHMuZmVhdHVyZXNbMF0uZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0vbXVsdGlwbGllciwgdGFuZ2VudHMuZmVhdHVyZXNbMF0uZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV0vbXVsdGlwbGllcl1cblxuICAvLyBlbmRNYXJrZXIgPSBMLm1hcmtlcih0YW5nZW50LCB7XG4gIC8vICAgZHJhZ2dhYmxlOiB0cnVlLFxuICAvLyAgIGljb246IG5ldyBMLk51bWJlcmVkRGl2SWNvbigpXG4gIC8vIH0pLmFkZFRvKG1hcClcblxuICAvLyB2YXIgbmVhcmVzdFN0YXJ0ID0gdHVyZi5uZWFyZXN0UG9pbnQoc3RhcnRNYXJrZXIudG9HZW9KU09OKCksIHBvaW50cylcbiAgLy8gdmFyIG5lYXJlc3RFbmQgPSB0dXJmLm5lYXJlc3RQb2ludChlbmRNYXJrZXIudG9HZW9KU09OKCksIHBvaW50cylcbiAgLy8gZm91bmRQYXRoID0gcGF0aEZpbmRlci5maW5kKGNyZWF0ZU5vZGVJZChuZWFyZXN0U3RhcnQpLCBjcmVhdGVOb2RlSWQobmVhcmVzdEVuZCkpXG4gIC8vIGRyYXdQYXRoKClcblxuXG4gIC8vIGNvbnNvbGUubG9nKGFbMF0ueCArIFwiLFwiICsgYVswXS55ICsgXCIgXCIgKyB0YW5nZW50WzBdICsgXCIsXCIgKyB0YW5nZW50WzFdKVxuICAvLyBjb25zb2xlLmxvZygnJylcblxuXG5cblxuXG5cblxuXG5cblxuICAgIC8vIC8vIG4xIC0+IG51bWJlciBvZiBwb2ludHMgaW4gcG9seWdvbiBhIFxuICAgIC8vIC8vIG4yIC0+IG51bWJlciBvZiBwb2ludHMgaW4gcG9seWdvbiBiIFxuICAgIC8vIHZhciBuMSA9IGEubGVuZ3RoLCBuMiA9IGIubGVuZ3RoOyBcbiAgXG4gICAgLy8gLy8gVG8gZmluZCBhIHBvaW50IGluc2lkZSB0aGUgY29udmV4IHBvbHlnb24oY2VudHJvaWQpLCBcbiAgICAvLyAvLyB3ZSBzdW0gdXAgYWxsIHRoZSBjb29yZGluYXRlcyBhbmQgdGhlbiBkaXZpZGUgIGJ5IFxuICAgIC8vIC8vIG4obnVtYmVyIG9mIHBvaW50cykuIEJ1dCB0aGlzIHdvdWxkIGJlIGEgZmxvYXRpbmctcG9pbnQgXG4gICAgLy8gLy8gdmFsdWUuIFNvIHRvIGdldCByaWQgb2YgdGhpcyB3ZSBtdWx0aXBseSBwb2ludHMgXG4gICAgLy8gLy8gaW5pdGlhbGx5IHdpdGggbjEgYW5kIHRoZW4gZmluZCB0aGUgY2VudHJlIGFuZCBcbiAgICAvLyAvLyB0aGVuIGRpdmlkZWQgaXQgYnkgbjEgYWdhaW4uIFxuICAgIC8vIC8vIFNpbWlsYXJseSB3ZSBkbyBkaXZpZGUgYW5kIG11bHRpcGx5IGZvciBuMiAoaS5lLiwgXG4gICAgLy8gLy8gZWxlbWVudHMgb2YgYikgXG4gIFxuICAgIC8vIC8vIG1heGEgYW5kIG1pbmIgYXJlIHVzZWQgdG8gY2hlY2sgaWYgcG9seWdvbiBhIFxuICAgIC8vIC8vIGlzIGxlZnQgb2YgYi4gXG4gICAgLy8gdmFyIG1heGEgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjsgXG4gICAgLy8gZm9yICh2YXIgaT0wOyBpPG4xOyBpKyspIFxuICAgIC8vIHsgXG4gICAgLy8gICAgIG1heGEgPSBNYXRoLm1heChtYXhhLCBhW2ldLngpOyBcbiAgICAvLyAgICAgbWlkLnggICs9IGFbaV0ueDtcbiAgICAvLyAgICAgbWlkLnkgKz0gYVtpXS55OyBcbiAgICAvLyAgICAgYVtpXS54ICo9IG4xOyBcbiAgICAvLyAgICAgYVtpXS55ICo9IG4xOyBcbiAgICAvLyB9IFxuICBcbiAgICAvLyAvLyBzb3J0aW5nIHRoZSBwb2ludHMgaW4gY291bnRlciBjbG9ja3dpc2Ugb3JkZXIgXG4gICAgLy8gLy8gZm9yIHBvbHlnb24gYSBcbiAgICAvLyBjb25zdCBjbG9uZWRBID0gY2xvbmVQb2ludHMoYSlcbiAgICAvLyBzb3J0UG9pbnRzKGFbMF0sIGNsb25lZEEpXG4gICAgLy8gYSA9IGNsb25lZEFcbiAgXG4gICAgLy8gZm9yICh2YXIgaT0wOyBpPG4xOyBpKyspIFxuICAgIC8vIHsgXG4gICAgLy8gICAgIGFbaV0ueCAvPSBuMTsgXG4gICAgLy8gICAgIGFbaV0ueSAvPSBuMTsgXG4gICAgLy8gfSBcbiAgXG4gICAgLy8gbWlkID0gbmV3IFBvaW50KFswLDBdKVxuICBcbiAgICAvLyB2YXIgbWluYiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSOyBcbiAgICAvLyBmb3IgKHZhciBpPTA7IGk8bjI7IGkrKykgXG4gICAgLy8geyBcbiAgICAvLyAgICAgbWlkLnggKz0gYltpXS54OyBcbiAgICAvLyAgICAgbWlkLnkgKz0gYltpXS55OyBcbiAgICAvLyAgICAgbWluYiA9IE1hdGgubWluKG1pbmIsIGJbaV0ueCk7IFxuICAgIC8vICAgICBiW2ldLnggKj0gbjI7IFxuICAgIC8vICAgICBiW2ldLnkgKj0gbjI7IFxuICAgIC8vIH0gXG4gIFxuICAgIC8vIC8vIHNvcnRpbmcgdGhlIHBvaW50cyBpbiBjb3VudGVyIGNsb2Nrd2lzZSBcbiAgICAvLyAvLyBvcmRlciBmb3IgcG9seWdvbiBiIFxuICAgIC8vIGNvbnN0IGNsb25lZEIgPSBjbG9uZVBvaW50cyhiKVxuICAgIC8vIHNvcnRQb2ludHMoYlswXSwgY2xvbmVkQilcbiAgICAvLyBiID0gY2xvbmVkQlxuICBcbiAgICAvLyBmb3IgKHZhciBpPTA7IGk8bjI7IGkrKykgXG4gICAgLy8geyBcbiAgICAvLyAgICAgYltpXS54Lz1uMjsgXG4gICAgLy8gICAgIGJbaV0ueS89bjI7IFxuICAgIC8vIH0gXG4gIFxuICAgIC8vIC8vIElmIGEgaXMgdG8gdGhlIHJpZ2h0IG9mIGIsIHN3YXAgYSBhbmQgYiBcbiAgICAvLyAvLyBUaGlzIG1ha2VzIHN1cmUgYSBpcyBsZWZ0IG9mIGIuIFxuICAgIC8vIGlmIChtaW5iIDwgbWF4YSkgXG4gICAgLy8geyBcbiAgICAvLyAgICAgYiA9IFthLCBhID0gYl1bMF07ICAvLyBzd2FwIGEgYW5kIGIgICAgXG4gICAgLy8gICAgIG4xID0gYS5sZW5ndGg7XG4gICAgLy8gICAgIG4yID0gYi5sZW5ndGg7XG4gICAgLy8gfSBcbiAgXG4gICAgLy8gLy8gaWEgLT4gcmlnaHRtb3N0IHBvaW50IG9mIGEgXG4gICAgLy8gdmFyIGlhID0gMCwgaWIgPSAwOyBcbiAgICAvLyBmb3IgKHZhciBpPTE7IGk8bjE7IGkrKykgXG4gICAgLy8gICAgIGlmIChhW2ldLnggPiBhW2lhXS54KSBcbiAgICAvLyAgICAgICAgIGlhID0gaTsgXG4gIFxuICAgIC8vIC8vIGliIC0+IGxlZnRtb3N0IHBvaW50IG9mIGIgXG4gICAgLy8gZm9yICh2YXIgaT0xOyBpPG4yOyBpKyspIFxuICAgIC8vICAgICBpZiAoYltpXS54IDwgYltpYl0ueCkgXG4gICAgLy8gICAgICAgICBpYj1pOyBcbiAgXG4gICAgLy8gLy8gZmluZGluZyB0aGUgdXBwZXIgdGFuZ2VudCBcbiAgICAvLyB2YXIgaW5kYSA9IGlhLCBpbmRiID0gaWI7IFxuICAgIC8vIHZhciBkb25lID0gMDsgXG4gICAgLy8gd2hpbGUgKCFkb25lKSBcbiAgICAvLyB7IFxuICAgIC8vICAgICBkb25lID0gMTsgXG4gICAgLy8gICAgIC8vIGNvbnN0IGcgPSBjcmVhdGVHcmFwaCgpXG4gICAgLy8gICAgIC8vIGcuYWRkTm9kZShjcmVhdGVOb2RlSWQyKGJbaW5kYl0pLCB7IHg6IGJbaW5kYl0ueCwgeTogYltpbmRiXS55IH0pXG4gICAgLy8gICAgIC8vIGcuYWRkTm9kZShjcmVhdGVOb2RlSWQyKGFbaW5kYV0pLCB7IHg6IGFbaW5kYV0ueCwgeTogYVtpbmRhXS55IH0pXG4gICAgLy8gICAgIC8vIGcuYWRkTm9kZShjcmVhdGVOb2RlSWQyKGFbKGluZGErMSklbjFdKSwgeyB4OiBhWyhpbmRhKzEpJW4xXS54LCB5OiBhWyhpbmRhKzEpJW4xXS55IH0pXG4gICAgLy8gICAgIC8vIGcuYWRkTGluayhjcmVhdGVOb2RlSWQyKGJbaW5kYl0pLCBjcmVhdGVOb2RlSWQyKGFbaW5kYV0pKVxuICAgIC8vICAgICAvLyBnLmFkZExpbmsoY3JlYXRlTm9kZUlkMihhW2luZGFdKSwgY3JlYXRlTm9kZUlkMihhWyhpbmRhKzEpJW4xXSkpXG4gICAgLy8gICAgIC8vIHNldEdyYXBoKGcpXG4gICAgLy8gICAgIC8vIHJvdXRlTGF5ZXIuc2V0TGF0TG5ncyhbYltpbmRiXSwgYVtpbmRhXV0pXG4gICAgLy8gICAgIC8vIGRyYXdQYXRoKClcblxuICAgIC8vICAgICAvLyByb3V0ZUxheWVyLnNldExhdExuZ3MoW10pXG5cblxuICAgIC8vICAgICB3aGlsZSAob3JpZW50YXRpb24oYltpbmRiXSwgYVtpbmRhXSwgYVsoaW5kYSsxKSVuMV0pID4gMCkgXG4gICAgLy8gICAgICAgICBpbmRhID0gKGluZGEgKyAxKSAlIG4xOyBcbiAgXG4gICAgLy8gICAgIHdoaWxlIChvcmllbnRhdGlvbihhW2luZGFdLCBiW2luZGJdLCBiWyhuMitpbmRiLTEpJW4yXSkgPCAwKSBcbiAgICAvLyAgICAgeyBcbiAgICAvLyAgICAgICAgIGluZGIgPSAobjIraW5kYi0xKSVuMjsgXG4gICAgLy8gICAgICAgICBkb25lID0gMDsgXG4gICAgLy8gICAgIH0gXG4gICAgLy8gfSBcbiAgICAvLyBjb25zb2xlLmxvZyhhW2luZGFdLnggKyBcIixcIiArIGFbaW5kYV0ueSlcbiAgXG4gICAgLy8gLy8gY291dCA8PCBcInVwcGVyIHRhbmdlbnQgKFwiIDw8IGFbaW5kYV0ueCA8PCBcIixcIlxuICAgIC8vIC8vICAgICA8PCBhW2luZGFdLnkgPDwgXCIpIChcIiA8PCBiW2luZGJdLnggXG4gICAgLy8gLy8gICAgIDw8IFwiLFwiIDw8IGJbaW5kYl0ueSA8PCBcIilcXG5cIjsgXG59IFxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVJZDIgKHApIHtcbiAgICByZXR1cm4gcC54ICsgJywnICsgcC55XG4gIH1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyR3JhcGhSZWxhdGVkRGF0YSAoKSB7XG4gIGlmIChyb3V0ZUxheWVyICE9PSBudWxsKSByb3V0ZUxheWVyLnNldExhdExuZ3MoW10pXG4gIGlmIChzZWxlY3Rpb25MYXllciAhPT0gbnVsbCkgc2VsZWN0aW9uTGF5ZXIuY2xlYXJMYXllcnMoKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0dXBSb3V0ZUxheWVyICgpIHtcbiAgcm91dGVMYXllciA9IEwucG9seWxpbmUoW10sIHtcbiAgICBjb2xvcjogJyNFQjMyMjMnXG4gIH0pLmFkZFRvKG1hcClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldFBhdGhGaW5kZXIgKHBhdGhHcmFwaCkge1xuICBwYXRoRmluZGVyID0gcGF0aEdyYXBoXG4gIHJldHVybiB1cGRhdGVQYXRoTWFya2VycygpXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVBhdGhNYXJrZXJzICgpIHtcbiAgaWYodXBkYXRpbmdQYXRoTWFya2Vycyl7XG4gICAgdXBkYXRpbmdQYXRoTWFya2VycyA9IDBcbiAgICByZXR1cm5cbiAgfVxuXG4gIHVwZGF0aW5nUGF0aE1hcmtlcnMgPSB0cnVlXG4gIC8vIGNvbnN0IHN0YXJ0Q3JlYXRpb24gPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KClcblxuICBpZihyb3V0ZUxheWVyICE9IG51bGwpXG4gICAgcm91dGVMYXllci5zZXRMYXRMbmdzKFtdKVxuICByZXN0b3JlT3JpZ2luYWxQb2ludHNBbmRFZGdlcygpXG5cbiAgaWYocm91dGVMYXllciAhPSBudWxsKXtcbiAgICBzdGFydFBvaW50ID0gbmV3IFBvaW50KFtzdGFydE1hcmtlci50b0dlb0pTT04oKS5nZW9tZXRyeS5jb29yZGluYXRlc1swXSwgc3RhcnRNYXJrZXIudG9HZW9KU09OKCkuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV1dKTtcbiAgICBlbmRQb2ludCA9IG5ldyBQb2ludChbZW5kTWFya2VyLnRvR2VvSlNPTigpLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdLCBlbmRNYXJrZXIudG9HZW9KU09OKCkuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV1dKTtcbiAgfVxuXG4gIHZhciBkeW5hbWljTm9kZXNKU09OID0gZ2V0RHluYW1pY05vZGVzSlNPTihzdGFydFBvaW50LCBlbmRQb2ludClcbiAgdmFyIGR5bmFtaWNFZGdlc0pTT04gPSBnZXREeW5hbWljRWRnZXNKU09OKHN0YXJ0UG9pbnQsIGVuZFBvaW50KVxuICB1cGRhdGVHcmFwaFdpdGhEeW5hbWljSlNPTihkeW5hbWljTm9kZXNKU09OLCBkeW5hbWljRWRnZXNKU09OKVxuXG4gIGlmKHJvdXRlTGF5ZXIgIT0gbnVsbCl7XG4gICAgdmFyIG5lYXJlc3RTdGFydCA9IHR1cmYubmVhcmVzdFBvaW50KHN0YXJ0TWFya2VyLnRvR2VvSlNPTigpLCBwb2ludHMpXG4gICAgdmFyIG5lYXJlc3RFbmQgPSB0dXJmLm5lYXJlc3RQb2ludChlbmRNYXJrZXIudG9HZW9KU09OKCksIHBvaW50cylcbiAgICBuZWFyZXN0U3RhcnQgPSBzdGFydE1hcmtlci50b0dlb0pTT04oKVxuICAgIG5lYXJlc3RFbmQgPSBlbmRNYXJrZXIudG9HZW9KU09OKClcbiAgICBmb3VuZFBhdGggPSBwYXRoRmluZGVyLmZpbmQoY3JlYXRlTm9kZUlkKG5lYXJlc3RTdGFydCksIGNyZWF0ZU5vZGVJZChuZWFyZXN0RW5kKSlcbiAgICBkcmF3UGF0aCgpXG4gIH1lbHNle1xuICAgIGZvdW5kUGF0aCA9IHBhdGhGaW5kZXIuZmluZChjcmVhdGVOb2RlSWQyKHN0YXJ0UG9pbnQpLCBjcmVhdGVOb2RlSWQyKGVuZFBvaW50KSlcbiAgfVxuICBjb25zb2xlLmxvZyhcIlxcdHZhciBzdGFydCA9IFtcIitjcmVhdGVOb2RlSWQyKHN0YXJ0UG9pbnQpK1wiXVxcblxcdHZhciBlbmQgPSBbXCIrY3JlYXRlTm9kZUlkMihlbmRQb2ludCkrXCJdXFxuXFxuXCIpXG5cbiAgLy8gY29uc3QgZW5kQ3JlYXRpb24gPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KClcbiAgLy8gY29uc3QgdGltZVRha2VuVG9DcmVhdGUgPSBwYXJzZUludChlbmRDcmVhdGlvbiAtIHN0YXJ0Q3JlYXRpb24pXG4gIC8vIGNvbnNvbGUubG9nKCdUaW1lIHRvIGZpbmQgcGF0aDogJywgdGltZVRha2VuVG9DcmVhdGUpXG5cbiAgdXBkYXRpbmdQYXRoTWFya2VycyA9IGZhbHNlXG5cbiAgcmV0dXJuIGZvdW5kUGF0aFxufVxuXG5mdW5jdGlvbiBkcmF3UGF0aCAoKSB7XG4gIGNvbnN0IHBhdGhMYXRMbmdzID0gZm91bmRQYXRoLm1hcChmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBbbm9kZS5kYXRhLnksIG5vZGUuZGF0YS54XVxuICB9KVxuICByb3V0ZUxheWVyLnNldExhdExuZ3MocGF0aExhdExuZ3MpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVJZCAocCkge1xuICByZXR1cm4gcC5nZW9tZXRyeS5jb29yZGluYXRlc1swXSArICcsJyArIHAuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV1cbn1cblxuZnVuY3Rpb24gdW5oaWdobGlnaHRGZWF0dXJlICgpIHtcbiAgc2VsZWN0aW9uTGF5ZXIuY2xlYXJMYXllcnMoKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0R3JhcGggKGdkKSB7XG4gIGdyYXBoRGF0YSA9IGdkXG59XG5cbmZ1bmN0aW9uIGhpZ2hsaWdodEZlYXR1cmUgKGUpIHtcbiAgc2VsZWN0aW9uTGF5ZXIuY2xlYXJMYXllcnMoKVxuXG4gIGNvbnN0IG5vZGUgPSBncmFwaERhdGEuZ2V0Tm9kZShlLnRhcmdldC5fbGF0bG5nLmxuZyArICcsJyArIGUudGFyZ2V0Ll9sYXRsbmcubGF0KVxuXG4gIGdyYXBoRGF0YS5mb3JFYWNoTGlua2VkTm9kZShlLnRhcmdldC5fbGF0bG5nLmxuZyArICcsJyArIGUudGFyZ2V0Ll9sYXRsbmcubGF0LCBmdW5jdGlvbiAobGlua2VkTm9kZSwgbGluaykge1xuICAgIEwucG9seWxpbmUoW1tsaW5rZWROb2RlLmRhdGEueSwgbGlua2VkTm9kZS5kYXRhLnhdLCBbbm9kZS5kYXRhLnksIG5vZGUuZGF0YS54XV0sIHtcbiAgICAgIHdlaWdodDogMC41LFxuICAgICAgb3BhY2l0eTogMC44LFxuICAgICAgcGFuZTogJ3NoYWRvd1BhbmUnLFxuICAgICAgaW50ZXJhY3RpdmU6IGZhbHNlXG4gICAgfSkuYWRkVG8oc2VsZWN0aW9uTGF5ZXIpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU51bWJlckRpdiAoKSB7XG4gIHJldHVybiBMLkljb24uZXh0ZW5kKHtcbiAgICBvcHRpb25zOiB7XG4gICAgICBpY29uU2l6ZTogbmV3IEwuUG9pbnQoMTUsIDE1KSxcbiAgICAgIGNsYXNzTmFtZTogJ2xlYWZsZXQtZGl2LWljb24nXG4gICAgfSxcbiAgICBjcmVhdGVJY29uOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgIHZhciBudW1kaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgbnVtZGl2LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnbnVtYmVyJylcbiAgICAgIG51bWRpdi5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnNbJ251bWJlciddIHx8ICcnXG4gICAgICBkaXYuYXBwZW5kQ2hpbGQobnVtZGl2KVxuICAgICAgdGhpcy5fc2V0SWNvblN0eWxlcyhkaXYsICdpY29uJylcbiAgICAgIHJldHVybiBkaXZcbiAgICB9XG4gIH0pXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/mapHelpers.js\n");

/***/ }),

/***/ "./src/setupStructure.js":
/*!*******************************!*\
  !*** ./src/setupStructure.js ***!
  \*******************************/
/*! exports provided: setupStructure */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setupStructure\", function() { return setupStructure; });\n/* harmony import */ var _Point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Point */ \"./src/Point.js\");\n/* harmony import */ var _Edge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Edge */ \"./src/Edge.js\");\n\n\n\nfunction setupStructure (coords, edges, points, polygons, polygonId) {\n  // const geom = geojson.type === 'Feature' ? geojson.geometry : geojson\n\n  // let coords = geom.coordinates\n\n  // // standardise the input\n  // if (geom.type === 'Polygon') coords = [coords]\n\n  coords = [coords]\n\n  for (let i = 0; i < coords.length; i++) {\n    const contour = []\n    polygons.push(contour)\n\n    if(coords[i] == undefined)\n      continue\n\n    for (let ii = 0; ii < coords[i].geometry.coordinates.length; ii++) {\n      let prevPoint = new _Point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"](coords[i].geometry.coordinates[ii][0], polygonId)\n      let currentPoint = new _Point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"](coords[i].geometry.coordinates[ii][1], polygonId)\n      prevPoint.nextPoint = currentPoint\n      let nextPoint = new _Point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"](coords[i].geometry.coordinates[ii][2], polygonId)\n      linkPoints(prevPoint, currentPoint, nextPoint)\n\n      points.push(prevPoint)\n\n      let prevEdge = new _Edge__WEBPACK_IMPORTED_MODULE_1__[\"Edge\"](prevPoint, currentPoint) // eslint-disable-line\n      edges.push(prevEdge)\n      contour.push(prevEdge)\n\n      // Save me for later\n      const firstPoint = prevPoint\n\n      prevPoint = currentPoint\n      currentPoint = nextPoint\n\n      for (let iii = 2; iii < coords[i].geometry.coordinates[ii].length - 2; iii++) {\n        points.push(prevPoint)\n\n        nextPoint = new _Point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"](coords[i].geometry.coordinates[ii][iii + 1], polygonId)\n\n        linkPoints(prevPoint, currentPoint, nextPoint)\n\n        const e = new _Edge__WEBPACK_IMPORTED_MODULE_1__[\"Edge\"](prevPoint, currentPoint) // eslint-disable-line\n\n        edges.push(e)\n        contour.push(e)\n\n        prevPoint = currentPoint\n        currentPoint = nextPoint\n        prevEdge = e\n      }\n\n      linkPoints(prevPoint, currentPoint, firstPoint)\n\n      const secondLastEdge = new _Edge__WEBPACK_IMPORTED_MODULE_1__[\"Edge\"](prevEdge.p2, currentPoint)\n\n      edges.push(secondLastEdge)\n      contour.push(secondLastEdge)\n\n      const lastEdge = new _Edge__WEBPACK_IMPORTED_MODULE_1__[\"Edge\"](currentPoint, firstPoint) // eslint-disable-line\n      linkPoints(currentPoint, firstPoint, firstPoint.nextPoint)\n\n      edges.push(lastEdge)\n      contour.push(lastEdge)\n\n      points.push(prevPoint)\n      points.push(nextPoint)\n    }\n  }\n}\n\n// export function setupStructure (coords, edges, points, polygons, polygonId) {\n//   // const geom = geojson.type === 'Feature' ? geojson.geometry : geojson\n\n//   // let coords = geom.coordinates\n\n//   // // standardise the input\n//   // if (geom.type === 'Polygon') coords = [coords]\n\n//   coords = [coords]\n\n//   for (let i = 0; i < coords.length; i++) {\n//     const contour = []\n//     polygons.push(contour)\n\n//     if(coords[i] == undefined)\n//       continue\n\n//     for (let ii = 0; ii < coords[i].length; ii++) {\n//       let prevPoint = new Point(coords[i][ii][0], polygonId)\n//       let currentPoint = new Point(coords[i][ii][1], polygonId)\n//       prevPoint.nextPoint = currentPoint\n//       let nextPoint = new Point(coords[i][ii][2], polygonId)\n//       linkPoints(prevPoint, currentPoint, nextPoint)\n\n//       points.push(prevPoint)\n\n//       let prevEdge = new Edge(prevPoint, currentPoint) // eslint-disable-line\n//       edges.push(prevEdge)\n//       contour.push(prevEdge)\n\n//       // Save me for later\n//       const firstPoint = prevPoint\n\n//       prevPoint = currentPoint\n//       currentPoint = nextPoint\n\n//       for (let iii = 2; iii < coords[i][ii].length - 2; iii++) {\n//         points.push(prevPoint)\n\n//         nextPoint = new Point(coords[i][ii][iii + 1], polygonId)\n\n//         linkPoints(prevPoint, currentPoint, nextPoint)\n\n//         const e = new Edge(prevPoint, currentPoint) // eslint-disable-line\n\n//         edges.push(e)\n//         contour.push(e)\n\n//         prevPoint = currentPoint\n//         currentPoint = nextPoint\n//         prevEdge = e\n//       }\n\n//       linkPoints(prevPoint, currentPoint, firstPoint)\n\n//       const secondLastEdge = new Edge(prevEdge.p2, currentPoint)\n\n//       edges.push(secondLastEdge)\n//       contour.push(secondLastEdge)\n\n//       const lastEdge = new Edge(currentPoint, firstPoint) // eslint-disable-line\n//       linkPoints(currentPoint, firstPoint, firstPoint.nextPoint)\n\n//       edges.push(lastEdge)\n//       contour.push(lastEdge)\n\n//       points.push(prevPoint)\n//       points.push(nextPoint)\n//     }\n//   }\n// }\n\nfunction linkPoints (prevPoint, currentPoint, nextPoint) {\n  currentPoint.prevPoint = prevPoint\n  currentPoint.nextPoint = nextPoint\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2V0dXBTdHJ1Y3R1cmUuanM/NDFhNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUErQjtBQUNGOztBQUV0QjtBQUNQOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLDRDQUE0QztBQUNoRSwwQkFBMEIsNENBQUs7QUFDL0IsNkJBQTZCLDRDQUFLO0FBQ2xDO0FBQ0EsMEJBQTBCLDRDQUFLO0FBQy9COztBQUVBOztBQUVBLHlCQUF5QiwwQ0FBSTtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIscURBQXFEO0FBQzVFOztBQUVBLHdCQUF3Qiw0Q0FBSzs7QUFFN0I7O0FBRUEsc0JBQXNCLDBDQUFJOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlDQUFpQywwQ0FBSTs7QUFFckM7QUFDQTs7QUFFQSwyQkFBMkIsMENBQUk7QUFDL0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQkFBMEIsZ0NBQWdDO0FBQzFEOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL3NyYy9zZXR1cFN0cnVjdHVyZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi9Qb2ludCdcbmltcG9ydCB7IEVkZ2UgfSBmcm9tICcuL0VkZ2UnXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXR1cFN0cnVjdHVyZSAoY29vcmRzLCBlZGdlcywgcG9pbnRzLCBwb2x5Z29ucywgcG9seWdvbklkKSB7XG4gIC8vIGNvbnN0IGdlb20gPSBnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlJyA/IGdlb2pzb24uZ2VvbWV0cnkgOiBnZW9qc29uXG5cbiAgLy8gbGV0IGNvb3JkcyA9IGdlb20uY29vcmRpbmF0ZXNcblxuICAvLyAvLyBzdGFuZGFyZGlzZSB0aGUgaW5wdXRcbiAgLy8gaWYgKGdlb20udHlwZSA9PT0gJ1BvbHlnb24nKSBjb29yZHMgPSBbY29vcmRzXVxuXG4gIGNvb3JkcyA9IFtjb29yZHNdXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjb250b3VyID0gW11cbiAgICBwb2x5Z29ucy5wdXNoKGNvbnRvdXIpXG5cbiAgICBpZihjb29yZHNbaV0gPT0gdW5kZWZpbmVkKVxuICAgICAgY29udGludWVcblxuICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCBjb29yZHNbaV0uZ2VvbWV0cnkuY29vcmRpbmF0ZXMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICBsZXQgcHJldlBvaW50ID0gbmV3IFBvaW50KGNvb3Jkc1tpXS5nZW9tZXRyeS5jb29yZGluYXRlc1tpaV1bMF0sIHBvbHlnb25JZClcbiAgICAgIGxldCBjdXJyZW50UG9pbnQgPSBuZXcgUG9pbnQoY29vcmRzW2ldLmdlb21ldHJ5LmNvb3JkaW5hdGVzW2lpXVsxXSwgcG9seWdvbklkKVxuICAgICAgcHJldlBvaW50Lm5leHRQb2ludCA9IGN1cnJlbnRQb2ludFxuICAgICAgbGV0IG5leHRQb2ludCA9IG5ldyBQb2ludChjb29yZHNbaV0uZ2VvbWV0cnkuY29vcmRpbmF0ZXNbaWldWzJdLCBwb2x5Z29uSWQpXG4gICAgICBsaW5rUG9pbnRzKHByZXZQb2ludCwgY3VycmVudFBvaW50LCBuZXh0UG9pbnQpXG5cbiAgICAgIHBvaW50cy5wdXNoKHByZXZQb2ludClcblxuICAgICAgbGV0IHByZXZFZGdlID0gbmV3IEVkZ2UocHJldlBvaW50LCBjdXJyZW50UG9pbnQpIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIGVkZ2VzLnB1c2gocHJldkVkZ2UpXG4gICAgICBjb250b3VyLnB1c2gocHJldkVkZ2UpXG5cbiAgICAgIC8vIFNhdmUgbWUgZm9yIGxhdGVyXG4gICAgICBjb25zdCBmaXJzdFBvaW50ID0gcHJldlBvaW50XG5cbiAgICAgIHByZXZQb2ludCA9IGN1cnJlbnRQb2ludFxuICAgICAgY3VycmVudFBvaW50ID0gbmV4dFBvaW50XG5cbiAgICAgIGZvciAobGV0IGlpaSA9IDI7IGlpaSA8IGNvb3Jkc1tpXS5nZW9tZXRyeS5jb29yZGluYXRlc1tpaV0ubGVuZ3RoIC0gMjsgaWlpKyspIHtcbiAgICAgICAgcG9pbnRzLnB1c2gocHJldlBvaW50KVxuXG4gICAgICAgIG5leHRQb2ludCA9IG5ldyBQb2ludChjb29yZHNbaV0uZ2VvbWV0cnkuY29vcmRpbmF0ZXNbaWldW2lpaSArIDFdLCBwb2x5Z29uSWQpXG5cbiAgICAgICAgbGlua1BvaW50cyhwcmV2UG9pbnQsIGN1cnJlbnRQb2ludCwgbmV4dFBvaW50KVxuXG4gICAgICAgIGNvbnN0IGUgPSBuZXcgRWRnZShwcmV2UG9pbnQsIGN1cnJlbnRQb2ludCkgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgICAgIGVkZ2VzLnB1c2goZSlcbiAgICAgICAgY29udG91ci5wdXNoKGUpXG5cbiAgICAgICAgcHJldlBvaW50ID0gY3VycmVudFBvaW50XG4gICAgICAgIGN1cnJlbnRQb2ludCA9IG5leHRQb2ludFxuICAgICAgICBwcmV2RWRnZSA9IGVcbiAgICAgIH1cblxuICAgICAgbGlua1BvaW50cyhwcmV2UG9pbnQsIGN1cnJlbnRQb2ludCwgZmlyc3RQb2ludClcblxuICAgICAgY29uc3Qgc2Vjb25kTGFzdEVkZ2UgPSBuZXcgRWRnZShwcmV2RWRnZS5wMiwgY3VycmVudFBvaW50KVxuXG4gICAgICBlZGdlcy5wdXNoKHNlY29uZExhc3RFZGdlKVxuICAgICAgY29udG91ci5wdXNoKHNlY29uZExhc3RFZGdlKVxuXG4gICAgICBjb25zdCBsYXN0RWRnZSA9IG5ldyBFZGdlKGN1cnJlbnRQb2ludCwgZmlyc3RQb2ludCkgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgbGlua1BvaW50cyhjdXJyZW50UG9pbnQsIGZpcnN0UG9pbnQsIGZpcnN0UG9pbnQubmV4dFBvaW50KVxuXG4gICAgICBlZGdlcy5wdXNoKGxhc3RFZGdlKVxuICAgICAgY29udG91ci5wdXNoKGxhc3RFZGdlKVxuXG4gICAgICBwb2ludHMucHVzaChwcmV2UG9pbnQpXG4gICAgICBwb2ludHMucHVzaChuZXh0UG9pbnQpXG4gICAgfVxuICB9XG59XG5cbi8vIGV4cG9ydCBmdW5jdGlvbiBzZXR1cFN0cnVjdHVyZSAoY29vcmRzLCBlZGdlcywgcG9pbnRzLCBwb2x5Z29ucywgcG9seWdvbklkKSB7XG4vLyAgIC8vIGNvbnN0IGdlb20gPSBnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlJyA/IGdlb2pzb24uZ2VvbWV0cnkgOiBnZW9qc29uXG5cbi8vICAgLy8gbGV0IGNvb3JkcyA9IGdlb20uY29vcmRpbmF0ZXNcblxuLy8gICAvLyAvLyBzdGFuZGFyZGlzZSB0aGUgaW5wdXRcbi8vICAgLy8gaWYgKGdlb20udHlwZSA9PT0gJ1BvbHlnb24nKSBjb29yZHMgPSBbY29vcmRzXVxuXG4vLyAgIGNvb3JkcyA9IFtjb29yZHNdXG5cbi8vICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcbi8vICAgICBjb25zdCBjb250b3VyID0gW11cbi8vICAgICBwb2x5Z29ucy5wdXNoKGNvbnRvdXIpXG5cbi8vICAgICBpZihjb29yZHNbaV0gPT0gdW5kZWZpbmVkKVxuLy8gICAgICAgY29udGludWVcblxuLy8gICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCBjb29yZHNbaV0ubGVuZ3RoOyBpaSsrKSB7XG4vLyAgICAgICBsZXQgcHJldlBvaW50ID0gbmV3IFBvaW50KGNvb3Jkc1tpXVtpaV1bMF0sIHBvbHlnb25JZClcbi8vICAgICAgIGxldCBjdXJyZW50UG9pbnQgPSBuZXcgUG9pbnQoY29vcmRzW2ldW2lpXVsxXSwgcG9seWdvbklkKVxuLy8gICAgICAgcHJldlBvaW50Lm5leHRQb2ludCA9IGN1cnJlbnRQb2ludFxuLy8gICAgICAgbGV0IG5leHRQb2ludCA9IG5ldyBQb2ludChjb29yZHNbaV1baWldWzJdLCBwb2x5Z29uSWQpXG4vLyAgICAgICBsaW5rUG9pbnRzKHByZXZQb2ludCwgY3VycmVudFBvaW50LCBuZXh0UG9pbnQpXG5cbi8vICAgICAgIHBvaW50cy5wdXNoKHByZXZQb2ludClcblxuLy8gICAgICAgbGV0IHByZXZFZGdlID0gbmV3IEVkZ2UocHJldlBvaW50LCBjdXJyZW50UG9pbnQpIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbi8vICAgICAgIGVkZ2VzLnB1c2gocHJldkVkZ2UpXG4vLyAgICAgICBjb250b3VyLnB1c2gocHJldkVkZ2UpXG5cbi8vICAgICAgIC8vIFNhdmUgbWUgZm9yIGxhdGVyXG4vLyAgICAgICBjb25zdCBmaXJzdFBvaW50ID0gcHJldlBvaW50XG5cbi8vICAgICAgIHByZXZQb2ludCA9IGN1cnJlbnRQb2ludFxuLy8gICAgICAgY3VycmVudFBvaW50ID0gbmV4dFBvaW50XG5cbi8vICAgICAgIGZvciAobGV0IGlpaSA9IDI7IGlpaSA8IGNvb3Jkc1tpXVtpaV0ubGVuZ3RoIC0gMjsgaWlpKyspIHtcbi8vICAgICAgICAgcG9pbnRzLnB1c2gocHJldlBvaW50KVxuXG4vLyAgICAgICAgIG5leHRQb2ludCA9IG5ldyBQb2ludChjb29yZHNbaV1baWldW2lpaSArIDFdLCBwb2x5Z29uSWQpXG5cbi8vICAgICAgICAgbGlua1BvaW50cyhwcmV2UG9pbnQsIGN1cnJlbnRQb2ludCwgbmV4dFBvaW50KVxuXG4vLyAgICAgICAgIGNvbnN0IGUgPSBuZXcgRWRnZShwcmV2UG9pbnQsIGN1cnJlbnRQb2ludCkgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4vLyAgICAgICAgIGVkZ2VzLnB1c2goZSlcbi8vICAgICAgICAgY29udG91ci5wdXNoKGUpXG5cbi8vICAgICAgICAgcHJldlBvaW50ID0gY3VycmVudFBvaW50XG4vLyAgICAgICAgIGN1cnJlbnRQb2ludCA9IG5leHRQb2ludFxuLy8gICAgICAgICBwcmV2RWRnZSA9IGVcbi8vICAgICAgIH1cblxuLy8gICAgICAgbGlua1BvaW50cyhwcmV2UG9pbnQsIGN1cnJlbnRQb2ludCwgZmlyc3RQb2ludClcblxuLy8gICAgICAgY29uc3Qgc2Vjb25kTGFzdEVkZ2UgPSBuZXcgRWRnZShwcmV2RWRnZS5wMiwgY3VycmVudFBvaW50KVxuXG4vLyAgICAgICBlZGdlcy5wdXNoKHNlY29uZExhc3RFZGdlKVxuLy8gICAgICAgY29udG91ci5wdXNoKHNlY29uZExhc3RFZGdlKVxuXG4vLyAgICAgICBjb25zdCBsYXN0RWRnZSA9IG5ldyBFZGdlKGN1cnJlbnRQb2ludCwgZmlyc3RQb2ludCkgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuLy8gICAgICAgbGlua1BvaW50cyhjdXJyZW50UG9pbnQsIGZpcnN0UG9pbnQsIGZpcnN0UG9pbnQubmV4dFBvaW50KVxuXG4vLyAgICAgICBlZGdlcy5wdXNoKGxhc3RFZGdlKVxuLy8gICAgICAgY29udG91ci5wdXNoKGxhc3RFZGdlKVxuXG4vLyAgICAgICBwb2ludHMucHVzaChwcmV2UG9pbnQpXG4vLyAgICAgICBwb2ludHMucHVzaChuZXh0UG9pbnQpXG4vLyAgICAgfVxuLy8gICB9XG4vLyB9XG5cbmZ1bmN0aW9uIGxpbmtQb2ludHMgKHByZXZQb2ludCwgY3VycmVudFBvaW50LCBuZXh0UG9pbnQpIHtcbiAgY3VycmVudFBvaW50LnByZXZQb2ludCA9IHByZXZQb2ludFxuICBjdXJyZW50UG9pbnQubmV4dFBvaW50ID0gbmV4dFBvaW50XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/setupStructure.js\n");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/*! exports provided: pi1, pi2, INF, edgeIntersect, ccw, onSegment, angle2, pointEdgeDistance, intersectPoint, calcEdgeDistance */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pi1\", function() { return pi1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pi2\", function() { return pi2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"INF\", function() { return INF; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"edgeIntersect\", function() { return edgeIntersect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ccw\", function() { return ccw; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"onSegment\", function() { return onSegment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"angle2\", function() { return angle2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pointEdgeDistance\", function() { return pointEdgeDistance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"intersectPoint\", function() { return intersectPoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"calcEdgeDistance\", function() { return calcEdgeDistance; });\n/* harmony import */ var _Point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Point */ \"./src/Point.js\");\n\n\nconst pi1 = Math.PI * 3 / 2\nconst pi2 = Math.PI / 2\n\nconst INF = 10000\nconst COLIN_TOLERANCE = 13\nconst T = Math.pow(10, COLIN_TOLERANCE)\nconst T2 = Math.pow(10.0, COLIN_TOLERANCE)\n\nfunction edgeIntersect (p1, q1, edge) {\n  const p2 = edge.p1\n  const q2 = edge.p2\n  const o1 = ccw(p1, q1, p2)\n  const o2 = ccw(p1, q1, q2)\n  const o3 = ccw(p2, q2, p1)\n  const o4 = ccw(p2, q2, q1)\n  if (o1 !== o2 && o3 !== o4) return true\n  if (o1 === 0 && onSegment(p1, p2, q1)) return true\n  if (o2 === 0 && onSegment(p1, q2, q1)) return true\n  if (o3 === 0 && onSegment(p2, p1, q2)) return true\n  if (o4 === 0 && onSegment(p2, q1, q2)) return true\n  return false\n}\n\nfunction ccw (a, b, c) {\n  const area = Math.round(((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) * T) / T2\n  if (area > 0) return 1\n  if (area < 0) return -1\n  return 0\n}\n\nfunction onSegment (p, q, r) {\n  if (q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x)) {\n    if (q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y)) return true\n  }\n  return false\n}\n\nfunction angle2 (p1, p2, p3) {\n  const a = Math.pow((p3.x - p2.x), 2) + Math.pow((p3.y - p2.y), 2)\n  const b = Math.pow((p3.x - p1.x), 2) + Math.pow((p3.y - p1.y), 2)\n  const c = Math.pow((p2.x - p1.x), 2) + Math.pow((p2.y - p1.y), 2)\n  return Math.acos((a + c - b) / (2 * Math.sqrt(a) * Math.sqrt(c)))\n}\n\nfunction pointEdgeDistance (p1, p2, edge) {\n  const ip = intersectPoint(p1, p2, edge)\n  return ip !== null ? calcEdgeDistance(p1, ip) : 0\n}\n\nfunction intersectPoint (p1, p2, edge) {\n  if (edge.containsPoint(p1)) return p1\n  if (edge.containsPoint(p2)) return p2\n  if (edge.p1.x === edge.p2.x) {\n    if (p1.x === p2.x) return null\n    const pslope = (p1.y - p2.y) / (p1.x - p2.x)\n    const intersectX = edge.p1.x\n    const intersectY = pslope * (intersectX - p1.x) + p1.y\n    return new _Point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"]([intersectX, intersectY], null)\n  }\n  if (p1.x === p2.x) {\n    const eslope = (edge.p1.y - edge.p2.y) / (edge.p1.x - edge.p2.x)\n    const intersectX = p1.x\n    const intersectY = eslope * (intersectX - edge.p1.x) + edge.p1.y\n    return new _Point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"]([intersectX, intersectY], null)\n  }\n\n  const pslope = (p1.y - p2.y) / (p1.x - p2.x)\n  const eslope = (edge.p1.y - edge.p2.y) / (edge.p1.x - edge.p2.x)\n\n  if (pslope === eslope) return null\n  const intersectX = (eslope * edge.p1.x - pslope * p1.x + p1.y - edge.p1.y) / (eslope - pslope)\n  const intersectY = eslope * (intersectX - edge.p1.x) + edge.p1.y\n  return new _Point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"]([intersectX, intersectY], null)\n}\n\nfunction calcEdgeDistance (p1, p2) {\n  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2))\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMuanM/MDI1ZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBK0I7O0FBRXhCO0FBQ0E7O0FBRUE7QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0Q0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0Q0FBSztBQUNwQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNENBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBIiwiZmlsZSI6Ii4vc3JjL3V0aWxzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuL1BvaW50J1xuXG5leHBvcnQgY29uc3QgcGkxID0gTWF0aC5QSSAqIDMgLyAyXG5leHBvcnQgY29uc3QgcGkyID0gTWF0aC5QSSAvIDJcblxuZXhwb3J0IGNvbnN0IElORiA9IDEwMDAwXG5jb25zdCBDT0xJTl9UT0xFUkFOQ0UgPSAxM1xuY29uc3QgVCA9IE1hdGgucG93KDEwLCBDT0xJTl9UT0xFUkFOQ0UpXG5jb25zdCBUMiA9IE1hdGgucG93KDEwLjAsIENPTElOX1RPTEVSQU5DRSlcblxuZXhwb3J0IGZ1bmN0aW9uIGVkZ2VJbnRlcnNlY3QgKHAxLCBxMSwgZWRnZSkge1xuICBjb25zdCBwMiA9IGVkZ2UucDFcbiAgY29uc3QgcTIgPSBlZGdlLnAyXG4gIGNvbnN0IG8xID0gY2N3KHAxLCBxMSwgcDIpXG4gIGNvbnN0IG8yID0gY2N3KHAxLCBxMSwgcTIpXG4gIGNvbnN0IG8zID0gY2N3KHAyLCBxMiwgcDEpXG4gIGNvbnN0IG80ID0gY2N3KHAyLCBxMiwgcTEpXG4gIGlmIChvMSAhPT0gbzIgJiYgbzMgIT09IG80KSByZXR1cm4gdHJ1ZVxuICBpZiAobzEgPT09IDAgJiYgb25TZWdtZW50KHAxLCBwMiwgcTEpKSByZXR1cm4gdHJ1ZVxuICBpZiAobzIgPT09IDAgJiYgb25TZWdtZW50KHAxLCBxMiwgcTEpKSByZXR1cm4gdHJ1ZVxuICBpZiAobzMgPT09IDAgJiYgb25TZWdtZW50KHAyLCBwMSwgcTIpKSByZXR1cm4gdHJ1ZVxuICBpZiAobzQgPT09IDAgJiYgb25TZWdtZW50KHAyLCBxMSwgcTIpKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNjdyAoYSwgYiwgYykge1xuICBjb25zdCBhcmVhID0gTWF0aC5yb3VuZCgoKGIueCAtIGEueCkgKiAoYy55IC0gYS55KSAtIChiLnkgLSBhLnkpICogKGMueCAtIGEueCkpICogVCkgLyBUMlxuICBpZiAoYXJlYSA+IDApIHJldHVybiAxXG4gIGlmIChhcmVhIDwgMCkgcmV0dXJuIC0xXG4gIHJldHVybiAwXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvblNlZ21lbnQgKHAsIHEsIHIpIHtcbiAgaWYgKHEueCA8PSBNYXRoLm1heChwLngsIHIueCkgJiYgcS54ID49IE1hdGgubWluKHAueCwgci54KSkge1xuICAgIGlmIChxLnkgPD0gTWF0aC5tYXgocC55LCByLnkpICYmIHEueSA+PSBNYXRoLm1pbihwLnksIHIueSkpIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhbmdsZTIgKHAxLCBwMiwgcDMpIHtcbiAgY29uc3QgYSA9IE1hdGgucG93KChwMy54IC0gcDIueCksIDIpICsgTWF0aC5wb3coKHAzLnkgLSBwMi55KSwgMilcbiAgY29uc3QgYiA9IE1hdGgucG93KChwMy54IC0gcDEueCksIDIpICsgTWF0aC5wb3coKHAzLnkgLSBwMS55KSwgMilcbiAgY29uc3QgYyA9IE1hdGgucG93KChwMi54IC0gcDEueCksIDIpICsgTWF0aC5wb3coKHAyLnkgLSBwMS55KSwgMilcbiAgcmV0dXJuIE1hdGguYWNvcygoYSArIGMgLSBiKSAvICgyICogTWF0aC5zcXJ0KGEpICogTWF0aC5zcXJ0KGMpKSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvaW50RWRnZURpc3RhbmNlIChwMSwgcDIsIGVkZ2UpIHtcbiAgY29uc3QgaXAgPSBpbnRlcnNlY3RQb2ludChwMSwgcDIsIGVkZ2UpXG4gIHJldHVybiBpcCAhPT0gbnVsbCA/IGNhbGNFZGdlRGlzdGFuY2UocDEsIGlwKSA6IDBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdFBvaW50IChwMSwgcDIsIGVkZ2UpIHtcbiAgaWYgKGVkZ2UuY29udGFpbnNQb2ludChwMSkpIHJldHVybiBwMVxuICBpZiAoZWRnZS5jb250YWluc1BvaW50KHAyKSkgcmV0dXJuIHAyXG4gIGlmIChlZGdlLnAxLnggPT09IGVkZ2UucDIueCkge1xuICAgIGlmIChwMS54ID09PSBwMi54KSByZXR1cm4gbnVsbFxuICAgIGNvbnN0IHBzbG9wZSA9IChwMS55IC0gcDIueSkgLyAocDEueCAtIHAyLngpXG4gICAgY29uc3QgaW50ZXJzZWN0WCA9IGVkZ2UucDEueFxuICAgIGNvbnN0IGludGVyc2VjdFkgPSBwc2xvcGUgKiAoaW50ZXJzZWN0WCAtIHAxLngpICsgcDEueVxuICAgIHJldHVybiBuZXcgUG9pbnQoW2ludGVyc2VjdFgsIGludGVyc2VjdFldLCBudWxsKVxuICB9XG4gIGlmIChwMS54ID09PSBwMi54KSB7XG4gICAgY29uc3QgZXNsb3BlID0gKGVkZ2UucDEueSAtIGVkZ2UucDIueSkgLyAoZWRnZS5wMS54IC0gZWRnZS5wMi54KVxuICAgIGNvbnN0IGludGVyc2VjdFggPSBwMS54XG4gICAgY29uc3QgaW50ZXJzZWN0WSA9IGVzbG9wZSAqIChpbnRlcnNlY3RYIC0gZWRnZS5wMS54KSArIGVkZ2UucDEueVxuICAgIHJldHVybiBuZXcgUG9pbnQoW2ludGVyc2VjdFgsIGludGVyc2VjdFldLCBudWxsKVxuICB9XG5cbiAgY29uc3QgcHNsb3BlID0gKHAxLnkgLSBwMi55KSAvIChwMS54IC0gcDIueClcbiAgY29uc3QgZXNsb3BlID0gKGVkZ2UucDEueSAtIGVkZ2UucDIueSkgLyAoZWRnZS5wMS54IC0gZWRnZS5wMi54KVxuXG4gIGlmIChwc2xvcGUgPT09IGVzbG9wZSkgcmV0dXJuIG51bGxcbiAgY29uc3QgaW50ZXJzZWN0WCA9IChlc2xvcGUgKiBlZGdlLnAxLnggLSBwc2xvcGUgKiBwMS54ICsgcDEueSAtIGVkZ2UucDEueSkgLyAoZXNsb3BlIC0gcHNsb3BlKVxuICBjb25zdCBpbnRlcnNlY3RZID0gZXNsb3BlICogKGludGVyc2VjdFggLSBlZGdlLnAxLngpICsgZWRnZS5wMS55XG4gIHJldHVybiBuZXcgUG9pbnQoW2ludGVyc2VjdFgsIGludGVyc2VjdFldLCBudWxsKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsY0VkZ2VEaXN0YW5jZSAocDEsIHAyKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3cocDIueCAtIHAxLngsIDIpICsgTWF0aC5wb3cocDIueSAtIHAxLnksIDIpKVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/utils.js\n");

/***/ })

/******/ });