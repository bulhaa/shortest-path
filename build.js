/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/visibility-graph-master/use/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../src/Edge.js":
/*!**********************!*\
  !*** ../src/Edge.js ***!
  \**********************/
/*! exports provided: Edge */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Edge\", function() { return Edge; });\nclass Edge {\n  constructor (p1, p2) {\n    this.p1 = p1\n    this.p2 = p2\n\n    p1.edges.push(this)\n    p2.edges.push(this)\n  }\n\n  getOtherPointInEdge (point) {\n    return this.p1.isPointEqual(point) ? this.p2 : this.p1\n  }\n\n  areEdgesEqual (otherEdge) {\n    if (this.p1.isPointEqual(otherEdge.p1) && this.p2.isPointEqual(otherEdge.p2)) return true\n    if (this.p1.isPointEqual(otherEdge.p2) && this.p2.isPointEqual(otherEdge.p1)) return true\n    return false\n  }\n\n  containsPoint (point) {\n    if (this.p1.isPointEqual(point) || this.p2.isPointEqual(point)) return true\n    return false\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL0VkZ2UuanM/ZDE1ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi4vc3JjL0VkZ2UuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY2xhc3MgRWRnZSB7XG4gIGNvbnN0cnVjdG9yIChwMSwgcDIpIHtcbiAgICB0aGlzLnAxID0gcDFcbiAgICB0aGlzLnAyID0gcDJcblxuICAgIHAxLmVkZ2VzLnB1c2godGhpcylcbiAgICBwMi5lZGdlcy5wdXNoKHRoaXMpXG4gIH1cblxuICBnZXRPdGhlclBvaW50SW5FZGdlIChwb2ludCkge1xuICAgIHJldHVybiB0aGlzLnAxLmlzUG9pbnRFcXVhbChwb2ludCkgPyB0aGlzLnAyIDogdGhpcy5wMVxuICB9XG5cbiAgYXJlRWRnZXNFcXVhbCAob3RoZXJFZGdlKSB7XG4gICAgaWYgKHRoaXMucDEuaXNQb2ludEVxdWFsKG90aGVyRWRnZS5wMSkgJiYgdGhpcy5wMi5pc1BvaW50RXF1YWwob3RoZXJFZGdlLnAyKSkgcmV0dXJuIHRydWVcbiAgICBpZiAodGhpcy5wMS5pc1BvaW50RXF1YWwob3RoZXJFZGdlLnAyKSAmJiB0aGlzLnAyLmlzUG9pbnRFcXVhbChvdGhlckVkZ2UucDEpKSByZXR1cm4gdHJ1ZVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgY29udGFpbnNQb2ludCAocG9pbnQpIHtcbiAgICBpZiAodGhpcy5wMS5pc1BvaW50RXF1YWwocG9pbnQpIHx8IHRoaXMucDIuaXNQb2ludEVxdWFsKHBvaW50KSkgcmV0dXJuIHRydWVcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../src/Edge.js\n");

/***/ }),

/***/ "../src/EdgeKey.js":
/*!*************************!*\
  !*** ../src/EdgeKey.js ***!
  \*************************/
/*! exports provided: EdgeKey */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EdgeKey\", function() { return EdgeKey; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"../src/utils.js\");\n\n\nclass EdgeKey {\n\n  constructor (p1, p2, edge) {\n    this.p1 = p1\n    this.p2 = p2\n    this.edge = edge\n  }\n\n  isLessThanOtherEdgeKey (otherEdgeKey) {\n    if (this.matchesOtherKey(otherEdgeKey)) return false\n    if (!Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"edgeIntersect\"])(this.p1, this.p2, otherEdgeKey.edge)) return true\n    const selfDistance = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"pointEdgeDistance\"])(this.p1, this.p2, this.edge)\n    const otherDistance = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"pointEdgeDistance\"])(this.p1, this.p2, otherEdgeKey.edge)\n    if (selfDistance > otherDistance) return false\n    if (selfDistance < otherDistance) return true\n    if (selfDistance === otherDistance) {\n      let samePoint = null\n      if (otherEdgeKey.edge.containsPoint(this.edge.p1)) samePoint = this.edge.p1\n      // else if (otherEdgeKey.edge.containsPoint(this.edge.p2)) samePoint = this.edge.p2\n      else samePoint = this.edge.p2\n      const aslf = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"angle2\"])(this.p1, this.p2, this.edge.getOtherPointInEdge(samePoint))\n      const aot = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"angle2\"])(this.p1, this.p2, otherEdgeKey.edge.getOtherPointInEdge(samePoint))\n      if (aslf < aot) return true\n      return false\n    }\n  }\n\n  matchesOtherKey (otherKey) {\n    return this.edge.areEdgesEqual(otherKey.edge)\n  }\n\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL0VkZ2VLZXkuanM/MjQzYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBa0U7O0FBRTNEOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsNERBQWE7QUFDdEIseUJBQXlCLGdFQUFpQjtBQUMxQywwQkFBMEIsZ0VBQWlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFEQUFNO0FBQ3pCLGtCQUFrQixxREFBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi4vc3JjL0VkZ2VLZXkuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBlZGdlSW50ZXJzZWN0LCBwb2ludEVkZ2VEaXN0YW5jZSwgYW5nbGUyIH0gZnJvbSAnLi91dGlscydcblxuZXhwb3J0IGNsYXNzIEVkZ2VLZXkge1xuXG4gIGNvbnN0cnVjdG9yIChwMSwgcDIsIGVkZ2UpIHtcbiAgICB0aGlzLnAxID0gcDFcbiAgICB0aGlzLnAyID0gcDJcbiAgICB0aGlzLmVkZ2UgPSBlZGdlXG4gIH1cblxuICBpc0xlc3NUaGFuT3RoZXJFZGdlS2V5IChvdGhlckVkZ2VLZXkpIHtcbiAgICBpZiAodGhpcy5tYXRjaGVzT3RoZXJLZXkob3RoZXJFZGdlS2V5KSkgcmV0dXJuIGZhbHNlXG4gICAgaWYgKCFlZGdlSW50ZXJzZWN0KHRoaXMucDEsIHRoaXMucDIsIG90aGVyRWRnZUtleS5lZGdlKSkgcmV0dXJuIHRydWVcbiAgICBjb25zdCBzZWxmRGlzdGFuY2UgPSBwb2ludEVkZ2VEaXN0YW5jZSh0aGlzLnAxLCB0aGlzLnAyLCB0aGlzLmVkZ2UpXG4gICAgY29uc3Qgb3RoZXJEaXN0YW5jZSA9IHBvaW50RWRnZURpc3RhbmNlKHRoaXMucDEsIHRoaXMucDIsIG90aGVyRWRnZUtleS5lZGdlKVxuICAgIGlmIChzZWxmRGlzdGFuY2UgPiBvdGhlckRpc3RhbmNlKSByZXR1cm4gZmFsc2VcbiAgICBpZiAoc2VsZkRpc3RhbmNlIDwgb3RoZXJEaXN0YW5jZSkgcmV0dXJuIHRydWVcbiAgICBpZiAoc2VsZkRpc3RhbmNlID09PSBvdGhlckRpc3RhbmNlKSB7XG4gICAgICBsZXQgc2FtZVBvaW50ID0gbnVsbFxuICAgICAgaWYgKG90aGVyRWRnZUtleS5lZGdlLmNvbnRhaW5zUG9pbnQodGhpcy5lZGdlLnAxKSkgc2FtZVBvaW50ID0gdGhpcy5lZGdlLnAxXG4gICAgICAvLyBlbHNlIGlmIChvdGhlckVkZ2VLZXkuZWRnZS5jb250YWluc1BvaW50KHRoaXMuZWRnZS5wMikpIHNhbWVQb2ludCA9IHRoaXMuZWRnZS5wMlxuICAgICAgZWxzZSBzYW1lUG9pbnQgPSB0aGlzLmVkZ2UucDJcbiAgICAgIGNvbnN0IGFzbGYgPSBhbmdsZTIodGhpcy5wMSwgdGhpcy5wMiwgdGhpcy5lZGdlLmdldE90aGVyUG9pbnRJbkVkZ2Uoc2FtZVBvaW50KSlcbiAgICAgIGNvbnN0IGFvdCA9IGFuZ2xlMih0aGlzLnAxLCB0aGlzLnAyLCBvdGhlckVkZ2VLZXkuZWRnZS5nZXRPdGhlclBvaW50SW5FZGdlKHNhbWVQb2ludCkpXG4gICAgICBpZiAoYXNsZiA8IGFvdCkgcmV0dXJuIHRydWVcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIG1hdGNoZXNPdGhlcktleSAob3RoZXJLZXkpIHtcbiAgICByZXR1cm4gdGhpcy5lZGdlLmFyZUVkZ2VzRXF1YWwob3RoZXJLZXkuZWRnZSlcbiAgfVxuXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../src/EdgeKey.js\n");

/***/ }),

/***/ "../src/EdgeKeys.js":
/*!**************************!*\
  !*** ../src/EdgeKeys.js ***!
  \**************************/
/*! exports provided: EdgeKeys */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EdgeKeys\", function() { return EdgeKeys; });\nclass EdgeKeys {\n\n  constructor () {\n    this.keys = []\n  }\n\n  findKeyPosition (edgekey, p) {\n    let lo = 0\n    let hi = this.keys.length\n    while (lo < hi) {\n      const mid = Math.floor((lo + hi) / 2)\n      if (edgekey.isLessThanOtherEdgeKey(this.keys[mid])) hi = mid\n      else lo = mid + 1\n    }\n    return lo\n  }\n\n  addKey (edgekey, p) {\n    const lo = this.findKeyPosition(edgekey)\n    this.keys.splice(lo, 0, edgekey)\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL0VkZ2VLZXlzLmpzPzA3NmEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4uL3NyYy9FZGdlS2V5cy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjbGFzcyBFZGdlS2V5cyB7XG5cbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMua2V5cyA9IFtdXG4gIH1cblxuICBmaW5kS2V5UG9zaXRpb24gKGVkZ2VrZXksIHApIHtcbiAgICBsZXQgbG8gPSAwXG4gICAgbGV0IGhpID0gdGhpcy5rZXlzLmxlbmd0aFxuICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICBjb25zdCBtaWQgPSBNYXRoLmZsb29yKChsbyArIGhpKSAvIDIpXG4gICAgICBpZiAoZWRnZWtleS5pc0xlc3NUaGFuT3RoZXJFZGdlS2V5KHRoaXMua2V5c1ttaWRdKSkgaGkgPSBtaWRcbiAgICAgIGVsc2UgbG8gPSBtaWQgKyAxXG4gICAgfVxuICAgIHJldHVybiBsb1xuICB9XG5cbiAgYWRkS2V5IChlZGdla2V5LCBwKSB7XG4gICAgY29uc3QgbG8gPSB0aGlzLmZpbmRLZXlQb3NpdGlvbihlZGdla2V5KVxuICAgIHRoaXMua2V5cy5zcGxpY2UobG8sIDAsIGVkZ2VrZXkpXG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../src/EdgeKeys.js\n");

/***/ }),

/***/ "../src/Point.js":
/*!***********************!*\
  !*** ../src/Point.js ***!
  \***********************/
/*! exports provided: Point */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Point\", function() { return Point; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"../src/utils.js\");\n\n\nclass Point {\n\n  constructor (coords, polygonID) {\n    if (polygonID === null) polygonID = -1\n    this.x = coords[0]\n    this.y = coords[1]\n    this.polygonID = polygonID\n    this.edges = []\n    this.prevPoint = null\n    this.nextPoint = null\n  }\n\n  isPointEqual (otherPoint) {\n    return this.x === otherPoint.x && this.y === otherPoint.y\n  }\n\n  angleToPoint (otherPoint) {\n    if (this.isPointEqual(otherPoint)) return 0\n    const dx = otherPoint.x - this.x\n    const dy = otherPoint.y - this.y\n    if (dx === 0) dy < 1 ? _utils__WEBPACK_IMPORTED_MODULE_0__[\"pi1\"] : _utils__WEBPACK_IMPORTED_MODULE_0__[\"pi2\"]\n    if (dy === 0) dx < 0 ? Math.PI : 0\n    if (dx < 0) return Math.PI + Math.atan(dy / dx)\n    if (dy < 0) return 2 * Math.PI + Math.atan(dy / dx)\n    return Math.atan(dy / dx)\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL1BvaW50LmpzP2JlNzIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQWtDOztBQUUzQjs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBDQUFHLEdBQUcsMENBQUc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4uL3NyYy9Qb2ludC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBpMSwgcGkyIH0gZnJvbSAnLi91dGlscydcblxuZXhwb3J0IGNsYXNzIFBvaW50IHtcblxuICBjb25zdHJ1Y3RvciAoY29vcmRzLCBwb2x5Z29uSUQpIHtcbiAgICBpZiAocG9seWdvbklEID09PSBudWxsKSBwb2x5Z29uSUQgPSAtMVxuICAgIHRoaXMueCA9IGNvb3Jkc1swXVxuICAgIHRoaXMueSA9IGNvb3Jkc1sxXVxuICAgIHRoaXMucG9seWdvbklEID0gcG9seWdvbklEXG4gICAgdGhpcy5lZGdlcyA9IFtdXG4gICAgdGhpcy5wcmV2UG9pbnQgPSBudWxsXG4gICAgdGhpcy5uZXh0UG9pbnQgPSBudWxsXG4gIH1cblxuICBpc1BvaW50RXF1YWwgKG90aGVyUG9pbnQpIHtcbiAgICByZXR1cm4gdGhpcy54ID09PSBvdGhlclBvaW50LnggJiYgdGhpcy55ID09PSBvdGhlclBvaW50LnlcbiAgfVxuXG4gIGFuZ2xlVG9Qb2ludCAob3RoZXJQb2ludCkge1xuICAgIGlmICh0aGlzLmlzUG9pbnRFcXVhbChvdGhlclBvaW50KSkgcmV0dXJuIDBcbiAgICBjb25zdCBkeCA9IG90aGVyUG9pbnQueCAtIHRoaXMueFxuICAgIGNvbnN0IGR5ID0gb3RoZXJQb2ludC55IC0gdGhpcy55XG4gICAgaWYgKGR4ID09PSAwKSBkeSA8IDEgPyBwaTEgOiBwaTJcbiAgICBpZiAoZHkgPT09IDApIGR4IDwgMCA/IE1hdGguUEkgOiAwXG4gICAgaWYgKGR4IDwgMCkgcmV0dXJuIE1hdGguUEkgKyBNYXRoLmF0YW4oZHkgLyBkeClcbiAgICBpZiAoZHkgPCAwKSByZXR1cm4gMiAqIE1hdGguUEkgKyBNYXRoLmF0YW4oZHkgLyBkeClcbiAgICByZXR1cm4gTWF0aC5hdGFuKGR5IC8gZHgpXG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../src/Point.js\n");

/***/ }),

/***/ "../src/createGraphFromGeoJson.js":
/*!****************************************!*\
  !*** ../src/createGraphFromGeoJson.js ***!
  \****************************************/
/*! exports provided: loadPoints, restoreOriginalPointsAndEdges, getVisibleNodes, addStartingAndEndingNodes, getObstructingEdge, isVisible, createGraphFromGeoJson */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadPoints\", function() { return loadPoints; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"restoreOriginalPointsAndEdges\", function() { return restoreOriginalPointsAndEdges; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getVisibleNodes\", function() { return getVisibleNodes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addStartingAndEndingNodes\", function() { return addStartingAndEndingNodes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getObstructingEdge\", function() { return getObstructingEdge; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isVisible\", function() { return isVisible; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createGraphFromGeoJson\", function() { return createGraphFromGeoJson; });\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'ngraph.graph'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n/* harmony import */ var _EdgeKeys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EdgeKeys */ \"../src/EdgeKeys.js\");\n/* harmony import */ var _EdgeKey__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EdgeKey */ \"../src/EdgeKey.js\");\n/* harmony import */ var _Point__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Point */ \"../src/Point.js\");\n/* harmony import */ var _setupStructure__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./setupStructure */ \"../src/setupStructure.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils */ \"../src/utils.js\");\n/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./debug */ \"../src/debug.js\");\n/* harmony import */ var _Edge__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Edge */ \"../src/Edge.js\");\n\n\n\n\n\n\n //eslint-disable-line\n\n\n\nconst points = []\nconst edges = []\nconst polygons = []\nvar originalPointsLength = 0\nvar originalEdgesLength = 0\n\nfunction loadPoints (geojson) {\n  Object(_setupStructure__WEBPACK_IMPORTED_MODULE_4__[\"setupStructure\"])(geojson, edges, points, polygons)\n  originalPointsLength = points.length\n  originalEdgesLength = edges.length\n}\n\nfunction restoreOriginalPointsAndEdges() {\n  while(points.length > originalPointsLength) {\n    points.pop()\n  }\n\n  while(edges.length > originalEdgesLength) {\n    edges.pop()\n  }\n}\n\n// add start and end to nodes and check for visibility\nfunction getVisibleNodes (pt1, start, end) {\n  if(start != null && end != null){\n    // edges.push(new Edge(points[points.length-1], start))\n    edges.push(new _Edge__WEBPACK_IMPORTED_MODULE_7__[\"Edge\"](start, end))\n    // edges.push(new Edge(end, points[0]))\n\n    // start.prevPoint = points[points.length-1]\n    // start.nextPoint = end\n    start.polygonID = -1\n\n    // end.prevPoint = start\n    // end.nextPoint = points[0]\n    end.polygonID = -1\n\n    points.push(start)\n    points.push(end)\n  }\n\n  const g = !(function webpackMissingModule() { var e = new Error(\"Cannot find module 'ngraph.graph'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())()\n  const pointsLen = points.length\n  const clonedPoints = clonePoints()\n\n  for (var i = 0; i < pointsLen; i++) {\n    const p = points[i]\n    if (!p.isPointEqual(pt1)) continue\n\n    const prevPoint = p.prevPoint\n    const nextPoint = p.nextPoint\n\n    sortPoints(p, clonedPoints)\n    // _renderSortedPoints(p, clonedPoints)\n\n    const openEdges = new _EdgeKeys__WEBPACK_IMPORTED_MODULE_1__[\"EdgeKeys\"]()\n    const pointInf = new _Point__WEBPACK_IMPORTED_MODULE_3__[\"Point\"]([_utils__WEBPACK_IMPORTED_MODULE_5__[\"INF\"], p.y], null)\n    for (let ii = 0; ii < pointsLen; ii++) {\n      const e = edges[ii]\n      if (typeof e != 'undefined' && e.containsPoint(p)) continue\n      if (typeof e != 'undefined' && Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"edgeIntersect\"])(p, pointInf, e)) {\n        if (Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"onSegment\"])(p, e.p1, pointInf) || Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"onSegment\"])(p, e.p2, pointInf)) continue\n        openEdges.addKey(new _EdgeKey__WEBPACK_IMPORTED_MODULE_2__[\"EdgeKey\"](p, pointInf, e))\n      }\n    }\n    // // _renderOpenEdges(p, openEdges.keys)\n\n    const visible = []\n    if(prevPoint) visible.push(prevPoint)\n    if(nextPoint) visible.push(nextPoint)\n    let prev = null\n    let prevVisible = null\n\n    for (let ii = 0; ii < pointsLen; ii++) {\n      const p2 = clonedPoints[ii]\n      // if (!p2.isPointEqual(pt2)) continue\n      if (p2.isPointEqual(p)) continue\n      if (p.angleToPoint(p2) > Math.pi) break\n\n      if (openEdges.keys.length > 0) {\n        for (let iii = 0; iii < p2.edges.length; iii++) {\n          const e = p2.edges[iii]\n          if (Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"ccw\"])(p, p2, e.getOtherPointInEdge(p2)) === -1) {\n            const k = new _EdgeKey__WEBPACK_IMPORTED_MODULE_2__[\"EdgeKey\"](p, p2, e)\n            const index = openEdges.findKeyPosition(k) - 1\n            if (index !== -1 && openEdges.keys[index].matchesOtherKey(k)) {\n              openEdges.keys.splice(index, 1)\n            }\n          }\n        }\n      }\n\n      let isVisible = false\n      if (prev === null || Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"ccw\"])(p, prev, p2) !== 0 || !Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"onSegment\"])(p, prev, p2)) {\n        if (openEdges.keys.length === 0) {\n          isVisible = true\n        } else if (!Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"edgeIntersect\"])(p, p2, openEdges.keys[0].edge)) {\n          isVisible = true\n        }\n      } else if (!prevVisible) {\n        isVisible = false\n      } else {\n        isVisible = true\n        for (let iii = 0; iii < openEdges.keys.length; iii++) {\n          const e = openEdges.keys[iii]\n          if (!e.edge.containsPoint(prev) && Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"edgeIntersect\"])(prev, p2, e.edge)) {\n            isVisible = false\n            break\n          }\n        }\n        if (isVisible && edgeInPolygon(prev, p2)) isVisible = false\n      }\n\n      const isInAdjacentPoints = (prevPoint != null && p2.isPointEqual(prevPoint)) || (nextPoint != null && p2.isPointEqual(nextPoint))\n      if (isVisible && !isInAdjacentPoints) isVisible = !edgeInPolygon(p, p2)\n\n      if (isVisible) visible.push(p2)\n      \n\n      for (let iii = 0; iii < p2.edges.length; iii++) {\n        const e = p2.edges[iii]\n        if (!e.containsPoint(p) && Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"ccw\"])(p, p2, e.getOtherPointInEdge(p2)) === 1) {\n          const k = new _EdgeKey__WEBPACK_IMPORTED_MODULE_2__[\"EdgeKey\"](p, p2, e)\n          openEdges.addKey(k)\n        }\n      }\n\n      prev = p2\n      prevVisible = isVisible\n    }\n\n    return visible;\n\n    // const nodeId = createNodeId(p)\n    // g.addNode(nodeId, { x: p.x, y: p.y })\n\n    // for (var ii = 0; ii < visible.length; ii++) {\n    //   const otherNodeId = createNodeId(visible[ii])\n    //   g.addNode(otherNodeId, { x: visible[ii].x, y: visible[ii].y })\n    //   g.addLink(nodeId, otherNodeId)\n    // }\n  }\n  // return g\n}\n\nfunction addStartingAndEndingNodes (start, end) {\n  // edges.push(new Edge(points[points.length-1], start))\n  edges.push(new _Edge__WEBPACK_IMPORTED_MODULE_7__[\"Edge\"](start, end))\n  // edges.push(new Edge(end, points[0]))\n\n  // start.prevPoint = points[points.length-1]\n  // start.nextPoint = end\n  start.polygonID = -1\n\n  // end.prevPoint = start\n  // end.nextPoint = points[0]\n  end.polygonID = -1\n\n  points.push(start)\n  points.push(end)\n}\n\n\n\nfunction getObstructingEdge (pt1, pt2, polygonPoints) {\n  const g = !(function webpackMissingModule() { var e = new Error(\"Cannot find module 'ngraph.graph'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())()\n  var points = polygonPoints.slice(0)\n  points.push(pt1)\n  points.push(pt2)\n  const pointsLen = points.length\n  const clonedPoints = points.slice(0)\n\n\n  for (var i = 0; i < pointsLen; i++) {\n    const p = points[i]\n    if (!p.isPointEqual(pt1)) continue\n\n    const prevPoint = p.prevPoint\n    const nextPoint = p.nextPoint\n\n    sortPoints(p, clonedPoints)\n    // _renderSortedPoints(p, clonedPoints)\n\n    const openEdges = new _EdgeKeys__WEBPACK_IMPORTED_MODULE_1__[\"EdgeKeys\"]()\n    const pointInf = new _Point__WEBPACK_IMPORTED_MODULE_3__[\"Point\"]([_utils__WEBPACK_IMPORTED_MODULE_5__[\"INF\"], p.y], null)\n    for (let ii = 0; ii < pointsLen; ii++) {\n      const e = edges[ii]\n      if (typeof e != 'undefined' && e.containsPoint(p)) continue\n      if (typeof e != 'undefined' && Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"edgeIntersect\"])(p, pointInf, e)) {\n        if (Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"onSegment\"])(p, e.p1, pointInf) || Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"onSegment\"])(p, e.p2, pointInf)) continue\n        openEdges.addKey(new _EdgeKey__WEBPACK_IMPORTED_MODULE_2__[\"EdgeKey\"](p, pointInf, e))\n      }\n    }\n    // // _renderOpenEdges(p, openEdges.keys)\n\n    const visible = []\n    visible.push(prevPoint)\n    visible.push(nextPoint)\n    let prev = null\n    let prevVisible = null\n\n    for (let ii = 0; ii < pointsLen; ii++) {\n      const p2 = clonedPoints[ii]\n      // if (!p2.isPointEqual(pt2)) continue\n\n      if (p2.isPointEqual(p)) continue\n      if (p.angleToPoint(p2) > Math.pi) break\n\n      if (openEdges.keys.length > 0) {\n        for (let iii = 0; iii < p2.edges.length; iii++) {\n          const e = p2.edges[iii]\n          if (Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"ccw\"])(p, p2, e.getOtherPointInEdge(p2)) === -1) {\n            const k = new _EdgeKey__WEBPACK_IMPORTED_MODULE_2__[\"EdgeKey\"](p, p2, e)\n            const index = openEdges.findKeyPosition(k) - 1\n            if (index !== -1 && openEdges.keys[index].matchesOtherKey(k)) {\n              openEdges.keys.splice(index, 1)\n            }\n          }\n        }\n      }\n\n      if (p2.isPointEqual(pt2))\n        pt2 = pt2\n      let isVisible = false\n      if (prev === null || Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"ccw\"])(p, prev, p2) !== 0 || !Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"onSegment\"])(p, prev, p2)) {\n        if (openEdges.keys.length === 0) {\n          isVisible = true\n        } else if (!Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"edgeIntersect\"])(p, p2, openEdges.keys[0].edge)) {\n          isVisible = true\n        }\n      } else if (!prevVisible) {\n        isVisible = false\n      } else {\n        isVisible = true\n        for (let iii = 0; iii < openEdges.keys.length; iii++) {\n          const e = openEdges.keys[iii]\n          if (!e.edge.containsPoint(prev) && Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"edgeIntersect\"])(prev, p2, e.edge)) {\n            isVisible = false\n            break\n          }\n        }\n        if (isVisible && edgeInPolygon(prev, p2)) isVisible = false\n      }\n\n      const isInAdjacentPoints = (prevPoint != null && p2.isPointEqual(prevPoint)) || (nextPoint != null && p2.isPointEqual(nextPoint))\n      if (isVisible && !isInAdjacentPoints) isVisible = !edgeInPolygon(p, p2)\n\n      // if same polygon visisble\n      if (p.polygonID == p2.polygonID && p.polygonID != -1)\n        isVisible = true\n\n      // if (isVisible) visible.push(p2)\n      if (p2.isPointEqual(pt2))\n       return isVisible ? null : openEdges.keys[0].edge;\n      \n\n      for (let iii = 0; iii < p2.edges.length; iii++) {\n        const e = p2.edges[iii]\n        if (!e.containsPoint(p) && Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"ccw\"])(p, p2, e.getOtherPointInEdge(p2)) === 1) {\n          const k = new _EdgeKey__WEBPACK_IMPORTED_MODULE_2__[\"EdgeKey\"](p, p2, e)\n          openEdges.addKey(k)\n        }\n      }\n\n      prev = p2\n      prevVisible = isVisible\n    }\n\n    // const nodeId = createNodeId(p)\n    // g.addNode(nodeId, { x: p.x, y: p.y })\n\n    // for (var ii = 0; ii < visible.length; ii++) {\n    //   const otherNodeId = createNodeId(visible[ii])\n    //   g.addNode(otherNodeId, { x: visible[ii].x, y: visible[ii].y })\n    //   g.addLink(nodeId, otherNodeId)\n    // }\n  }\n  // return g\n}\n\n// export function getObstructingEdge (pt1, pt2) {\n//   const g = createGraph()\n//   const pointsLen = points.length\n//   const clonedPoints = clonePoints()\n\n//   for (var i = 0; i < pointsLen; i++) {\n//     const p = points[i]\n//     if (!p.isPointEqual(pt1)) continue\n\n//     const prevPoint = p.prevPoint\n//     const nextPoint = p.nextPoint\n\n//     sortPoints(p, clonedPoints)\n//     // _renderSortedPoints(p, clonedPoints)\n\n//     const openEdges = new EdgeKeys()\n//     const pointInf = new Point([INF, p.y], null)\n//     for (let ii = 0; ii < pointsLen; ii++) {\n//       const e = edges[ii]\n//       if (typeof e != 'undefined' && e.containsPoint(p)) continue\n//       if (typeof e != 'undefined' && edgeIntersect(p, pointInf, e)) {\n//         if (onSegment(p, e.p1, pointInf) || onSegment(p, e.p2, pointInf)) continue\n//         openEdges.addKey(new EdgeKey(p, pointInf, e))\n//       }\n//     }\n//     // // _renderOpenEdges(p, openEdges.keys)\n\n//     const visible = []\n//     visible.push(prevPoint)\n//     visible.push(nextPoint)\n//     let prev = null\n//     let prevVisible = null\n\n//     for (let ii = 0; ii < pointsLen; ii++) {\n//       const p2 = clonedPoints[ii]\n//       // if (!p2.isPointEqual(pt2)) continue\n\n//       if (p2.isPointEqual(p)) continue\n//       if (p.angleToPoint(p2) > Math.pi) break\n\n//       if (openEdges.keys.length > 0) {\n//         for (let iii = 0; iii < p2.edges.length; iii++) {\n//           const e = p2.edges[iii]\n//           if (ccw(p, p2, e.getOtherPointInEdge(p2)) === -1) {\n//             const k = new EdgeKey(p, p2, e)\n//             const index = openEdges.findKeyPosition(k) - 1\n//             if (index !== -1 && openEdges.keys[index].matchesOtherKey(k)) {\n//               openEdges.keys.splice(index, 1)\n//             }\n//           }\n//         }\n//       }\n\n//       if (p2.isPointEqual(pt2))\n//         pt2 = pt2\n//       let isVisible = false\n//       if (prev === null || ccw(p, prev, p2) !== 0 || !onSegment(p, prev, p2)) {\n//         if (openEdges.keys.length === 0) {\n//           isVisible = true\n//         } else if (!edgeIntersect(p, p2, openEdges.keys[0].edge)) {\n//           isVisible = true\n//         }\n//       } else if (!prevVisible) {\n//         isVisible = false\n//       } else {\n//         isVisible = true\n//         for (let iii = 0; iii < openEdges.keys.length; iii++) {\n//           const e = openEdges.keys[iii]\n//           if (!e.edge.containsPoint(prev) && edgeIntersect(prev, p2, e.edge)) {\n//             isVisible = false\n//             break\n//           }\n//         }\n//         if (isVisible && edgeInPolygon(prev, p2)) isVisible = false\n//       }\n\n//       const isInAdjacentPoints = (prevPoint != null && p2.isPointEqual(prevPoint)) || (nextPoint != null && p2.isPointEqual(nextPoint))\n//       if (isVisible && !isInAdjacentPoints) isVisible = !edgeInPolygon(p, p2)\n\n//       // if same polygon visisble\n//       if (p.polygonID == p2.polygonID && p.polygonID != -1)\n//         isVisible = true\n\n//       // if (isVisible) visible.push(p2)\n//       if (p2.isPointEqual(pt2))\n//        return isVisible ? null : openEdges.keys[0].edge;\n      \n\n//       for (let iii = 0; iii < p2.edges.length; iii++) {\n//         const e = p2.edges[iii]\n//         if (!e.containsPoint(p) && ccw(p, p2, e.getOtherPointInEdge(p2)) === 1) {\n//           const k = new EdgeKey(p, p2, e)\n//           openEdges.addKey(k)\n//         }\n//       }\n\n//       prev = p2\n//       prevVisible = isVisible\n//     }\n\n//     // const nodeId = createNodeId(p)\n//     // g.addNode(nodeId, { x: p.x, y: p.y })\n\n//     // for (var ii = 0; ii < visible.length; ii++) {\n//     //   const otherNodeId = createNodeId(visible[ii])\n//     //   g.addNode(otherNodeId, { x: visible[ii].x, y: visible[ii].y })\n//     //   g.addLink(nodeId, otherNodeId)\n//     // }\n//   }\n//   // return g\n// }\n\nfunction isVisible (pt1, pt2) {\n  const g = !(function webpackMissingModule() { var e = new Error(\"Cannot find module 'ngraph.graph'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())()\n  const pointsLen = points.length\n  const clonedPoints = clonePoints()\n\n  for (var i = 0; i < pointsLen; i++) {\n    const p = points[i]\n    if (!p.isPointEqual(pt1)) continue\n\n    const prevPoint = p.prevPoint\n    const nextPoint = p.nextPoint\n\n    sortPoints(p, clonedPoints)\n    // _renderSortedPoints(p, clonedPoints)\n\n    const openEdges = new _EdgeKeys__WEBPACK_IMPORTED_MODULE_1__[\"EdgeKeys\"]()\n    const pointInf = new _Point__WEBPACK_IMPORTED_MODULE_3__[\"Point\"]([_utils__WEBPACK_IMPORTED_MODULE_5__[\"INF\"], p.y], null)\n    for (let ii = 0; ii < pointsLen; ii++) {\n      const e = edges[ii]\n      if (typeof e != 'undefined' && e.containsPoint(p)) continue\n      if (typeof e != 'undefined' && Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"edgeIntersect\"])(p, pointInf, e)) {\n        if (Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"onSegment\"])(p, e.p1, pointInf) || Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"onSegment\"])(p, e.p2, pointInf)) continue\n        openEdges.addKey(new _EdgeKey__WEBPACK_IMPORTED_MODULE_2__[\"EdgeKey\"](p, pointInf, e))\n      }\n    }\n    // // _renderOpenEdges(p, openEdges.keys)\n\n    const visible = []\n    visible.push(prevPoint)\n    visible.push(nextPoint)\n    let prev = null\n    let prevVisible = null\n\n    for (let ii = 0; ii < pointsLen; ii++) {\n      const p2 = clonedPoints[ii]\n      // if (!p2.isPointEqual(pt2)) continue\n\n      if (p2.isPointEqual(p)) continue\n      if (p.angleToPoint(p2) > Math.pi) break\n\n      if (openEdges.keys.length > 0) {\n        for (let iii = 0; iii < p2.edges.length; iii++) {\n          const e = p2.edges[iii]\n          if (Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"ccw\"])(p, p2, e.getOtherPointInEdge(p2)) === -1) {\n            const k = new _EdgeKey__WEBPACK_IMPORTED_MODULE_2__[\"EdgeKey\"](p, p2, e)\n            const index = openEdges.findKeyPosition(k) - 1\n            if (index !== -1 && openEdges.keys[index].matchesOtherKey(k)) {\n              openEdges.keys.splice(index, 1)\n            }\n          }\n        }\n      }\n\n      if (p2.isPointEqual(pt2))\n        pt2 = pt2\n      let isVisible = false\n      if (prev === null || Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"ccw\"])(p, prev, p2) !== 0 || !Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"onSegment\"])(p, prev, p2)) {\n        if (openEdges.keys.length === 0) {\n          isVisible = true\n        } else if (!Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"edgeIntersect\"])(p, p2, openEdges.keys[0].edge)) {\n          isVisible = true\n        }\n      } else if (!prevVisible) {\n        isVisible = false\n      } else {\n        isVisible = true\n        for (let iii = 0; iii < openEdges.keys.length; iii++) {\n          const e = openEdges.keys[iii]\n          if (!e.edge.containsPoint(prev) && Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"edgeIntersect\"])(prev, p2, e.edge)) {\n            isVisible = false\n            break\n          }\n        }\n        if (isVisible && edgeInPolygon(prev, p2)) isVisible = false\n      }\n\n      const isInAdjacentPoints = (prevPoint != null && p2.isPointEqual(prevPoint)) || (nextPoint != null && p2.isPointEqual(nextPoint))\n      if (isVisible && !isInAdjacentPoints) isVisible = !edgeInPolygon(p, p2)\n\n      // if (isVisible) visible.push(p2)\n      if (p2.isPointEqual(pt2)) return isVisible;\n      \n\n      for (let iii = 0; iii < p2.edges.length; iii++) {\n        const e = p2.edges[iii]\n        if (!e.containsPoint(p) && Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"ccw\"])(p, p2, e.getOtherPointInEdge(p2)) === 1) {\n          const k = new _EdgeKey__WEBPACK_IMPORTED_MODULE_2__[\"EdgeKey\"](p, p2, e)\n          openEdges.addKey(k)\n        }\n      }\n\n      prev = p2\n      prevVisible = isVisible\n    }\n\n    // const nodeId = createNodeId(p)\n    // g.addNode(nodeId, { x: p.x, y: p.y })\n\n    // for (var ii = 0; ii < visible.length; ii++) {\n    //   const otherNodeId = createNodeId(visible[ii])\n    //   g.addNode(otherNodeId, { x: visible[ii].x, y: visible[ii].y })\n    //   g.addLink(nodeId, otherNodeId)\n    // }\n  }\n  // return g\n}\n\nfunction createGraphFromGeoJson (geojson) {\n\n  Object(_setupStructure__WEBPACK_IMPORTED_MODULE_4__[\"setupStructure\"])(geojson, edges, points, polygons)\n\n  return processGraph()\n}\n\n  function processGraph () {\n    const g = !(function webpackMissingModule() { var e = new Error(\"Cannot find module 'ngraph.graph'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())()\n    const pointsLen = points.length\n    const clonedPoints = clonePoints()\n\n    for (var i = 0; i < pointsLen; i++) {\n      const p = points[i]\n      const prevPoint = p.prevPoint\n      const nextPoint = p.nextPoint\n\n      // sortPoints(p, clonedPoints)\n      // _renderSortedPoints(p, clonedPoints)\n\n      // const openEdges = new EdgeKeys()\n      // const pointInf = new Point([INF, p.y], null)\n      // for (let ii = 0; ii < pointsLen; ii++) {\n      //   const e = edges[ii]\n      //   if (e.containsPoint(p)) continue\n      //   if (edgeIntersect(p, pointInf, e)) {\n      //     if (onSegment(p, e.p1, pointInf) || onSegment(p, e.p2, pointInf)) continue\n      //     openEdges.addKey(new EdgeKey(p, pointInf, e))\n      //   }\n      // }\n      // // _renderOpenEdges(p, openEdges.keys)\n\n      const visible = []\n      if(i == 0)\n        visible.push(prevPoint)\n\n      visible.push(nextPoint)\n      let prev = null\n      let prevVisible = null\n\n      // for (let ii = 0; ii < pointsLen; ii++) {\n      //   const p2 = clonedPoints[ii]\n      //   if (p2.isPointEqual(p)) continue\n      //   if (p.angleToPoint(p2) > Math.pi) break\n\n      //   if (openEdges.keys.length > 0) {\n      //     for (let iii = 0; iii < p2.edges.length; iii++) {\n      //       const e = p2.edges[iii]\n      //       if (ccw(p, p2, e.getOtherPointInEdge(p2)) === -1) {\n      //         const k = new EdgeKey(p, p2, e)\n      //         const index = openEdges.findKeyPosition(k) - 1\n      //         if (index !== -1 && openEdges.keys[index].matchesOtherKey(k)) {\n      //           openEdges.keys.splice(index, 1)\n      //         }\n      //       }\n      //     }\n      //   }\n\n      //   let isVisible = false\n      //   if (prev === null || ccw(p, prev, p2) !== 0 || !onSegment(p, prev, p2)) {\n      //     if (openEdges.keys.length === 0) {\n      //       isVisible = true\n      //     } else if (!edgeIntersect(p, p2, openEdges.keys[0].edge)) {\n      //       isVisible = true\n      //     }\n      //   } else if (!prevVisible) {\n      //     isVisible = false\n      //   } else {\n      //     isVisible = true\n      //     for (let iii = 0; iii < openEdges.keys.length; iii++) {\n      //       const e = openEdges.keys[iii]\n      //       if (!e.edge.containsPoint(prev) && edgeIntersect(prev, p2, e.edge)) {\n      //         isVisible = false\n      //         break\n      //       }\n      //     }\n      //     if (isVisible && edgeInPolygon(prev, p2)) isVisible = false\n      //   }\n\n      //   const isInAdjacentPoints = p2.isPointEqual(prevPoint) || p2.isPointEqual(nextPoint)\n      //   if (isVisible && !isInAdjacentPoints) isVisible = !edgeInPolygon(p, p2)\n\n      //   if (isVisible) visible.push(p2)\n\n      //   for (let iii = 0; iii < p2.edges.length; iii++) {\n      //     const e = p2.edges[iii]\n      //     if (!e.containsPoint(p) && ccw(p, p2, e.getOtherPointInEdge(p2)) === 1) {\n      //       const k = new EdgeKey(p, p2, e)\n      //       openEdges.addKey(k)\n      //     }\n      //   }\n\n      //   prev = p2\n      //   prevVisible = isVisible\n      // }\n\n      const nodeId = createNodeId(p)\n      g.addNode(nodeId, { x: p.x, y: p.y })\n\n      for (var ii = 0; ii < visible.length; ii++) {\n        const otherNodeId = createNodeId(visible[ii])\n        g.addNode(otherNodeId, { x: visible[ii].x, y: visible[ii].y })\n        g.addLink(nodeId, otherNodeId)\n      }\n    }\n    return g\n  }\n\n  function createNodeId (p) {\n    return p.x + ',' + p.y\n  }\n\n  function clonePoints () {\n    return points.slice(0)\n  }\n\n  function sortPoints (point, clonedPoints) {\n    clonedPoints.sort((a, b) => {\n      const angle1 = point.angleToPoint(a)\n      const angle2 = point.angleToPoint(b)\n      if (angle1 < angle2) return -1\n      if (angle1 > angle2) return 1\n      const dist1 = Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"calcEdgeDistance\"])(point, a)\n      const dist2 = Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"calcEdgeDistance\"])(point, b)\n      if (dist1 < dist2) return -1\n      if (dist1 > dist2) return 1\n      return 0\n    })\n  }\n\n  function edgeInPolygon (p1, p2) {\n    if (p1.polygonID !== p2.polygonID) return false\n    if (p1.polygonID === -1 || p2.polygonID === -1) return false\n    const midPoint = new _Point__WEBPACK_IMPORTED_MODULE_3__[\"Point\"]([(p1.x + p2.x) / 2, (p1.y + p2.y) / 2], null)\n    return polygonCrossing(midPoint, polygons[p1.polygonID])\n  }\n\n  function polygonCrossing (p1, polyEdges) {\n    const p2 = new _Point__WEBPACK_IMPORTED_MODULE_3__[\"Point\"]([_utils__WEBPACK_IMPORTED_MODULE_5__[\"INF\"], p1.y], null)\n    let intersectCount = 0\n    let coFlag = false\n    let coDir = 0\n\n    for (let i = 0; i < polyEdges.length; i++) {\n      const e = polyEdges[i]\n      if (p1.y < e.p1.y && p1.y < e.p2.y) continue\n      if (p1.y > e.p1.y && p1.y > e.p2.y) continue\n      const co0 = (Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"ccw\"])(p1, e.p1, p2) === 0) && (e.p1.x > p1.x)\n      const co1 = (Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"ccw\"])(p1, e.p2, p2) === 0) && (e.p2.x > p1.x)\n      const coPoint = co0 ? e.p1 : e.p2\n      if (co0 || co1) {\n        coDir = e.getOtherPointInEdge(coPoint).y > p1.y ? coDir++ : coDir--\n        if (coFlag) {\n          if (coDir === 0) intersectCount++\n          coFlag = false\n          coDir = 0\n        } else {\n          coFlag = true\n        }\n      } else if (Object(_utils__WEBPACK_IMPORTED_MODULE_5__[\"edgeIntersect\"])(p1, p2, e)) {\n        intersectCount++\n      }\n    }\n    if (intersectCount % 2 === 0) return false\n    return true\n  }\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2NyZWF0ZUdyYXBoRnJvbUdlb0pzb24uanM/MzkzNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFzQztBQUNEO0FBQ0Y7QUFDSjtBQUNrQjtBQUM2QjtBQUNmOztBQUVsQzs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLEVBQUUsc0VBQWM7QUFDaEI7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ087QUFDUDtBQUNBO0FBQ0EsbUJBQW1CLDBDQUFJO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFlBQVksc0lBQVc7QUFDdkI7QUFDQTs7QUFFQSxpQkFBaUIsZUFBZTtBQUNoQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQkFBMEIsa0RBQVE7QUFDbEMseUJBQXlCLDRDQUFLLEVBQUUsMENBQUc7QUFDbkMsb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0EscUNBQXFDLDREQUFhO0FBQ2xELFlBQVksd0RBQVMsdUJBQXVCLHdEQUFTO0FBQ3JELDZCQUE2QixnREFBTztBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBLGNBQWMsa0RBQUc7QUFDakIsMEJBQTBCLGdEQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLGtEQUFHLHdCQUF3Qix3REFBUztBQUMvRDtBQUNBO0FBQ0EsU0FBUyxXQUFXLDRE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QzdCO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrREFBRztBQUN0QixtQkFBbUIsa0RBQUc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU8sVUFBVSw0REFBYTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi4vc3JjL2NyZWF0ZUdyYXBoRnJvbUdlb0pzb24uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3JlYXRlR3JhcGggZnJvbSAnbmdyYXBoLmdyYXBoJ1xuaW1wb3J0IHsgRWRnZUtleXMgfSBmcm9tICcuL0VkZ2VLZXlzJ1xuaW1wb3J0IHsgRWRnZUtleSB9IGZyb20gJy4vRWRnZUtleSdcbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi9Qb2ludCdcbmltcG9ydCB7IHNldHVwU3RydWN0dXJlIH0gZnJvbSAnLi9zZXR1cFN0cnVjdHVyZSdcbmltcG9ydCB7IElORiwgZWRnZUludGVyc2VjdCwgb25TZWdtZW50LCBjY3csIGNhbGNFZGdlRGlzdGFuY2UgfSBmcm9tICcuL3V0aWxzJ1xuaW1wb3J0IHsgX3JlbmRlclNvcnRlZFBvaW50cywgX3JlbmRlck9wZW5FZGdlcyB9IGZyb20gJy4vZGVidWcnIC8vZXNsaW50LWRpc2FibGUtbGluZVxuXG5pbXBvcnQgeyBFZGdlIH0gZnJvbSAnLi9FZGdlJ1xuXG5jb25zdCBwb2ludHMgPSBbXVxuY29uc3QgZWRnZXMgPSBbXVxuY29uc3QgcG9seWdvbnMgPSBbXVxudmFyIG9yaWdpbmFsUG9pbnRzTGVuZ3RoID0gMFxudmFyIG9yaWdpbmFsRWRnZXNMZW5ndGggPSAwXG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkUG9pbnRzIChnZW9qc29uKSB7XG4gIHNldHVwU3RydWN0dXJlKGdlb2pzb24sIGVkZ2VzLCBwb2ludHMsIHBvbHlnb25zKVxuICBvcmlnaW5hbFBvaW50c0xlbmd0aCA9IHBvaW50cy5sZW5ndGhcbiAgb3JpZ2luYWxFZGdlc0xlbmd0aCA9IGVkZ2VzLmxlbmd0aFxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzdG9yZU9yaWdpbmFsUG9pbnRzQW5kRWRnZXMoKSB7XG4gIHdoaWxlKHBvaW50cy5sZW5ndGggPiBvcmlnaW5hbFBvaW50c0xlbmd0aCkge1xuICAgIHBvaW50cy5wb3AoKVxuICB9XG5cbiAgd2hpbGUoZWRnZXMubGVuZ3RoID4gb3JpZ2luYWxFZGdlc0xlbmd0aCkge1xuICAgIGVkZ2VzLnBvcCgpXG4gIH1cbn1cblxuLy8gYWRkIHN0YXJ0IGFuZCBlbmQgdG8gbm9kZXMgYW5kIGNoZWNrIGZvciB2aXNpYmlsaXR5XG5leHBvcnQgZnVuY3Rpb24gZ2V0VmlzaWJsZU5vZGVzIChwdDEsIHN0YXJ0LCBlbmQpIHtcbiAgaWYoc3RhcnQgIT0gbnVsbCAmJiBlbmQgIT0gbnVsbCl7XG4gICAgLy8gZWRnZXMucHVzaChuZXcgRWRnZShwb2ludHNbcG9pbnRzLmxlbmd0aC0xXSwgc3RhcnQpKVxuICAgIGVkZ2VzLnB1c2gobmV3IEVkZ2Uoc3RhcnQsIGVuZCkpXG4gICAgLy8gZWRnZXMucHVzaChuZXcgRWRnZShlbmQsIHBvaW50c1swXSkpXG5cbiAgICAvLyBzdGFydC5wcmV2UG9pbnQgPSBwb2ludHNbcG9pbnRzLmxlbmd0aC0xXVxuICAgIC8vIHN0YXJ0Lm5leHRQb2ludCA9IGVuZFxuICAgIHN0YXJ0LnBvbHlnb25JRCA9IC0xXG5cbiAgICAvLyBlbmQucHJldlBvaW50ID0gc3RhcnRcbiAgICAvLyBlbmQubmV4dFBvaW50ID0gcG9pbnRzWzBdXG4gICAgZW5kLnBvbHlnb25JRCA9IC0xXG5cbiAgICBwb2ludHMucHVzaChzdGFydClcbiAgICBwb2ludHMucHVzaChlbmQpXG4gIH1cblxuICBjb25zdCBnID0gY3JlYXRlR3JhcGgoKVxuICBjb25zdCBwb2ludHNMZW4gPSBwb2ludHMubGVuZ3RoXG4gIGNvbnN0IGNsb25lZFBvaW50cyA9IGNsb25lUG9pbnRzKClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50c0xlbjsgaSsrKSB7XG4gICAgY29uc3QgcCA9IHBvaW50c1tpXVxuICAgIGlmICghcC5pc1BvaW50RXF1YWwocHQxKSkgY29udGludWVcblxuICAgIGNvbnN0IHByZXZQb2ludCA9IHAucHJldlBvaW50XG4gICAgY29uc3QgbmV4dFBvaW50ID0gcC5uZXh0UG9pbnRcblxuICAgIHNvcnRQb2ludHMocCwgY2xvbmVkUG9pbnRzKVxuICAgIC8vIF9yZW5kZXJTb3J0ZWRQb2ludHMocCwgY2xvbmVkUG9pbnRzKVxuXG4gICAgY29uc3Qgb3BlbkVkZ2VzID0gbmV3IEVkZ2VLZXlzKClcbiAgICBjb25zdCBwb2ludEluZiA9IG5ldyBQb2ludChbSU5GLCBwLnldLCBudWxsKVxuICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCBwb2ludHNMZW47IGlpKyspIHtcbiAgICAgIGNvbnN0IGUgPSBlZGdlc1tpaV1cbiAgICAgIGlmICh0eXBlb2YgZSAhPSAndW5kZWZpbmVkJyAmJiBlLmNvbnRhaW5zUG9pbnQocCkpIGNvbnRpbnVlXG4gICAgICBpZiAodHlwZW9mIGUgIT0gJ3VuZGVmaW5lZCcgJiYgZWRnZUludGVyc2VjdChwLCBwb2ludEluZiwgZSkpIHtcbiAgICAgICAgaWYgKG9uU2VnbWVudChwLCBlLnAxLCBwb2ludEluZikgfHwgb25TZWdtZW50KHAsIGUucDIsIHBvaW50SW5mKSkgY29udGludWVcbiAgICAgICAgb3BlbkVkZ2VzLmFkZEtleShuZXcgRWRnZUtleShwLCBwb2ludEluZiwgZSkpXG4gICAgICB9XG4gICAgfVxuICAgIC8vIC8vIF9yZW5kZXJPcGVuRWRnZXMocCwgb3BlbkVkZ2VzLmtleXMpXG5cbiAgICBjb25zdCB2aXNpYmxlID0gW11cbiAgICBpZihwcmV2UG9pbnQpIHZpc2libGUucHVzaChwcmV2UG9pbnQpXG4gICAgaWYobmV4dFBvaW50KSB2aXNpYmxlLnB1c2gobmV4dFBvaW50KVxuICAgIGxldCBwcmV2ID0gbnVsbFxuICAgIGxldCBwcmV2VmlzaWJsZSA9IG51bGxcblxuICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCBwb2ludHNMZW47IGlpKyspIHtcbiAgICAgIGNvbnN0IHAyID0gY2xvbmVkUG9pbnRzW2lpXVxuICAgICAgLy8gaWYgKCFwMi5pc1BvaW50RXF1YWwocHQyKSkgY29udGludWVcbiAgICAgIGlmIChwMi5pc1BvaW50RXF1YWwocCkpIGNvbnRpbnVlXG4gICAgICBpZiAocC5hbmdsZVRvUG9pbnQocDIpID4gTWF0aC5waSkgYnJlYWtcblxuICAgICAgaWYgKG9wZW5FZGdlcy5rZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yIChsZXQgaWlpID0gMDsgaWlpIDwgcDIuZWRnZXMubGVuZ3RoOyBpaWkrKykge1xuICAgICAgICAgIGNvbnN0IGUgPSBwMi5lZGdlc1tpaWldXG4gICAgICAgICAgaWYgKGNjdyhwLCBwMiwgZS5nZXRPdGhlclBvaW50SW5FZGdlKHAyKSkgPT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBrID0gbmV3IEVkZ2VLZXkocCwgcDIsIGUpXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IG9wZW5FZGdlcy5maW5kS2V5UG9zaXRpb24oaykgLSAxXG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xICYmIG9wZW5FZGdlcy5rZXlzW2luZGV4XS5tYXRjaGVzT3RoZXJLZXkoaykpIHtcbiAgICAgICAgICAgICAgb3BlbkVkZ2VzLmtleXMuc3BsaWNlKGluZGV4LCAxKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXQgaXNWaXNpYmxlID0gZmFsc2VcbiAgICAgIGlmIChwcmV2ID09PSBudWxsIHx8IGNjdyhwLCBwcmV2LCBwMikgIT09IDAgfHwgIW9uU2VnbWVudChwLCBwcmV2LCBwMikpIHtcbiAgICAgICAgaWYgKG9wZW5FZGdlcy5rZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGlzVmlzaWJsZSA9IHRydWVcbiAgICAgICAgfSBlbHNlIGlmICghZWRnZUludGVyc2VjdChwLCBwMiwgb3BlbkVkZ2VzLmtleXNbMF0uZWRnZSkpIHtcbiAgICAgICAgICBpc1Zpc2libGUgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIXByZXZWaXNpYmxlKSB7XG4gICAgICAgIGlzVmlzaWJsZSA9IGZhbHNlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc1Zpc2libGUgPSB0cnVlXG4gICAgICAgIGZvciAobGV0IGlpaSA9IDA7IGlpaSA8IG9wZW5FZGdlcy5rZXlzLmxlbmd0aDsgaWlpKyspIHtcbiAgICAgICAgICBjb25zdCBlID0gb3BlbkVkZ2VzLmtleXNbaWlpXVxuICAgICAgICAgIGlmICghZS5lZGdlLmNvbnRhaW5zUG9pbnQocHJldikgJiYgZWRnZUludGVyc2VjdChwcmV2LCBwMiwgZS5lZGdlKSkge1xuICAgICAgICAgICAgaXNWaXNpYmxlID0gZmFsc2VcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Zpc2libGUgJiYgZWRnZUluUG9seWdvbihwcmV2LCBwMikpIGlzVmlzaWJsZSA9IGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlzSW5BZGphY2VudFBvaW50cyA9IChwcmV2UG9pbnQgIT0gbnVsbCAmJiBwMi5pc1BvaW50RXF1YWwocHJldlBvaW50KSkgfHwgKG5leHRQb2ludCAhPSBudWxsICYmIHAyLmlzUG9pbnRFcXVhbChuZXh0UG9pbnQpKVxuICAgICAgaWYgKGlzVmlzaWJsZSAmJiAhaXNJbkFkamFjZW50UG9pbnRzKSBpc1Zpc2libGUgPSAhZWRnZUluUG9seWdvbihwLCBwMilcblxuICAgICAgaWYgKGlzVmlzaWJsZSkgdmlzaWJsZS5wdXNoKHAyKVxuICAgICAgXG5cbiAgICAgIGZvciAobGV0IGlpaSA9IDA7IGlpaSA8IHAyLmVkZ2VzLmxlbmd0aDsgaWlpKyspIHtcbiAgICAgICAgY29uc3QgZSA9IHAyLmVkZ2VzW2lpaV1cbiAgICAgICAgaWYgKCFlLmNvbnRhaW5zUG9pbnQocCkgJiYgY2N3KHAsIHAyLCBlLmdldE90aGVyUG9pbnRJbkVkZ2UocDIpKSA9PT0gMSkge1xuICAgICAgICAgIGNvbnN0IGsgPSBuZXcgRWRnZUtleShwLCBwMiwgZSlcbiAgICAgICAgICBvcGVuRWRnZXMuYWRkS2V5KGspXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHJldiA9IHAyXG4gICAgICBwcmV2VmlzaWJsZSA9IGlzVmlzaWJsZVxuICAgIH1cblxuICAgIHJldHVybiB2aXNpYmxlO1xuXG4gICAgLy8gY29uc3Qgbm9kZUlkID0gY3JlYXRlTm9kZUlkKHApXG4gICAgLy8gZy5hZGROb2RlKG5vZGVJZCwgeyB4OiBwLngsIHk6IHAueSB9KVxuXG4gICAgLy8gZm9yICh2YXIgaWkgPSAwOyBpaSA8IHZpc2libGUubGVuZ3RoOyBpaSsrKSB7XG4gICAgLy8gICBjb25zdCBvdGhlck5vZGVJZCA9IGNyZWF0ZU5vZGVJZCh2aXNpYmxlW2lpXSlcbiAgICAvLyAgIGcuYWRkTm9kZShvdGhlck5vZGVJZCwgeyB4OiB2aXNpYmxlW2lpXS54LCB5OiB2aXNpYmxlW2lpXS55IH0pXG4gICAgLy8gICBnLmFkZExpbmsobm9kZUlkLCBvdGhlck5vZGVJZClcbiAgICAvLyB9XG4gIH1cbiAgLy8gcmV0dXJuIGdcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZFN0YXJ0aW5nQW5kRW5kaW5nTm9kZXMgKHN0YXJ0LCBlbmQpIHtcbiAgLy8gZWRnZXMucHVzaChuZXcgRWRnZShwb2ludHNbcG9pbnRzLmxlbmd0aC0xXSwgc3RhcnQpKVxuICBlZGdlcy5wdXNoKG5ldyBFZGdlKHN0YXJ0LCBlbmQpKVxuICAvLyBlZGdlcy5wdXNoKG5ldyBFZGdlKGVuZCwgcG9pbnRzWzBdKSlcblxuICAvLyBzdGFydC5wcmV2UG9pbnQgPSBwb2ludHNbcG9pbnRzLmxlbmd0aC0xXVxuICAvLyBzdGFydC5uZXh0UG9pbnQgPSBlbmRcbiAgc3RhcnQucG9seWdvbklEID0gLTFcblxuICAvLyBlbmQucHJldlBvaW50ID0gc3RhcnRcbiAgLy8gZW5kLm5leHRQb2ludCA9IHBvaW50c1swXVxuICBlbmQucG9seWdvbklEID0gLTFcblxuICBwb2ludHMucHVzaChzdGFydClcbiAgcG9pbnRzLnB1c2goZW5kKVxufVxuXG5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE9ic3RydWN0aW5nRWRnZSAocHQxLCBwdDIsIHBvbHlnb25Qb2ludHMpIHtcbiAgY29uc3QgZyA9IGNyZWF0ZUdyYXBoKClcbiAgdmFyIHBvaW50cyA9IHBvbHlnb25Qb2ludHMuc2xpY2UoMClcbiAgcG9pbnRzLnB1c2gocHQxKVxuICBwb2ludHMucHVzaChwdDIpXG4gIGNvbnN0IHBvaW50c0xlbiA9IHBvaW50cy5sZW5ndGhcbiAgY29uc3QgY2xvbmVkUG9pbnRzID0gcG9pbnRzLnNsaWNlKDApXG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50c0xlbjsgaSsrKSB7XG4gICAgY29uc3QgcCA9IHBvaW50c1tpXVxuICAgIGlmICghcC5pc1BvaW50RXF1YWwocHQxKSkgY29udGludWVcblxuICAgIGNvbnN0IHByZXZQb2ludCA9IHAucHJldlBvaW50XG4gICAgY29uc3QgbmV4dFBvaW50ID0gcC5uZXh0UG9pbnRcblxuICAgIHNvcnRQb2ludHMocCwgY2xvbmVkUG9pbnRzKVxuICAgIC8vIF9yZW5kZXJTb3J0ZWRQb2ludHMocCwgY2xvbmVkUG9pbnRzKVxuXG4gICAgY29uc3Qgb3BlbkVkZ2VzID0gbmV3IEVkZ2VLZXlzKClcbiAgICBjb25zdCBwb2ludEluZiA9IG5ldyBQb2ludChbSU5GLCBwLnldLCBudWxsKVxuICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCBwb2ludHNMZW47IGlpKyspIHtcbiAgICAgIGNvbnN0IGUgPSBlZGdlc1tpaV1cbiAgICAgIGlmICh0eXBlb2YgZSAhPSAndW5kZWZpbmVkJyAmJiBlLmNvbnRhaW5zUG9pbnQocCkpIGNvbnRpbnVlXG4gICAgICBpZiAodHlwZW9mIGUgIT0gJ3VuZGVmaW5lZCcgJiYgZWRnZUludGVyc2VjdChwLCBwb2ludEluZiwgZSkpIHtcbiAgICAgICAgaWYgKG9uU2VnbWVudChwLCBlLnAxLCBwb2ludEluZikgfHwgb25TZWdtZW50KHAsIGUucDIsIHBvaW50SW5mKSkgY29udGludWVcbiAgICAgICAgb3BlbkVkZ2VzLmFkZEtleShuZXcgRWRnZUtleShwLCBwb2ludEluZiwgZSkpXG4gICAgICB9XG4gICAgfVxuICAgIC8vIC8vIF9yZW5kZXJPcGVuRWRnZXMocCwgb3BlbkVkZ2VzLmtleXMpXG5cbiAgICBjb25zdCB2aXNpYmxlID0gW11cbiAgICB2aXNpYmxlLnB1c2gocHJldlBvaW50KVxuICAgIHZpc2libGUucHVzaChuZXh0UG9pbnQpXG4gICAgbGV0IHByZXYgPSBudWxsXG4gICAgbGV0IHByZXZWaXNpYmxlID0gbnVsbFxuXG4gICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IHBvaW50c0xlbjsgaWkrKykge1xuICAgICAgY29uc3QgcDIgPSBjbG9uZWRQb2ludHNbaWldXG4gICAgICAvLyBpZiAoIXAyLmlzUG9pbnRFcXVhbChwdDIpKSBjb250aW51ZVxuXG4gICAgICBpZiAocDIuaXNQb2ludEVxdWFsKHApKSBjb250aW51ZVxuICAgICAgaWYgKHAuYW5nbGVUb1BvaW50KHAyKSA+IE1hdGgucGkpIGJyZWFrXG5cbiAgICAgIGlmIChvcGVuRWRnZXMua2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAobGV0IGlpaSA9IDA7IGlpaSA8IHAyLmVkZ2VzLmxlbmd0aDsgaWlpKyspIHtcbiAgICAgICAgICBjb25zdCBlID0gcDIuZWRnZXNbaWlpXVxuICAgICAgICAgIGlmIChjY3cocCwgcDIsIGUuZ2V0T3RoZXJQb2ludEluRWRnZShwMikpID09PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgayA9IG5ldyBFZGdlS2V5KHAsIHAyLCBlKVxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBvcGVuRWRnZXMuZmluZEtleVBvc2l0aW9uKGspIC0gMVxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSAmJiBvcGVuRWRnZXMua2V5c1tpbmRleF0ubWF0Y2hlc090aGVyS2V5KGspKSB7XG4gICAgICAgICAgICAgIG9wZW5FZGdlcy5rZXlzLnNwbGljZShpbmRleCwgMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHAyLmlzUG9pbnRFcXVhbChwdDIpKVxuICAgICAgICBwdDIgPSBwdDJcbiAgICAgIGxldCBpc1Zpc2libGUgPSBmYWxzZVxuICAgICAgaWYgKHByZXYgPT09IG51bGwgfHwgY2N3KHAsIHByZXYsIHAyKSAhPT0gMCB8fCAhb25TZWdtZW50KHAsIHByZXYsIHAyKSkge1xuICAgICAgICBpZiAob3BlbkVkZ2VzLmtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgaXNWaXNpYmxlID0gdHJ1ZVxuICAgICAgICB9IGVsc2UgaWYgKCFlZGdlSW50ZXJzZWN0KHAsIHAyLCBvcGVuRWRnZXMua2V5c1swXS5lZGdlKSkge1xuICAgICAgICAgIGlzVmlzaWJsZSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghcHJldlZpc2libGUpIHtcbiAgICAgICAgaXNWaXNpYmxlID0gZmFsc2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzVmlzaWJsZSA9IHRydWVcbiAgICAgICAgZm9yIChsZXQgaWlpID0gMDsgaWlpIDwgb3BlbkVkZ2VzLmtleXMubGVuZ3RoOyBpaWkrKykge1xuICAgICAgICAgIGNvbnN0IGUgPSBvcGVuRWRnZXMua2V5c1tpaWldXG4gICAgICAgICAgaWYgKCFlLmVkZ2UuY29udGFpbnNQb2ludChwcmV2KSAmJiBlZGdlSW50ZXJzZWN0KHByZXYsIHAyLCBlLmVkZ2UpKSB7XG4gICAgICAgICAgICBpc1Zpc2libGUgPSBmYWxzZVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVmlzaWJsZSAmJiBlZGdlSW5Qb2x5Z29uKHByZXYsIHAyKSkgaXNWaXNpYmxlID0gZmFsc2VcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXNJbkFkamFjZW50UG9pbnRzID0gKHByZXZQb2ludCAhPSBudWxsICYmIHAyLmlzUG9pbnRFcXVhbChwcmV2UG9pbnQpKSB8fCAobmV4dFBvaW50ICE9IG51bGwgJiYgcDIuaXNQb2ludEVxdWFsKG5leHRQb2ludCkpXG4gICAgICBpZiAoaXNWaXNpYmxlICYmICFpc0luQWRqYWNlbnRQb2ludHMpIGlzVmlzaWJsZSA9ICFlZGdlSW5Qb2x5Z29uKHAsIHAyKVxuXG4gICAgICAvLyBpZiBzYW1lIHBvbHlnb24gdmlzaXNibGVcbiAgICAgIGlmIChwLnBvbHlnb25JRCA9PSBwMi5wb2x5Z29uSUQgJiYgcC5wb2x5Z29uSUQgIT0gLTEpXG4gICAgICAgIGlzVmlzaWJsZSA9IHRydWVcblxuICAgICAgLy8gaWYgKGlzVmlzaWJsZSkgdmlzaWJsZS5wdXNoKHAyKVxuICAgICAgaWYgKHAyLmlzUG9pbnRFcXVhbChwdDIpKVxuICAgICAgIHJldHVybiBpc1Zpc2libGUgPyBudWxsIDogb3BlbkVkZ2VzLmtleXNbMF0uZWRnZTtcbiAgICAgIFxuXG4gICAgICBmb3IgKGxldCBpaWkgPSAwOyBpaWkgPCBwMi5lZGdlcy5sZW5ndGg7IGlpaSsrKSB7XG4gICAgICAgIGNvbnN0IGUgPSBwMi5lZGdlc1tpaWldXG4gICAgICAgIGlmICghZS5jb250YWluc1BvaW50KHApICYmIGNjdyhwLCBwMiwgZS5nZXRPdGhlclBvaW50SW5FZGdlKHAyKSkgPT09IDEpIHtcbiAgICAgICAgICBjb25zdCBrID0gbmV3IEVkZ2VLZXkocCwgcDIsIGUpXG4gICAgICAgICAgb3BlbkVkZ2VzLmFkZEtleShrKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHByZXYgPSBwMlxuICAgICAgcHJldlZpc2libGUgPSBpc1Zpc2libGVcbiAgICB9XG5cbiAgICAvLyBjb25zdCBub2RlSWQgPSBjcmVhdGVOb2RlSWQocClcbiAgICAvLyBnLmFkZE5vZGUobm9kZUlkLCB7IHg6IHAueCwgeTogcC55IH0pXG5cbiAgICAvLyBmb3IgKHZhciBpaSA9IDA7IGlpIDwgdmlzaWJsZS5sZW5ndGg7IGlpKyspIHtcbiAgICAvLyAgIGNvbnN0IG90aGVyTm9kZUlkID0gY3JlYXRlTm9kZUlkKHZpc2libGVbaWldKVxuICAgIC8vICAgZy5hZGROb2RlKG90aGVyTm9kZUlkLCB7IHg6IHZpc2libGVbaWldLngsIHk6IHZpc2libGVbaWldLnkgfSlcbiAgICAvLyAgIGcuYWRkTGluayhub2RlSWQsIG90aGVyTm9kZUlkKVxuICAgIC8vIH1cbiAgfVxuICAvLyByZXR1cm4gZ1xufVxuXG4vLyBleHBvcnQgZnVuY3Rpb24gZ2V0T2JzdHJ1Y3RpbmdFZGdlIChwdDEsIHB0Mikge1xuLy8gICBjb25zdCBnID0gY3JlYXRlR3JhcGgoKVxuLy8gICBjb25zdCBwb2ludHNMZW4gPSBwb2ludHMubGVuZ3RoXG4vLyAgIGNvbnN0IGNsb25lZFBvaW50cyA9IGNsb25lUG9pbnRzKClcblxuLy8gICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50c0xlbjsgaSsrKSB7XG4vLyAgICAgY29uc3QgcCA9IHBvaW50c1tpXVxuLy8gICAgIGlmICghcC5pc1BvaW50RXF1YWwocHQxKSkgY29udGludWVcblxuLy8gICAgIGNvbnN0IHByZXZQb2ludCA9IHAucHJldlBvaW50XG4vLyAgICAgY29uc3QgbmV4dFBvaW50ID0gcC5uZXh0UG9pbnRcblxuLy8gICAgIHNvcnRQb2ludHMocCwgY2xvbmVkUG9pbnRzKVxuLy8gICAgIC8vIF9yZW5kZXJTb3J0ZWRQb2ludHMocCwgY2xvbmVkUG9pbnRzKVxuXG4vLyAgICAgY29uc3Qgb3BlbkVkZ2VzID0gbmV3IEVkZ2VLZXlzKClcbi8vICAgICBjb25zdCBwb2ludEluZiA9IG5ldyBQb2ludChbSU5GLCBwLnldLCBudWxsKVxuLy8gICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCBwb2ludHNMZW47IGlpKyspIHtcbi8vICAgICAgIGNvbnN0IGUgPSBlZGdlc1tpaV1cbi8vICAgICAgIGlmICh0eXBlb2YgZSAhPSAndW5kZWZpbmVkJyAmJiBlLmNvbnRhaW5zUG9pbnQocCkpIGNvbnRpbnVlXG4vLyAgICAgICBpZiAodHlwZW9mIGUgIT0gJ3VuZGVmaW5lZCcgJiYgZWRnZUludGVyc2VjdChwLCBwb2ludEluZiwgZSkpIHtcbi8vICAgICAgICAgaWYgKG9uU2VnbWVudChwLCBlLnAxLCBwb2ludEluZikgfHwgb25TZWdtZW50KHAsIGUucDIsIHBvaW50SW5mKSkgY29udGludWVcbi8vICAgICAgICAgb3BlbkVkZ2VzLmFkZEtleShuZXcgRWRnZUtleShwLCBwb2ludEluZiwgZSkpXG4vLyAgICAgICB9XG4vLyAgICAgfVxuLy8gICAgIC8vIC8vIF9yZW5kZXJPcGVuRWRnZXMocCwgb3BlbkVkZ2VzLmtleXMpXG5cbi8vICAgICBjb25zdCB2aXNpYmxlID0gW11cbi8vICAgICB2aXNpYmxlLnB1c2gocHJldlBvaW50KVxuLy8gICAgIHZpc2libGUucHVzaChuZXh0UG9pbnQpXG4vLyAgICAgbGV0IHByZXYgPSBudWxsXG4vLyAgICAgbGV0IHByZXZWaXNpYmxlID0gbnVsbFxuXG4vLyAgICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IHBvaW50c0xlbjsgaWkrKykge1xuLy8gICAgICAgY29uc3QgcDIgPSBjbG9uZWRQb2ludHNbaWldXG4vLyAgICAgICAvLyBpZiAoIXAyLmlzUG9pbnRFcXVhbChwdDIpKSBjb250aW51ZVxuXG4vLyAgICAgICBpZiAocDIuaXNQb2ludEVxdWFsKHApKSBjb250aW51ZVxuLy8gICAgICAgaWYgKHAuYW5nbGVUb1BvaW50KHAyKSA+IE1hdGgucGkpIGJyZWFrXG5cbi8vICAgICAgIGlmIChvcGVuRWRnZXMua2V5cy5sZW5ndGggPiAwKSB7XG4vLyAgICAgICAgIGZvciAobGV0IGlpaSA9IDA7IGlpaSA8IHAyLmVkZ2VzLmxlbmd0aDsgaWlpKyspIHtcbi8vICAgICAgICAgICBjb25zdCBlID0gcDIuZWRnZXNbaWlpXVxuLy8gICAgICAgICAgIGlmIChjY3cocCwgcDIsIGUuZ2V0T3RoZXJQb2ludEluRWRnZShwMikpID09PSAtMSkge1xuLy8gICAgICAgICAgICAgY29uc3QgayA9IG5ldyBFZGdlS2V5KHAsIHAyLCBlKVxuLy8gICAgICAgICAgICAgY29uc3QgaW5kZXggPSBvcGVuRWRnZXMuZmluZEtleVBvc2l0aW9uKGspIC0gMVxuLy8gICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSAmJiBvcGVuRWRnZXMua2V5c1tpbmRleF0ubWF0Y2hlc090aGVyS2V5KGspKSB7XG4vLyAgICAgICAgICAgICAgIG9wZW5FZGdlcy5rZXlzLnNwbGljZShpbmRleCwgMSlcbi8vICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICB9XG4vLyAgICAgICAgIH1cbi8vICAgICAgIH1cblxuLy8gICAgICAgaWYgKHAyLmlzUG9pbnRFcXVhbChwdDIpKVxuLy8gICAgICAgICBwdDIgPSBwdDJcbi8vICAgICAgIGxldCBpc1Zpc2libGUgPSBmYWxzZVxuLy8gICAgICAgaWYgKHByZXYgPT09IG51bGwgfHwgY2N3KHAsIHByZXYsIHAyKSAhPT0gMCB8fCAhb25TZWdtZW50KHAsIHByZXYsIHAyKSkge1xuLy8gICAgICAgICBpZiAob3BlbkVkZ2VzLmtleXMubGVuZ3RoID09PSAwKSB7XG4vLyAgICAgICAgICAgaXNWaXNpYmxlID0gdHJ1ZVxuLy8gICAgICAgICB9IGVsc2UgaWYgKCFlZGdlSW50ZXJzZWN0KHAsIHAyLCBvcGVuRWRnZXMua2V5c1swXS5lZGdlKSkge1xuLy8gICAgICAgICAgIGlzVmlzaWJsZSA9IHRydWVcbi8vICAgICAgICAgfVxuLy8gICAgICAgfSBlbHNlIGlmICghcHJldlZpc2libGUpIHtcbi8vICAgICAgICAgaXNWaXNpYmxlID0gZmFsc2Vcbi8vICAgICAgIH0gZWxzZSB7XG4vLyAgICAgICAgIGlzVmlzaWJsZSA9IHRydWVcbi8vICAgICAgICAgZm9yIChsZXQgaWlpID0gMDsgaWlpIDwgb3BlbkVkZ2VzLmtleXMubGVuZ3RoOyBpaWkrKykge1xuLy8gICAgICAgICAgIGNvbnN0IGUgPSBvcGVuRWRnZXMua2V5c1tpaWldXG4vLyAgICAgICAgICAgaWYgKCFlLmVkZ2UuY29udGFpbnNQb2ludChwcmV2KSAmJiBlZGdlSW50ZXJzZWN0KHByZXYsIHAyLCBlLmVkZ2UpKSB7XG4vLyAgICAgICAgICAgICBpc1Zpc2libGUgPSBmYWxzZVxuLy8gICAgICAgICAgICAgYnJlYWtcbi8vICAgICAgICAgICB9XG4vLyAgICAgICAgIH1cbi8vICAgICAgICAgaWYgKGlzVmlzaWJsZSAmJiBlZGdlSW5Qb2x5Z29uKHByZXYsIHAyKSkgaXNWaXNpYmxlID0gZmFsc2Vcbi8vICAgICAgIH1cblxuLy8gICAgICAgY29uc3QgaXNJbkFkamFjZW50UG9pbnRzID0gKHByZXZQb2ludCAhPSBudWxsICYmIHAyLmlzUG9pbnRFcXVhbChwcmV2UG9pbnQpKSB8fCAobmV4dFBvaW50ICE9IG51bGwgJiYgcDIuaXNQb2ludEVxdWFsKG5leHRQb2ludCkpXG4vLyAgICAgICBpZiAoaXNWaXNpYmxlICYmICFpc0luQWRqYWNlbnRQb2ludHMpIGlzVmlzaWJsZSA9ICFlZGdlSW5Qb2x5Z29uKHAsIHAyKVxuXG4vLyAgICAgICAvLyBpZiBzYW1lIHBvbHlnb24gdmlzaXNibGVcbi8vICAgICAgIGlmIChwLnBvbHlnb25JRCA9PSBwMi5wb2x5Z29uSUQgJiYgcC5wb2x5Z29uSUQgIT0gLTEpXG4vLyAgICAgICAgIGlzVmlzaWJsZSA9IHRydWVcblxuLy8gICAgICAgLy8gaWYgKGlzVmlzaWJsZSkgdmlzaWJsZS5wdXNoKHAyKVxuLy8gICAgICAgaWYgKHAyLmlzUG9pbnRFcXVhbChwdDIpKVxuLy8gICAgICAgIHJldHVybiBpc1Zpc2libGUgPyBudWxsIDogb3BlbkVkZ2VzLmtleXNbMF0uZWRnZTtcbiAgICAgIFxuXG4vLyAgICAgICBmb3IgKGxldCBpaWkgPSAwOyBpaWkgPCBwMi5lZGdlcy5sZW5ndGg7IGlpaSsrKSB7XG4vLyAgICAgICAgIGNvbnN0IGUgPSBwMi5lZGdlc1tpaWldXG4vLyAgICAgICAgIGlmICghZS5jb250YWluc1BvaW50KHApICYmIGNjdyhwLCBwMiwgZS5nZXRPdGhlclBvaW50SW5FZGdlKHAyKSkgPT09IDEpIHtcbi8vICAgICAgICAgICBjb25zdCBrID0gbmV3IEVkZ2VLZXkocCwgcDIsIGUpXG4vLyAgICAgICAgICAgb3BlbkVkZ2VzLmFkZEtleShrKVxuLy8gICAgICAgICB9XG4vLyAgICAgICB9XG5cbi8vICAgICAgIHByZXYgPSBwMlxuLy8gICAgICAgcHJldlZpc2libGUgPSBpc1Zpc2libGVcbi8vICAgICB9XG5cbi8vICAgICAvLyBjb25zdCBub2RlSWQgPSBjcmVhdGVOb2RlSWQocClcbi8vICAgICAvLyBnLmFkZE5vZGUobm9kZUlkLCB7IHg6IHAueCwgeTogcC55IH0pXG5cbi8vICAgICAvLyBmb3IgKHZhciBpaSA9IDA7IGlpIDwgdmlzaWJsZS5sZW5ndGg7IGlpKyspIHtcbi8vICAgICAvLyAgIGNvbnN0IG90aGVyTm9kZUlkID0gY3JlYXRlTm9kZUlkKHZpc2libGVbaWldKVxuLy8gICAgIC8vICAgZy5hZGROb2RlKG90aGVyTm9kZUlkLCB7IHg6IHZpc2libGVbaWldLngsIHk6IHZpc2libGVbaWldLnkgfSlcbi8vICAgICAvLyAgIGcuYWRkTGluayhub2RlSWQsIG90aGVyTm9kZUlkKVxuLy8gICAgIC8vIH1cbi8vICAgfVxuLy8gICAvLyByZXR1cm4gZ1xuLy8gfVxuXG5leHBvcnQgZnVuY3Rpb24gaXNWaXNpYmxlIChwdDEsIHB0Mikge1xuICBjb25zdCBnID0gY3JlYXRlR3JhcGgoKVxuICBjb25zdCBwb2ludHNMZW4gPSBwb2ludHMubGVuZ3RoXG4gIGNvbnN0IGNsb25lZFBvaW50cyA9IGNsb25lUG9pbnRzKClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50c0xlbjsgaSsrKSB7XG4gICAgY29uc3QgcCA9IHBvaW50c1tpXVxuICAgIGlmICghcC5pc1BvaW50RXF1YWwocHQxKSkgY29udGludWVcblxuICAgIGNvbnN0IHByZXZQb2ludCA9IHAucHJldlBvaW50XG4gICAgY29uc3QgbmV4dFBvaW50ID0gcC5uZXh0UG9pbnRcblxuICAgIHNvcnRQb2ludHMocCwgY2xvbmVkUG9pbnRzKVxuICAgIC8vIF9yZW5kZXJTb3J0ZWRQb2ludHMocCwgY2xvbmVkUG9pbnRzKVxuXG4gICAgY29uc3Qgb3BlbkVkZ2VzID0gbmV3IEVkZ2VLZXlzKClcbiAgICBjb25zdCBwb2ludEluZiA9IG5ldyBQb2ludChbSU5GLCBwLnldLCBudWxsKVxuICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCBwb2ludHNMZW47IGlpKyspIHtcbiAgICAgIGNvbnN0IGUgPSBlZGdlc1tpaV1cbiAgICAgIGlmICh0eXBlb2YgZSAhPSAndW5kZWZpbmVkJyAmJiBlLmNvbnRhaW5zUG9pbnQocCkpIGNvbnRpbnVlXG4gICAgICBpZiAodHlwZW9mIGUgIT0gJ3VuZGVmaW5lZCcgJiYgZWRnZUludGVyc2VjdChwLCBwb2ludEluZiwgZSkpIHtcbiAgICAgICAgaWYgKG9uU2VnbWVudChwLCBlLnAxLCBwb2ludEluZikgfHwgb25TZWdtZW50KHAsIGUucDIsIHBvaW50SW5mKSkgY29udGludWVcbiAgICAgICAgb3BlbkVkZ2VzLmFkZEtleShuZXcgRWRnZUtleShwLCBwb2ludEluZiwgZSkpXG4gICAgICB9XG4gICAgfVxuICAgIC8vIC8vIF9yZW5kZXJPcGVuRWRnZXMocCwgb3BlbkVkZ2VzLmtleXMpXG5cbiAgICBjb25zdCB2aXNpYmxlID0gW11cbiAgICB2aXNpYmxlLnB1c2gocHJldlBvaW50KVxuICAgIHZpc2libGUucHVzaChuZXh0UG9pbnQpXG4gICAgbGV0IHByZXYgPSBudWxsXG4gICAgbGV0IHByZXZWaXNpYmxlID0gbnVsbFxuXG4gICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IHBvaW50c0xlbjsgaWkrKykge1xuICAgICAgY29uc3QgcDIgPSBjbG9uZWRQb2ludHNbaWldXG4gICAgICAvLyBpZiAoIXAyLmlzUG9pbnRFcXVhbChwdDIpKSBjb250aW51ZVxuXG4gICAgICBpZiAocDIuaXNQb2ludEVxdWFsKHApKSBjb250aW51ZVxuICAgICAgaWYgKHAuYW5nbGVUb1BvaW50KHAyKSA+IE1hdGgucGkpIGJyZWFrXG5cbiAgICAgIGlmIChvcGVuRWRnZXMua2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAobGV0IGlpaSA9IDA7IGlpaSA8IHAyLmVkZ2VzLmxlbmd0aDsgaWlpKyspIHtcbiAgICAgICAgICBjb25zdCBlID0gcDIuZWRnZXNbaWlpXVxuICAgICAgICAgIGlmIChjY3cocCwgcDIsIGUuZ2V0T3RoZXJQb2ludEluRWRnZShwMikpID09PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgayA9IG5ldyBFZGdlS2V5KHAsIHAyLCBlKVxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBvcGVuRWRnZXMuZmluZEtleVBvc2l0aW9uKGspIC0gMVxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSAmJiBvcGVuRWRnZXMua2V5c1tpbmRleF0ubWF0Y2hlc090aGVyS2V5KGspKSB7XG4gICAgICAgICAgICAgIG9wZW5FZGdlcy5rZXlzLnNwbGljZShpbmRleCwgMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHAyLmlzUG9pbnRFcXVhbChwdDIpKVxuICAgICAgICBwdDIgPSBwdDJcbiAgICAgIGxldCBpc1Zpc2libGUgPSBmYWxzZVxuICAgICAgaWYgKHByZXYgPT09IG51bGwgfHwgY2N3KHAsIHByZXYsIHAyKSAhPT0gMCB8fCAhb25TZWdtZW50KHAsIHByZXYsIHAyKSkge1xuICAgICAgICBpZiAob3BlbkVkZ2VzLmtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgaXNWaXNpYmxlID0gdHJ1ZVxuICAgICAgICB9IGVsc2UgaWYgKCFlZGdlSW50ZXJzZWN0KHAsIHAyLCBvcGVuRWRnZXMua2V5c1swXS5lZGdlKSkge1xuICAgICAgICAgIGlzVmlzaWJsZSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghcHJldlZpc2libGUpIHtcbiAgICAgICAgaXNWaXNpYmxlID0gZmFsc2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzVmlzaWJsZSA9IHRydWVcbiAgICAgICAgZm9yIChsZXQgaWlpID0gMDsgaWlpIDwgb3BlbkVkZ2VzLmtleXMubGVuZ3RoOyBpaWkrKykge1xuICAgICAgICAgIGNvbnN0IGUgPSBvcGVuRWRnZXMua2V5c1tpaWldXG4gICAgICAgICAgaWYgKCFlLmVkZ2UuY29udGFpbnNQb2ludChwcmV2KSAmJiBlZGdlSW50ZXJzZWN0KHByZXYsIHAyLCBlLmVkZ2UpKSB7XG4gICAgICAgICAgICBpc1Zpc2libGUgPSBmYWxzZVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVmlzaWJsZSAmJiBlZGdlSW5Qb2x5Z29uKHByZXYsIHAyKSkgaXNWaXNpYmxlID0gZmFsc2VcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXNJbkFkamFjZW50UG9pbnRzID0gKHByZXZQb2ludCAhPSBudWxsICYmIHAyLmlzUG9pbnRFcXVhbChwcmV2UG9pbnQpKSB8fCAobmV4dFBvaW50ICE9IG51bGwgJiYgcDIuaXNQb2ludEVxdWFsKG5leHRQb2ludCkpXG4gICAgICBpZiAoaXNWaXNpYmxlICYmICFpc0luQWRqYWNlbnRQb2ludHMpIGlzVmlzaWJsZSA9ICFlZGdlSW5Qb2x5Z29uKHAsIHAyKVxuXG4gICAgICAvLyBpZiAoaXNWaXNpYmxlKSB2aXNpYmxlLnB1c2gocDIpXG4gICAgICBpZiAocDIuaXNQb2ludEVxdWFsKHB0MikpIHJldHVybiBpc1Zpc2libGU7XG4gICAgICBcblxuICAgICAgZm9yIChsZXQgaWlpID0gMDsgaWlpIDwgcDIuZWRnZXMubGVuZ3RoOyBpaWkrKykge1xuICAgICAgICBjb25zdCBlID0gcDIuZWRnZXNbaWlpXVxuICAgICAgICBpZiAoIWUuY29udGFpbnNQb2ludChwKSAmJiBjY3cocCwgcDIsIGUuZ2V0T3RoZXJQb2ludEluRWRnZShwMikpID09PSAxKSB7XG4gICAgICAgICAgY29uc3QgayA9IG5ldyBFZGdlS2V5KHAsIHAyLCBlKVxuICAgICAgICAgIG9wZW5FZGdlcy5hZGRLZXkoaylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcmV2ID0gcDJcbiAgICAgIHByZXZWaXNpYmxlID0gaXNWaXNpYmxlXG4gICAgfVxuXG4gICAgLy8gY29uc3Qgbm9kZUlkID0gY3JlYXRlTm9kZUlkKHApXG4gICAgLy8gZy5hZGROb2RlKG5vZGVJZCwgeyB4OiBwLngsIHk6IHAueSB9KVxuXG4gICAgLy8gZm9yICh2YXIgaWkgPSAwOyBpaSA8IHZpc2libGUubGVuZ3RoOyBpaSsrKSB7XG4gICAgLy8gICBjb25zdCBvdGhlck5vZGVJZCA9IGNyZWF0ZU5vZGVJZCh2aXNpYmxlW2lpXSlcbiAgICAvLyAgIGcuYWRkTm9kZShvdGhlck5vZGVJZCwgeyB4OiB2aXNpYmxlW2lpXS54LCB5OiB2aXNpYmxlW2lpXS55IH0pXG4gICAgLy8gICBnLmFkZExpbmsobm9kZUlkLCBvdGhlck5vZGVJZClcbiAgICAvLyB9XG4gIH1cbiAgLy8gcmV0dXJuIGdcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUdyYXBoRnJvbUdlb0pzb24gKGdlb2pzb24pIHtcblxuICBzZXR1cFN0cnVjdHVyZShnZW9qc29uLCBlZGdlcywgcG9pbnRzLCBwb2x5Z29ucylcblxuICByZXR1cm4gcHJvY2Vzc0dyYXBoKClcbn1cblxuICBmdW5jdGlvbiBwcm9jZXNzR3JhcGggKCkge1xuICAgIGNvbnN0IGcgPSBjcmVhdGVHcmFwaCgpXG4gICAgY29uc3QgcG9pbnRzTGVuID0gcG9pbnRzLmxlbmd0aFxuICAgIGNvbnN0IGNsb25lZFBvaW50cyA9IGNsb25lUG9pbnRzKClcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzTGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IHAgPSBwb2ludHNbaV1cbiAgICAgIGNvbnN0IHByZXZQb2ludCA9IHAucHJldlBvaW50XG4gICAgICBjb25zdCBuZXh0UG9pbnQgPSBwLm5leHRQb2ludFxuXG4gICAgICAvLyBzb3J0UG9pbnRzKHAsIGNsb25lZFBvaW50cylcbiAgICAgIC8vIF9yZW5kZXJTb3J0ZWRQb2ludHMocCwgY2xvbmVkUG9pbnRzKVxuXG4gICAgICAvLyBjb25zdCBvcGVuRWRnZXMgPSBuZXcgRWRnZUtleXMoKVxuICAgICAgLy8gY29uc3QgcG9pbnRJbmYgPSBuZXcgUG9pbnQoW0lORiwgcC55XSwgbnVsbClcbiAgICAgIC8vIGZvciAobGV0IGlpID0gMDsgaWkgPCBwb2ludHNMZW47IGlpKyspIHtcbiAgICAgIC8vICAgY29uc3QgZSA9IGVkZ2VzW2lpXVxuICAgICAgLy8gICBpZiAoZS5jb250YWluc1BvaW50KHApKSBjb250aW51ZVxuICAgICAgLy8gICBpZiAoZWRnZUludGVyc2VjdChwLCBwb2ludEluZiwgZSkpIHtcbiAgICAgIC8vICAgICBpZiAob25TZWdtZW50KHAsIGUucDEsIHBvaW50SW5mKSB8fCBvblNlZ21lbnQocCwgZS5wMiwgcG9pbnRJbmYpKSBjb250aW51ZVxuICAgICAgLy8gICAgIG9wZW5FZGdlcy5hZGRLZXkobmV3IEVkZ2VLZXkocCwgcG9pbnRJbmYsIGUpKVxuICAgICAgLy8gICB9XG4gICAgICAvLyB9XG4gICAgICAvLyAvLyBfcmVuZGVyT3BlbkVkZ2VzKHAsIG9wZW5FZGdlcy5rZXlzKVxuXG4gICAgICBjb25zdCB2aXNpYmxlID0gW11cbiAgICAgIGlmKGkgPT0gMClcbiAgICAgICAgdmlzaWJsZS5wdXNoKHByZXZQb2ludClcblxuICAgICAgdmlzaWJsZS5wdXNoKG5leHRQb2ludClcbiAgICAgIGxldCBwcmV2ID0gbnVsbFxuICAgICAgbGV0IHByZXZWaXNpYmxlID0gbnVsbFxuXG4gICAgICAvLyBmb3IgKGxldCBpaSA9IDA7IGlpIDwgcG9pbnRzTGVuOyBpaSsrKSB7XG4gICAgICAvLyAgIGNvbnN0IHAyID0gY2xvbmVkUG9pbnRzW2lpXVxuICAgICAgLy8gICBpZiAocDIuaXNQb2ludEVxdWFsKHApKSBjb250aW51ZVxuICAgICAgLy8gICBpZiAocC5hbmdsZVRvUG9pbnQocDIpID4gTWF0aC5waSkgYnJlYWtcblxuICAgICAgLy8gICBpZiAob3BlbkVkZ2VzLmtleXMubGVuZ3RoID4gMCkge1xuICAgICAgLy8gICAgIGZvciAobGV0IGlpaSA9IDA7IGlpaSA8IHAyLmVkZ2VzLmxlbmd0aDsgaWlpKyspIHtcbiAgICAgIC8vICAgICAgIGNvbnN0IGUgPSBwMi5lZGdlc1tpaWldXG4gICAgICAvLyAgICAgICBpZiAoY2N3KHAsIHAyLCBlLmdldE90aGVyUG9pbnRJbkVkZ2UocDIpKSA9PT0gLTEpIHtcbiAgICAgIC8vICAgICAgICAgY29uc3QgayA9IG5ldyBFZGdlS2V5KHAsIHAyLCBlKVxuICAgICAgLy8gICAgICAgICBjb25zdCBpbmRleCA9IG9wZW5FZGdlcy5maW5kS2V5UG9zaXRpb24oaykgLSAxXG4gICAgICAvLyAgICAgICAgIGlmIChpbmRleCAhPT0gLTEgJiYgb3BlbkVkZ2VzLmtleXNbaW5kZXhdLm1hdGNoZXNPdGhlcktleShrKSkge1xuICAgICAgLy8gICAgICAgICAgIG9wZW5FZGdlcy5rZXlzLnNwbGljZShpbmRleCwgMSlcbiAgICAgIC8vICAgICAgICAgfVxuICAgICAgLy8gICAgICAgfVxuICAgICAgLy8gICAgIH1cbiAgICAgIC8vICAgfVxuXG4gICAgICAvLyAgIGxldCBpc1Zpc2libGUgPSBmYWxzZVxuICAgICAgLy8gICBpZiAocHJldiA9PT0gbnVsbCB8fCBjY3cocCwgcHJldiwgcDIpICE9PSAwIHx8ICFvblNlZ21lbnQocCwgcHJldiwgcDIpKSB7XG4gICAgICAvLyAgICAgaWYgKG9wZW5FZGdlcy5rZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gICAgICAgaXNWaXNpYmxlID0gdHJ1ZVxuICAgICAgLy8gICAgIH0gZWxzZSBpZiAoIWVkZ2VJbnRlcnNlY3QocCwgcDIsIG9wZW5FZGdlcy5rZXlzWzBdLmVkZ2UpKSB7XG4gICAgICAvLyAgICAgICBpc1Zpc2libGUgPSB0cnVlXG4gICAgICAvLyAgICAgfVxuICAgICAgLy8gICB9IGVsc2UgaWYgKCFwcmV2VmlzaWJsZSkge1xuICAgICAgLy8gICAgIGlzVmlzaWJsZSA9IGZhbHNlXG4gICAgICAvLyAgIH0gZWxzZSB7XG4gICAgICAvLyAgICAgaXNWaXNpYmxlID0gdHJ1ZVxuICAgICAgLy8gICAgIGZvciAobGV0IGlpaSA9IDA7IGlpaSA8IG9wZW5FZGdlcy5rZXlzLmxlbmd0aDsgaWlpKyspIHtcbiAgICAgIC8vICAgICAgIGNvbnN0IGUgPSBvcGVuRWRnZXMua2V5c1tpaWldXG4gICAgICAvLyAgICAgICBpZiAoIWUuZWRnZS5jb250YWluc1BvaW50KHByZXYpICYmIGVkZ2VJbnRlcnNlY3QocHJldiwgcDIsIGUuZWRnZSkpIHtcbiAgICAgIC8vICAgICAgICAgaXNWaXNpYmxlID0gZmFsc2VcbiAgICAgIC8vICAgICAgICAgYnJlYWtcbiAgICAgIC8vICAgICAgIH1cbiAgICAgIC8vICAgICB9XG4gICAgICAvLyAgICAgaWYgKGlzVmlzaWJsZSAmJiBlZGdlSW5Qb2x5Z29uKHByZXYsIHAyKSkgaXNWaXNpYmxlID0gZmFsc2VcbiAgICAgIC8vICAgfVxuXG4gICAgICAvLyAgIGNvbnN0IGlzSW5BZGphY2VudFBvaW50cyA9IHAyLmlzUG9pbnRFcXVhbChwcmV2UG9pbnQpIHx8IHAyLmlzUG9pbnRFcXVhbChuZXh0UG9pbnQpXG4gICAgICAvLyAgIGlmIChpc1Zpc2libGUgJiYgIWlzSW5BZGphY2VudFBvaW50cykgaXNWaXNpYmxlID0gIWVkZ2VJblBvbHlnb24ocCwgcDIpXG5cbiAgICAgIC8vICAgaWYgKGlzVmlzaWJsZSkgdmlzaWJsZS5wdXNoKHAyKVxuXG4gICAgICAvLyAgIGZvciAobGV0IGlpaSA9IDA7IGlpaSA8IHAyLmVkZ2VzLmxlbmd0aDsgaWlpKyspIHtcbiAgICAgIC8vICAgICBjb25zdCBlID0gcDIuZWRnZXNbaWlpXVxuICAgICAgLy8gICAgIGlmICghZS5jb250YWluc1BvaW50KHApICYmIGNjdyhwLCBwMiwgZS5nZXRPdGhlclBvaW50SW5FZGdlKHAyKSkgPT09IDEpIHtcbiAgICAgIC8vICAgICAgIGNvbnN0IGsgPSBuZXcgRWRnZUtleShwLCBwMiwgZSlcbiAgICAgIC8vICAgICAgIG9wZW5FZGdlcy5hZGRLZXkoaylcbiAgICAgIC8vICAgICB9XG4gICAgICAvLyAgIH1cblxuICAgICAgLy8gICBwcmV2ID0gcDJcbiAgICAgIC8vICAgcHJldlZpc2libGUgPSBpc1Zpc2libGVcbiAgICAgIC8vIH1cblxuICAgICAgY29uc3Qgbm9kZUlkID0gY3JlYXRlTm9kZUlkKHApXG4gICAgICBnLmFkZE5vZGUobm9kZUlkLCB7IHg6IHAueCwgeTogcC55IH0pXG5cbiAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCB2aXNpYmxlLmxlbmd0aDsgaWkrKykge1xuICAgICAgICBjb25zdCBvdGhlck5vZGVJZCA9IGNyZWF0ZU5vZGVJZCh2aXNpYmxlW2lpXSlcbiAgICAgICAgZy5hZGROb2RlKG90aGVyTm9kZUlkLCB7IHg6IHZpc2libGVbaWldLngsIHk6IHZpc2libGVbaWldLnkgfSlcbiAgICAgICAgZy5hZGRMaW5rKG5vZGVJZCwgb3RoZXJOb2RlSWQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBnXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVOb2RlSWQgKHApIHtcbiAgICByZXR1cm4gcC54ICsgJywnICsgcC55XG4gIH1cblxuICBmdW5jdGlvbiBjbG9uZVBvaW50cyAoKSB7XG4gICAgcmV0dXJuIHBvaW50cy5zbGljZSgwKVxuICB9XG5cbiAgZnVuY3Rpb24gc29ydFBvaW50cyAocG9pbnQsIGNsb25lZFBvaW50cykge1xuICAgIGNsb25lZFBvaW50cy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBjb25zdCBhbmdsZTEgPSBwb2ludC5hbmdsZVRvUG9pbnQoYSlcbiAgICAgIGNvbnN0IGFuZ2xlMiA9IHBvaW50LmFuZ2xlVG9Qb2ludChiKVxuICAgICAgaWYgKGFuZ2xlMSA8IGFuZ2xlMikgcmV0dXJuIC0xXG4gICAgICBpZiAoYW5nbGUxID4gYW5nbGUyKSByZXR1cm4gMVxuICAgICAgY29uc3QgZGlzdDEgPSBjYWxjRWRnZURpc3RhbmNlKHBvaW50LCBhKVxuICAgICAgY29uc3QgZGlzdDIgPSBjYWxjRWRnZURpc3RhbmNlKHBvaW50LCBiKVxuICAgICAgaWYgKGRpc3QxIDwgZGlzdDIpIHJldHVybiAtMVxuICAgICAgaWYgKGRpc3QxID4gZGlzdDIpIHJldHVybiAxXG4gICAgICByZXR1cm4gMFxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBlZGdlSW5Qb2x5Z29uIChwMSwgcDIpIHtcbiAgICBpZiAocDEucG9seWdvbklEICE9PSBwMi5wb2x5Z29uSUQpIHJldHVybiBmYWxzZVxuICAgIGlmIChwMS5wb2x5Z29uSUQgPT09IC0xIHx8IHAyLnBvbHlnb25JRCA9PT0gLTEpIHJldHVybiBmYWxzZVxuICAgIGNvbnN0IG1pZFBvaW50ID0gbmV3IFBvaW50KFsocDEueCArIHAyLngpIC8gMiwgKHAxLnkgKyBwMi55KSAvIDJdLCBudWxsKVxuICAgIHJldHVybiBwb2x5Z29uQ3Jvc3NpbmcobWlkUG9pbnQsIHBvbHlnb25zW3AxLnBvbHlnb25JRF0pXG4gIH1cblxuICBmdW5jdGlvbiBwb2x5Z29uQ3Jvc3NpbmcgKHAxLCBwb2x5RWRnZXMpIHtcbiAgICBjb25zdCBwMiA9IG5ldyBQb2ludChbSU5GLCBwMS55XSwgbnVsbClcbiAgICBsZXQgaW50ZXJzZWN0Q291bnQgPSAwXG4gICAgbGV0IGNvRmxhZyA9IGZhbHNlXG4gICAgbGV0IGNvRGlyID0gMFxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2x5RWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGUgPSBwb2x5RWRnZXNbaV1cbiAgICAgIGlmIChwMS55IDwgZS5wMS55ICYmIHAxLnkgPCBlLnAyLnkpIGNvbnRpbnVlXG4gICAgICBpZiAocDEueSA+IGUucDEueSAmJiBwMS55ID4gZS5wMi55KSBjb250aW51ZVxuICAgICAgY29uc3QgY28wID0gKGNjdyhwMSwgZS5wMSwgcDIpID09PSAwKSAmJiAoZS5wMS54ID4gcDEueClcbiAgICAgIGNvbnN0IGNvMSA9IChjY3cocDEsIGUucDIsIHAyKSA9PT0gMCkgJiYgKGUucDIueCA+IHAxLngpXG4gICAgICBjb25zdCBjb1BvaW50ID0gY28wID8gZS5wMSA6IGUucDJcbiAgICAgIGlmIChjbzAgfHwgY28xKSB7XG4gICAgICAgIGNvRGlyID0gZS5nZXRPdGhlclBvaW50SW5FZGdlKGNvUG9pbnQpLnkgPiBwMS55ID8gY29EaXIrKyA6IGNvRGlyLS1cbiAgICAgICAgaWYgKGNvRmxhZykge1xuICAgICAgICAgIGlmIChjb0RpciA9PT0gMCkgaW50ZXJzZWN0Q291bnQrK1xuICAgICAgICAgIGNvRmxhZyA9IGZhbHNlXG4gICAgICAgICAgY29EaXIgPSAwXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29GbGFnID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVkZ2VJbnRlcnNlY3QocDEsIHAyLCBlKSkge1xuICAgICAgICBpbnRlcnNlY3RDb3VudCsrXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpbnRlcnNlY3RDb3VudCAlIDIgPT09IDApIHJldHVybiBmYWxzZVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../src/createGraphFromGeoJson.js\n");

/***/ }),

/***/ "../src/debug.js":
/*!***********************!*\
  !*** ../src/debug.js ***!
  \***********************/
/*! exports provided: _renderSortedPoints, _renderOpenEdges */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_renderSortedPoints\", function() { return _renderSortedPoints; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_renderOpenEdges\", function() { return _renderOpenEdges; });\n\nfunction _renderSortedPoints (point, sortedPoints) {\n  const map = window.map\n  var sortedPointsLg = null\n\n  L.NumberedDivIcon = createNumberDiv()\n\n  setCurrentPoint(point)\n\n  if (sortedPointsLg === null) sortedPointsLg = L.layerGroup([]).addTo(map)\n  else sortedPointsLg.clearLayers()\n  sortedPoints.forEach((p, index) => {\n    return L.marker([p.y, p.x], {\n      color: 'black',\n      icon: new L.NumberedDivIcon({ number: index.toString() })\n    }).addTo(sortedPointsLg)\n  })\n\n  // debugger\n}\n\nfunction _renderOpenEdges (point, edges) {\n  const map = window.map\n  const currentPoint = L.circleMarker([point.y, point.x], {\n    radius: 20,\n    color: 'green'\n  }).addTo(map)\n  var openEdges = L.layerGroup([]).addTo(map)\n\n  edges.forEach((e, index) => {\n    L.polyline([[e.edge.p1.y, e.edge.p1.x], [e.edge.p2.y, e.edge.p2.x]], {\n      color: 'red'\n    }).addTo(openEdges)\n  })\n\n  // debugger\n  openEdges.clearLayers()\n  map.removeLayer(currentPoint)\n}\n\nfunction setCurrentPoint (point) {\n  const map = window.map\n  let currentPoint = null\n\n  if (currentPoint !== null) map.removeLayer(currentPoint)\n\n  currentPoint = L.circleMarker([point.y, point.x], {\n    radius: 20,\n    color: 'green'\n  }).addTo(map)\n\n}\n\nfunction createNumberDiv () {\n  return L.Icon.extend({\n    options: {\n      number: '',\n      iconSize: new L.Point(25, 25),\n      className: 'leaflet-div-icon'\n    },\n    createIcon: function () {\n      var div = document.createElement('div')\n      var numdiv = document.createElement('div')\n      numdiv.setAttribute('class', 'number')\n      numdiv.innerHTML = this.options['number'] || ''\n      div.appendChild(numdiv)\n      this._setIconStyles(div, 'icon')\n      return div\n    }\n  })\n}\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2RlYnVnLmpzP2M5MWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUNPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDJCQUEyQjtBQUM5RCxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsImZpbGUiOiIuLi9zcmMvZGVidWcuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmV4cG9ydCBmdW5jdGlvbiBfcmVuZGVyU29ydGVkUG9pbnRzIChwb2ludCwgc29ydGVkUG9pbnRzKSB7XG4gIGNvbnN0IG1hcCA9IHdpbmRvdy5tYXBcbiAgdmFyIHNvcnRlZFBvaW50c0xnID0gbnVsbFxuXG4gIEwuTnVtYmVyZWREaXZJY29uID0gY3JlYXRlTnVtYmVyRGl2KClcblxuICBzZXRDdXJyZW50UG9pbnQocG9pbnQpXG5cbiAgaWYgKHNvcnRlZFBvaW50c0xnID09PSBudWxsKSBzb3J0ZWRQb2ludHNMZyA9IEwubGF5ZXJHcm91cChbXSkuYWRkVG8obWFwKVxuICBlbHNlIHNvcnRlZFBvaW50c0xnLmNsZWFyTGF5ZXJzKClcbiAgc29ydGVkUG9pbnRzLmZvckVhY2goKHAsIGluZGV4KSA9PiB7XG4gICAgcmV0dXJuIEwubWFya2VyKFtwLnksIHAueF0sIHtcbiAgICAgIGNvbG9yOiAnYmxhY2snLFxuICAgICAgaWNvbjogbmV3IEwuTnVtYmVyZWREaXZJY29uKHsgbnVtYmVyOiBpbmRleC50b1N0cmluZygpIH0pXG4gICAgfSkuYWRkVG8oc29ydGVkUG9pbnRzTGcpXG4gIH0pXG5cbiAgLy8gZGVidWdnZXJcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9yZW5kZXJPcGVuRWRnZXMgKHBvaW50LCBlZGdlcykge1xuICBjb25zdCBtYXAgPSB3aW5kb3cubWFwXG4gIGNvbnN0IGN1cnJlbnRQb2ludCA9IEwuY2lyY2xlTWFya2VyKFtwb2ludC55LCBwb2ludC54XSwge1xuICAgIHJhZGl1czogMjAsXG4gICAgY29sb3I6ICdncmVlbidcbiAgfSkuYWRkVG8obWFwKVxuICB2YXIgb3BlbkVkZ2VzID0gTC5sYXllckdyb3VwKFtdKS5hZGRUbyhtYXApXG5cbiAgZWRnZXMuZm9yRWFjaCgoZSwgaW5kZXgpID0+IHtcbiAgICBMLnBvbHlsaW5lKFtbZS5lZGdlLnAxLnksIGUuZWRnZS5wMS54XSwgW2UuZWRnZS5wMi55LCBlLmVkZ2UucDIueF1dLCB7XG4gICAgICBjb2xvcjogJ3JlZCdcbiAgICB9KS5hZGRUbyhvcGVuRWRnZXMpXG4gIH0pXG5cbiAgLy8gZGVidWdnZXJcbiAgb3BlbkVkZ2VzLmNsZWFyTGF5ZXJzKClcbiAgbWFwLnJlbW92ZUxheWVyKGN1cnJlbnRQb2ludClcbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudFBvaW50IChwb2ludCkge1xuICBjb25zdCBtYXAgPSB3aW5kb3cubWFwXG4gIGxldCBjdXJyZW50UG9pbnQgPSBudWxsXG5cbiAgaWYgKGN1cnJlbnRQb2ludCAhPT0gbnVsbCkgbWFwLnJlbW92ZUxheWVyKGN1cnJlbnRQb2ludClcblxuICBjdXJyZW50UG9pbnQgPSBMLmNpcmNsZU1hcmtlcihbcG9pbnQueSwgcG9pbnQueF0sIHtcbiAgICByYWRpdXM6IDIwLFxuICAgIGNvbG9yOiAnZ3JlZW4nXG4gIH0pLmFkZFRvKG1hcClcblxufVxuXG5mdW5jdGlvbiBjcmVhdGVOdW1iZXJEaXYgKCkge1xuICByZXR1cm4gTC5JY29uLmV4dGVuZCh7XG4gICAgb3B0aW9uczoge1xuICAgICAgbnVtYmVyOiAnJyxcbiAgICAgIGljb25TaXplOiBuZXcgTC5Qb2ludCgyNSwgMjUpLFxuICAgICAgY2xhc3NOYW1lOiAnbGVhZmxldC1kaXYtaWNvbidcbiAgICB9LFxuICAgIGNyZWF0ZUljb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgdmFyIG51bWRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICBudW1kaXYuc2V0QXR0cmlidXRlKCdjbGFzcycsICdudW1iZXInKVxuICAgICAgbnVtZGl2LmlubmVySFRNTCA9IHRoaXMub3B0aW9uc1snbnVtYmVyJ10gfHwgJydcbiAgICAgIGRpdi5hcHBlbmRDaGlsZChudW1kaXYpXG4gICAgICB0aGlzLl9zZXRJY29uU3R5bGVzKGRpdiwgJ2ljb24nKVxuICAgICAgcmV0dXJuIGRpdlxuICAgIH1cbiAgfSlcbn1cblxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../src/debug.js\n");

/***/ }),

/***/ "../src/main.js":
/*!**********************!*\
  !*** ../src/main.js ***!
  \**********************/
/*! exports provided: createGraphFromGeoJson, getVisibleNodes, isVisible, loadPoints, restoreOriginalPointsAndEdges, getObstructingEdge, addStartingAndEndingNodes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _createGraphFromGeoJson__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createGraphFromGeoJson */ \"../src/createGraphFromGeoJson.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createGraphFromGeoJson\", function() { return _createGraphFromGeoJson__WEBPACK_IMPORTED_MODULE_0__[\"createGraphFromGeoJson\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getVisibleNodes\", function() { return _createGraphFromGeoJson__WEBPACK_IMPORTED_MODULE_0__[\"getVisibleNodes\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"isVisible\", function() { return _createGraphFromGeoJson__WEBPACK_IMPORTED_MODULE_0__[\"isVisible\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"loadPoints\", function() { return _createGraphFromGeoJson__WEBPACK_IMPORTED_MODULE_0__[\"loadPoints\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"restoreOriginalPointsAndEdges\", function() { return _createGraphFromGeoJson__WEBPACK_IMPORTED_MODULE_0__[\"restoreOriginalPointsAndEdges\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getObstructingEdge\", function() { return _createGraphFromGeoJson__WEBPACK_IMPORTED_MODULE_0__[\"getObstructingEdge\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"addStartingAndEndingNodes\", function() { return _createGraphFromGeoJson__WEBPACK_IMPORTED_MODULE_0__[\"addStartingAndEndingNodes\"]; });\n\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL21haW4uanM/ZDNmZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUF1TCIsImZpbGUiOiIuLi9zcmMvbWFpbi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IGNyZWF0ZUdyYXBoRnJvbUdlb0pzb24sIGdldFZpc2libGVOb2RlcywgaXNWaXNpYmxlLCBsb2FkUG9pbnRzLCByZXN0b3JlT3JpZ2luYWxQb2ludHNBbmRFZGdlcywgZ2V0T2JzdHJ1Y3RpbmdFZGdlLCBhZGRTdGFydGluZ0FuZEVuZGluZ05vZGVzIH0gZnJvbSAnLi9jcmVhdGVHcmFwaEZyb21HZW9Kc29uJ1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../src/main.js\n");

/***/ }),

/***/ "../src/setupStructure.js":
/*!********************************!*\
  !*** ../src/setupStructure.js ***!
  \********************************/
/*! exports provided: setupStructure */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setupStructure\", function() { return setupStructure; });\n/* harmony import */ var _Point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Point */ \"../src/Point.js\");\n/* harmony import */ var _Edge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Edge */ \"../src/Edge.js\");\n\n\n\nfunction setupStructure (geojson, edges, points, polygons) {\n  const geom = geojson.type === 'Feature' ? geojson.geometry : geojson\n\n  let coords = geom.features\n\n  // standardise the input\n  if (geom.type === 'Polygon') coords = [coords]\n\n  for (let i = 0; i < coords.length; i++) {\n    const contour = []\n    polygons.push(contour)\n\n    for (let ii = 0; ii < coords[i].geometry.coordinates.length; ii++) {\n      let prevPoint = new _Point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"](coords[i].geometry.coordinates[ii][0], i)\n      let currentPoint = new _Point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"](coords[i].geometry.coordinates[ii][1], i)\n      prevPoint.nextPoint = currentPoint\n      let nextPoint = new _Point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"](coords[i].geometry.coordinates[ii][2], i)\n      linkPoints(prevPoint, currentPoint, nextPoint)\n\n      points.push(prevPoint)\n\n      let prevEdge = new _Edge__WEBPACK_IMPORTED_MODULE_1__[\"Edge\"](prevPoint, currentPoint) // eslint-disable-line\n      edges.push(prevEdge)\n      contour.push(prevEdge)\n\n      // Save me for later\n      const firstPoint = prevPoint\n\n      prevPoint = currentPoint\n      currentPoint = nextPoint\n\n      for (let iii = 2; iii < coords[i].geometry.coordinates[ii].length - 2; iii++) {\n        points.push(prevPoint)\n\n        nextPoint = new _Point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"](coords[i].geometry.coordinates[ii][iii + 1], i)\n\n        linkPoints(prevPoint, currentPoint, nextPoint)\n\n        const e = new _Edge__WEBPACK_IMPORTED_MODULE_1__[\"Edge\"](prevPoint, currentPoint) // eslint-disable-line\n\n        edges.push(e)\n        contour.push(e)\n\n        prevPoint = currentPoint\n        currentPoint = nextPoint\n        prevEdge = e\n      }\n\n      linkPoints(prevPoint, currentPoint, firstPoint)\n\n      const secondLastEdge = new _Edge__WEBPACK_IMPORTED_MODULE_1__[\"Edge\"](prevEdge.p2, currentPoint)\n\n      edges.push(secondLastEdge)\n      contour.push(secondLastEdge)\n\n      const lastEdge = new _Edge__WEBPACK_IMPORTED_MODULE_1__[\"Edge\"](currentPoint, firstPoint) // eslint-disable-line\n      linkPoints(currentPoint, firstPoint, firstPoint.nextPoint)\n\n      edges.push(lastEdge)\n      contour.push(lastEdge)\n\n      points.push(prevPoint)\n      points.push(nextPoint)\n    }\n  }\n}\n\n// export function setupStructure (geojson, edges, points, polygons) {\n//   const geom = geojson.type === 'Feature' ? geojson.geometry : geojson\n\n//   let coords = geom.coordinates\n\n//   // standardise the input\n//   if (geom.type === 'Polygon') coords = [coords]\n\n//   for (let i = 0; i < coords.length; i++) {\n//     const contour = []\n//     polygons.push(contour)\n\n//     for (let ii = 0; ii < coords[i].length; ii++) {\n//       let prevPoint = new Point(coords[i][ii][0], i)\n//       let currentPoint = new Point(coords[i][ii][1], i)\n//       prevPoint.nextPoint = currentPoint\n//       let nextPoint = new Point(coords[i][ii][2], i)\n//       linkPoints(prevPoint, currentPoint, nextPoint)\n\n//       points.push(prevPoint)\n\n//       let prevEdge = new Edge(prevPoint, currentPoint) // eslint-disable-line\n//       edges.push(prevEdge)\n//       contour.push(prevEdge)\n\n//       // Save me for later\n//       const firstPoint = prevPoint\n\n//       prevPoint = currentPoint\n//       currentPoint = nextPoint\n\n//       for (let iii = 2; iii < coords[i][ii].length - 2; iii++) {\n//         points.push(prevPoint)\n\n//         nextPoint = new Point(coords[i][ii][iii + 1], i)\n\n//         linkPoints(prevPoint, currentPoint, nextPoint)\n\n//         const e = new Edge(prevPoint, currentPoint) // eslint-disable-line\n\n//         edges.push(e)\n//         contour.push(e)\n\n//         prevPoint = currentPoint\n//         currentPoint = nextPoint\n//         prevEdge = e\n//       }\n\n//       linkPoints(prevPoint, currentPoint, firstPoint)\n\n//       const secondLastEdge = new Edge(prevEdge.p2, currentPoint)\n\n//       edges.push(secondLastEdge)\n//       contour.push(secondLastEdge)\n\n//       const lastEdge = new Edge(currentPoint, firstPoint) // eslint-disable-line\n//       linkPoints(currentPoint, firstPoint, firstPoint.nextPoint)\n\n//       edges.push(lastEdge)\n//       contour.push(lastEdge)\n\n//       points.push(prevPoint)\n//       points.push(nextPoint)\n//     }\n//   }\n// }\n\nfunction linkPoints (prevPoint, currentPoint, nextPoint) {\n  currentPoint.prevPoint = prevPoint\n  currentPoint.nextPoint = nextPoint\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL3NldHVwU3RydWN0dXJlLmpzPzI2ZmEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBK0I7QUFDRjs7QUFFdEI7QUFDUDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTs7QUFFQSxvQkFBb0IsNENBQTRDO0FBQ2hFLDBCQUEwQiw0Q0FBSztBQUMvQiw2QkFBNkIsNENBQUs7QUFDbEM7QUFDQSwwQkFBMEIsNENBQUs7QUFDL0I7O0FBRUE7O0FBRUEseUJBQXlCLDBDQUFJO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1QixxREFBcUQ7QUFDNUU7O0FBRUEsd0JBQXdCLDRDQUFLOztBQUU3Qjs7QUFFQSxzQkFBc0IsMENBQUk7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUNBQWlDLDBDQUFJOztBQUVyQztBQUNBOztBQUVBLDJCQUEyQiwwQ0FBSTtBQUMvQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTs7QUFFQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQkFBMEIsZ0NBQWdDO0FBQzFEOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuLi9zcmMvc2V0dXBTdHJ1Y3R1cmUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQb2ludCB9IGZyb20gJy4vUG9pbnQnXG5pbXBvcnQgeyBFZGdlIH0gZnJvbSAnLi9FZGdlJ1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0dXBTdHJ1Y3R1cmUgKGdlb2pzb24sIGVkZ2VzLCBwb2ludHMsIHBvbHlnb25zKSB7XG4gIGNvbnN0IGdlb20gPSBnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlJyA/IGdlb2pzb24uZ2VvbWV0cnkgOiBnZW9qc29uXG5cbiAgbGV0IGNvb3JkcyA9IGdlb20uZmVhdHVyZXNcblxuICAvLyBzdGFuZGFyZGlzZSB0aGUgaW5wdXRcbiAgaWYgKGdlb20udHlwZSA9PT0gJ1BvbHlnb24nKSBjb29yZHMgPSBbY29vcmRzXVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY29udG91ciA9IFtdXG4gICAgcG9seWdvbnMucHVzaChjb250b3VyKVxuXG4gICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IGNvb3Jkc1tpXS5nZW9tZXRyeS5jb29yZGluYXRlcy5sZW5ndGg7IGlpKyspIHtcbiAgICAgIGxldCBwcmV2UG9pbnQgPSBuZXcgUG9pbnQoY29vcmRzW2ldLmdlb21ldHJ5LmNvb3JkaW5hdGVzW2lpXVswXSwgaSlcbiAgICAgIGxldCBjdXJyZW50UG9pbnQgPSBuZXcgUG9pbnQoY29vcmRzW2ldLmdlb21ldHJ5LmNvb3JkaW5hdGVzW2lpXVsxXSwgaSlcbiAgICAgIHByZXZQb2ludC5uZXh0UG9pbnQgPSBjdXJyZW50UG9pbnRcbiAgICAgIGxldCBuZXh0UG9pbnQgPSBuZXcgUG9pbnQoY29vcmRzW2ldLmdlb21ldHJ5LmNvb3JkaW5hdGVzW2lpXVsyXSwgaSlcbiAgICAgIGxpbmtQb2ludHMocHJldlBvaW50LCBjdXJyZW50UG9pbnQsIG5leHRQb2ludClcblxuICAgICAgcG9pbnRzLnB1c2gocHJldlBvaW50KVxuXG4gICAgICBsZXQgcHJldkVkZ2UgPSBuZXcgRWRnZShwcmV2UG9pbnQsIGN1cnJlbnRQb2ludCkgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgZWRnZXMucHVzaChwcmV2RWRnZSlcbiAgICAgIGNvbnRvdXIucHVzaChwcmV2RWRnZSlcblxuICAgICAgLy8gU2F2ZSBtZSBmb3IgbGF0ZXJcbiAgICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBwcmV2UG9pbnRcblxuICAgICAgcHJldlBvaW50ID0gY3VycmVudFBvaW50XG4gICAgICBjdXJyZW50UG9pbnQgPSBuZXh0UG9pbnRcblxuICAgICAgZm9yIChsZXQgaWlpID0gMjsgaWlpIDwgY29vcmRzW2ldLmdlb21ldHJ5LmNvb3JkaW5hdGVzW2lpXS5sZW5ndGggLSAyOyBpaWkrKykge1xuICAgICAgICBwb2ludHMucHVzaChwcmV2UG9pbnQpXG5cbiAgICAgICAgbmV4dFBvaW50ID0gbmV3IFBvaW50KGNvb3Jkc1tpXS5nZW9tZXRyeS5jb29yZGluYXRlc1tpaV1baWlpICsgMV0sIGkpXG5cbiAgICAgICAgbGlua1BvaW50cyhwcmV2UG9pbnQsIGN1cnJlbnRQb2ludCwgbmV4dFBvaW50KVxuXG4gICAgICAgIGNvbnN0IGUgPSBuZXcgRWRnZShwcmV2UG9pbnQsIGN1cnJlbnRQb2ludCkgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgICAgIGVkZ2VzLnB1c2goZSlcbiAgICAgICAgY29udG91ci5wdXNoKGUpXG5cbiAgICAgICAgcHJldlBvaW50ID0gY3VycmVudFBvaW50XG4gICAgICAgIGN1cnJlbnRQb2ludCA9IG5leHRQb2ludFxuICAgICAgICBwcmV2RWRnZSA9IGVcbiAgICAgIH1cblxuICAgICAgbGlua1BvaW50cyhwcmV2UG9pbnQsIGN1cnJlbnRQb2ludCwgZmlyc3RQb2ludClcblxuICAgICAgY29uc3Qgc2Vjb25kTGFzdEVkZ2UgPSBuZXcgRWRnZShwcmV2RWRnZS5wMiwgY3VycmVudFBvaW50KVxuXG4gICAgICBlZGdlcy5wdXNoKHNlY29uZExhc3RFZGdlKVxuICAgICAgY29udG91ci5wdXNoKHNlY29uZExhc3RFZGdlKVxuXG4gICAgICBjb25zdCBsYXN0RWRnZSA9IG5ldyBFZGdlKGN1cnJlbnRQb2ludCwgZmlyc3RQb2ludCkgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgbGlua1BvaW50cyhjdXJyZW50UG9pbnQsIGZpcnN0UG9pbnQsIGZpcnN0UG9pbnQubmV4dFBvaW50KVxuXG4gICAgICBlZGdlcy5wdXNoKGxhc3RFZGdlKVxuICAgICAgY29udG91ci5wdXNoKGxhc3RFZGdlKVxuXG4gICAgICBwb2ludHMucHVzaChwcmV2UG9pbnQpXG4gICAgICBwb2ludHMucHVzaChuZXh0UG9pbnQpXG4gICAgfVxuICB9XG59XG5cbi8vIGV4cG9ydCBmdW5jdGlvbiBzZXR1cFN0cnVjdHVyZSAoZ2VvanNvbiwgZWRnZXMsIHBvaW50cywgcG9seWdvbnMpIHtcbi8vICAgY29uc3QgZ2VvbSA9IGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmUnID8gZ2VvanNvbi5nZW9tZXRyeSA6IGdlb2pzb25cblxuLy8gICBsZXQgY29vcmRzID0gZ2VvbS5jb29yZGluYXRlc1xuXG4vLyAgIC8vIHN0YW5kYXJkaXNlIHRoZSBpbnB1dFxuLy8gICBpZiAoZ2VvbS50eXBlID09PSAnUG9seWdvbicpIGNvb3JkcyA9IFtjb29yZHNdXG5cbi8vICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcbi8vICAgICBjb25zdCBjb250b3VyID0gW11cbi8vICAgICBwb2x5Z29ucy5wdXNoKGNvbnRvdXIpXG5cbi8vICAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgY29vcmRzW2ldLmxlbmd0aDsgaWkrKykge1xuLy8gICAgICAgbGV0IHByZXZQb2ludCA9IG5ldyBQb2ludChjb29yZHNbaV1baWldWzBdLCBpKVxuLy8gICAgICAgbGV0IGN1cnJlbnRQb2ludCA9IG5ldyBQb2ludChjb29yZHNbaV1baWldWzFdLCBpKVxuLy8gICAgICAgcHJldlBvaW50Lm5leHRQb2ludCA9IGN1cnJlbnRQb2ludFxuLy8gICAgICAgbGV0IG5leHRQb2ludCA9IG5ldyBQb2ludChjb29yZHNbaV1baWldWzJdLCBpKVxuLy8gICAgICAgbGlua1BvaW50cyhwcmV2UG9pbnQsIGN1cnJlbnRQb2ludCwgbmV4dFBvaW50KVxuXG4vLyAgICAgICBwb2ludHMucHVzaChwcmV2UG9pbnQpXG5cbi8vICAgICAgIGxldCBwcmV2RWRnZSA9IG5ldyBFZGdlKHByZXZQb2ludCwgY3VycmVudFBvaW50KSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4vLyAgICAgICBlZGdlcy5wdXNoKHByZXZFZGdlKVxuLy8gICAgICAgY29udG91ci5wdXNoKHByZXZFZGdlKVxuXG4vLyAgICAgICAvLyBTYXZlIG1lIGZvciBsYXRlclxuLy8gICAgICAgY29uc3QgZmlyc3RQb2ludCA9IHByZXZQb2ludFxuXG4vLyAgICAgICBwcmV2UG9pbnQgPSBjdXJyZW50UG9pbnRcbi8vICAgICAgIGN1cnJlbnRQb2ludCA9IG5leHRQb2ludFxuXG4vLyAgICAgICBmb3IgKGxldCBpaWkgPSAyOyBpaWkgPCBjb29yZHNbaV1baWldLmxlbmd0aCAtIDI7IGlpaSsrKSB7XG4vLyAgICAgICAgIHBvaW50cy5wdXNoKHByZXZQb2ludClcblxuLy8gICAgICAgICBuZXh0UG9pbnQgPSBuZXcgUG9pbnQoY29vcmRzW2ldW2lpXVtpaWkgKyAxXSwgaSlcblxuLy8gICAgICAgICBsaW5rUG9pbnRzKHByZXZQb2ludCwgY3VycmVudFBvaW50LCBuZXh0UG9pbnQpXG5cbi8vICAgICAgICAgY29uc3QgZSA9IG5ldyBFZGdlKHByZXZQb2ludCwgY3VycmVudFBvaW50KSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbi8vICAgICAgICAgZWRnZXMucHVzaChlKVxuLy8gICAgICAgICBjb250b3VyLnB1c2goZSlcblxuLy8gICAgICAgICBwcmV2UG9pbnQgPSBjdXJyZW50UG9pbnRcbi8vICAgICAgICAgY3VycmVudFBvaW50ID0gbmV4dFBvaW50XG4vLyAgICAgICAgIHByZXZFZGdlID0gZVxuLy8gICAgICAgfVxuXG4vLyAgICAgICBsaW5rUG9pbnRzKHByZXZQb2ludCwgY3VycmVudFBvaW50LCBmaXJzdFBvaW50KVxuXG4vLyAgICAgICBjb25zdCBzZWNvbmRMYXN0RWRnZSA9IG5ldyBFZGdlKHByZXZFZGdlLnAyLCBjdXJyZW50UG9pbnQpXG5cbi8vICAgICAgIGVkZ2VzLnB1c2goc2Vjb25kTGFzdEVkZ2UpXG4vLyAgICAgICBjb250b3VyLnB1c2goc2Vjb25kTGFzdEVkZ2UpXG5cbi8vICAgICAgIGNvbnN0IGxhc3RFZGdlID0gbmV3IEVkZ2UoY3VycmVudFBvaW50LCBmaXJzdFBvaW50KSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4vLyAgICAgICBsaW5rUG9pbnRzKGN1cnJlbnRQb2ludCwgZmlyc3RQb2ludCwgZmlyc3RQb2ludC5uZXh0UG9pbnQpXG5cbi8vICAgICAgIGVkZ2VzLnB1c2gobGFzdEVkZ2UpXG4vLyAgICAgICBjb250b3VyLnB1c2gobGFzdEVkZ2UpXG5cbi8vICAgICAgIHBvaW50cy5wdXNoKHByZXZQb2ludClcbi8vICAgICAgIHBvaW50cy5wdXNoKG5leHRQb2ludClcbi8vICAgICB9XG4vLyAgIH1cbi8vIH1cblxuZnVuY3Rpb24gbGlua1BvaW50cyAocHJldlBvaW50LCBjdXJyZW50UG9pbnQsIG5leHRQb2ludCkge1xuICBjdXJyZW50UG9pbnQucHJldlBvaW50ID0gcHJldlBvaW50XG4gIGN1cnJlbnRQb2ludC5uZXh0UG9pbnQgPSBuZXh0UG9pbnRcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../src/setupStructure.js\n");

/***/ }),

/***/ "../src/utils.js":
/*!***********************!*\
  !*** ../src/utils.js ***!
  \***********************/
/*! exports provided: pi1, pi2, INF, edgeIntersect, ccw, onSegment, angle2, pointEdgeDistance, intersectPoint, calcEdgeDistance */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pi1\", function() { return pi1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pi2\", function() { return pi2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"INF\", function() { return INF; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"edgeIntersect\", function() { return edgeIntersect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ccw\", function() { return ccw; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"onSegment\", function() { return onSegment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"angle2\", function() { return angle2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pointEdgeDistance\", function() { return pointEdgeDistance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"intersectPoint\", function() { return intersectPoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"calcEdgeDistance\", function() { return calcEdgeDistance; });\n/* harmony import */ var _Point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Point */ \"../src/Point.js\");\n\n\nconst pi1 = Math.PI * 3 / 2\nconst pi2 = Math.PI / 2\n\nconst INF = 10000\nconst COLIN_TOLERANCE = 13\nconst T = Math.pow(10, COLIN_TOLERANCE)\nconst T2 = Math.pow(10.0, COLIN_TOLERANCE)\n\nfunction edgeIntersect (p1, q1, edge) {\n  const p2 = edge.p1\n  const q2 = edge.p2\n  const o1 = ccw(p1, q1, p2)\n  const o2 = ccw(p1, q1, q2)\n  const o3 = ccw(p2, q2, p1)\n  const o4 = ccw(p2, q2, q1)\n  if (o1 !== o2 && o3 !== o4) return true\n  if (o1 === 0 && onSegment(p1, p2, q1)) return true\n  if (o2 === 0 && onSegment(p1, q2, q1)) return true\n  if (o3 === 0 && onSegment(p2, p1, q2)) return true\n  if (o4 === 0 && onSegment(p2, q1, q2)) return true\n  return false\n}\n\nfunction ccw (a, b, c) {\n  const area = Math.round(((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) * T) / T2\n  if (area > 0) return 1\n  if (area < 0) return -1\n  return 0\n}\n\nfunction onSegment (p, q, r) {\n  if (q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x)) {\n    if (q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y)) return true\n  }\n  return false\n}\n\nfunction angle2 (p1, p2, p3) {\n  const a = Math.pow((p3.x - p2.x), 2) + Math.pow((p3.y - p2.y), 2)\n  const b = Math.pow((p3.x - p1.x), 2) + Math.pow((p3.y - p1.y), 2)\n  const c = Math.pow((p2.x - p1.x), 2) + Math.pow((p2.y - p1.y), 2)\n  return Math.acos((a + c - b) / (2 * Math.sqrt(a) * Math.sqrt(c)))\n}\n\nfunction pointEdgeDistance (p1, p2, edge) {\n  const ip = intersectPoint(p1, p2, edge)\n  return ip !== null ? calcEdgeDistance(p1, ip) : 0\n}\n\nfunction intersectPoint (p1, p2, edge) {\n  if (edge.containsPoint(p1)) return p1\n  if (edge.containsPoint(p2)) return p2\n  if (edge.p1.x === edge.p2.x) {\n    if (p1.x === p2.x) return null\n    const pslope = (p1.y - p2.y) / (p1.x - p2.x)\n    const intersectX = edge.p1.x\n    const intersectY = pslope * (intersectX - p1.x) + p1.y\n    return new _Point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"]([intersectX, intersectY], null)\n  }\n  if (p1.x === p2.x) {\n    const eslope = (edge.p1.y - edge.p2.y) / (edge.p1.x - edge.p2.x)\n    const intersectX = p1.x\n    const intersectY = eslope * (intersectX - edge.p1.x) + edge.p1.y\n    return new _Point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"]([intersectX, intersectY], null)\n  }\n\n  const pslope = (p1.y - p2.y) / (p1.x - p2.x)\n  const eslope = (edge.p1.y - edge.p2.y) / (edge.p1.x - edge.p2.x)\n\n  if (pslope === eslope) return null\n  const intersectX = (eslope * edge.p1.x - pslope * p1.x + p1.y - edge.p1.y) / (eslope - pslope)\n  const intersectY = eslope * (intersectX - edge.p1.x) + edge.p1.y\n  return new _Point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"]([intersectX, intersectY], null)\n}\n\nfunction calcEdgeDistance (p1, p2) {\n  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2))\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL3V0aWxzLmpzPzUwZjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQStCOztBQUV4QjtBQUNBOztBQUVBO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNENBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNENBQUs7QUFDcEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDRDQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQSIsImZpbGUiOiIuLi9zcmMvdXRpbHMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQb2ludCB9IGZyb20gJy4vUG9pbnQnXG5cbmV4cG9ydCBjb25zdCBwaTEgPSBNYXRoLlBJICogMyAvIDJcbmV4cG9ydCBjb25zdCBwaTIgPSBNYXRoLlBJIC8gMlxuXG5leHBvcnQgY29uc3QgSU5GID0gMTAwMDBcbmNvbnN0IENPTElOX1RPTEVSQU5DRSA9IDEzXG5jb25zdCBUID0gTWF0aC5wb3coMTAsIENPTElOX1RPTEVSQU5DRSlcbmNvbnN0IFQyID0gTWF0aC5wb3coMTAuMCwgQ09MSU5fVE9MRVJBTkNFKVxuXG5leHBvcnQgZnVuY3Rpb24gZWRnZUludGVyc2VjdCAocDEsIHExLCBlZGdlKSB7XG4gIGNvbnN0IHAyID0gZWRnZS5wMVxuICBjb25zdCBxMiA9IGVkZ2UucDJcbiAgY29uc3QgbzEgPSBjY3cocDEsIHExLCBwMilcbiAgY29uc3QgbzIgPSBjY3cocDEsIHExLCBxMilcbiAgY29uc3QgbzMgPSBjY3cocDIsIHEyLCBwMSlcbiAgY29uc3QgbzQgPSBjY3cocDIsIHEyLCBxMSlcbiAgaWYgKG8xICE9PSBvMiAmJiBvMyAhPT0gbzQpIHJldHVybiB0cnVlXG4gIGlmIChvMSA9PT0gMCAmJiBvblNlZ21lbnQocDEsIHAyLCBxMSkpIHJldHVybiB0cnVlXG4gIGlmIChvMiA9PT0gMCAmJiBvblNlZ21lbnQocDEsIHEyLCBxMSkpIHJldHVybiB0cnVlXG4gIGlmIChvMyA9PT0gMCAmJiBvblNlZ21lbnQocDIsIHAxLCBxMikpIHJldHVybiB0cnVlXG4gIGlmIChvNCA9PT0gMCAmJiBvblNlZ21lbnQocDIsIHExLCBxMikpIHJldHVybiB0cnVlXG4gIHJldHVybiBmYWxzZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2N3IChhLCBiLCBjKSB7XG4gIGNvbnN0IGFyZWEgPSBNYXRoLnJvdW5kKCgoYi54IC0gYS54KSAqIChjLnkgLSBhLnkpIC0gKGIueSAtIGEueSkgKiAoYy54IC0gYS54KSkgKiBUKSAvIFQyXG4gIGlmIChhcmVhID4gMCkgcmV0dXJuIDFcbiAgaWYgKGFyZWEgPCAwKSByZXR1cm4gLTFcbiAgcmV0dXJuIDBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9uU2VnbWVudCAocCwgcSwgcikge1xuICBpZiAocS54IDw9IE1hdGgubWF4KHAueCwgci54KSAmJiBxLnggPj0gTWF0aC5taW4ocC54LCByLngpKSB7XG4gICAgaWYgKHEueSA8PSBNYXRoLm1heChwLnksIHIueSkgJiYgcS55ID49IE1hdGgubWluKHAueSwgci55KSkgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFuZ2xlMiAocDEsIHAyLCBwMykge1xuICBjb25zdCBhID0gTWF0aC5wb3coKHAzLnggLSBwMi54KSwgMikgKyBNYXRoLnBvdygocDMueSAtIHAyLnkpLCAyKVxuICBjb25zdCBiID0gTWF0aC5wb3coKHAzLnggLSBwMS54KSwgMikgKyBNYXRoLnBvdygocDMueSAtIHAxLnkpLCAyKVxuICBjb25zdCBjID0gTWF0aC5wb3coKHAyLnggLSBwMS54KSwgMikgKyBNYXRoLnBvdygocDIueSAtIHAxLnkpLCAyKVxuICByZXR1cm4gTWF0aC5hY29zKChhICsgYyAtIGIpIC8gKDIgKiBNYXRoLnNxcnQoYSkgKiBNYXRoLnNxcnQoYykpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRFZGdlRGlzdGFuY2UgKHAxLCBwMiwgZWRnZSkge1xuICBjb25zdCBpcCA9IGludGVyc2VjdFBvaW50KHAxLCBwMiwgZWRnZSlcbiAgcmV0dXJuIGlwICE9PSBudWxsID8gY2FsY0VkZ2VEaXN0YW5jZShwMSwgaXApIDogMFxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJzZWN0UG9pbnQgKHAxLCBwMiwgZWRnZSkge1xuICBpZiAoZWRnZS5jb250YWluc1BvaW50KHAxKSkgcmV0dXJuIHAxXG4gIGlmIChlZGdlLmNvbnRhaW5zUG9pbnQocDIpKSByZXR1cm4gcDJcbiAgaWYgKGVkZ2UucDEueCA9PT0gZWRnZS5wMi54KSB7XG4gICAgaWYgKHAxLnggPT09IHAyLngpIHJldHVybiBudWxsXG4gICAgY29uc3QgcHNsb3BlID0gKHAxLnkgLSBwMi55KSAvIChwMS54IC0gcDIueClcbiAgICBjb25zdCBpbnRlcnNlY3RYID0gZWRnZS5wMS54XG4gICAgY29uc3QgaW50ZXJzZWN0WSA9IHBzbG9wZSAqIChpbnRlcnNlY3RYIC0gcDEueCkgKyBwMS55XG4gICAgcmV0dXJuIG5ldyBQb2ludChbaW50ZXJzZWN0WCwgaW50ZXJzZWN0WV0sIG51bGwpXG4gIH1cbiAgaWYgKHAxLnggPT09IHAyLngpIHtcbiAgICBjb25zdCBlc2xvcGUgPSAoZWRnZS5wMS55IC0gZWRnZS5wMi55KSAvIChlZGdlLnAxLnggLSBlZGdlLnAyLngpXG4gICAgY29uc3QgaW50ZXJzZWN0WCA9IHAxLnhcbiAgICBjb25zdCBpbnRlcnNlY3RZID0gZXNsb3BlICogKGludGVyc2VjdFggLSBlZGdlLnAxLngpICsgZWRnZS5wMS55XG4gICAgcmV0dXJuIG5ldyBQb2ludChbaW50ZXJzZWN0WCwgaW50ZXJzZWN0WV0sIG51bGwpXG4gIH1cblxuICBjb25zdCBwc2xvcGUgPSAocDEueSAtIHAyLnkpIC8gKHAxLnggLSBwMi54KVxuICBjb25zdCBlc2xvcGUgPSAoZWRnZS5wMS55IC0gZWRnZS5wMi55KSAvIChlZGdlLnAxLnggLSBlZGdlLnAyLngpXG5cbiAgaWYgKHBzbG9wZSA9PT0gZXNsb3BlKSByZXR1cm4gbnVsbFxuICBjb25zdCBpbnRlcnNlY3RYID0gKGVzbG9wZSAqIGVkZ2UucDEueCAtIHBzbG9wZSAqIHAxLnggKyBwMS55IC0gZWRnZS5wMS55KSAvIChlc2xvcGUgLSBwc2xvcGUpXG4gIGNvbnN0IGludGVyc2VjdFkgPSBlc2xvcGUgKiAoaW50ZXJzZWN0WCAtIGVkZ2UucDEueCkgKyBlZGdlLnAxLnlcbiAgcmV0dXJuIG5ldyBQb2ludChbaW50ZXJzZWN0WCwgaW50ZXJzZWN0WV0sIG51bGwpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxjRWRnZURpc3RhbmNlIChwMSwgcDIpIHtcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwMi54IC0gcDEueCwgMikgKyBNYXRoLnBvdyhwMi55IC0gcDEueSwgMikpXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../src/utils.js\n");

/***/ }),

/***/ "./src/Edge.js":
/*!*********************!*\
  !*** ./src/Edge.js ***!
  \*********************/
/*! exports provided: Edge */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Edge\", function() { return Edge; });\nclass Edge {\n  constructor (p1, p2) {\n    this.p1 = p1\n    this.p2 = p2\n\n    p1.edges.push(this)\n    p2.edges.push(this)\n  }\n\n  getOtherPointInEdge (point) {\n    return this.p1.isPointEqual(point) ? this.p2 : this.p1\n  }\n\n  areEdgesEqual (otherEdge) {\n    if (this.p1.isPointEqual(otherEdge.p1) && this.p2.isPointEqual(otherEdge.p2)) return true\n    if (this.p1.isPointEqual(otherEdge.p2) && this.p2.isPointEqual(otherEdge.p1)) return true\n    return false\n  }\n\n  containsPoint (point) {\n    if (this.p1.isPointEqual(point) || this.p2.isPointEqual(point)) return true\n    return false\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvRWRnZS5qcz80MDBiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL3NyYy9FZGdlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIEVkZ2Uge1xuICBjb25zdHJ1Y3RvciAocDEsIHAyKSB7XG4gICAgdGhpcy5wMSA9IHAxXG4gICAgdGhpcy5wMiA9IHAyXG5cbiAgICBwMS5lZGdlcy5wdXNoKHRoaXMpXG4gICAgcDIuZWRnZXMucHVzaCh0aGlzKVxuICB9XG5cbiAgZ2V0T3RoZXJQb2ludEluRWRnZSAocG9pbnQpIHtcbiAgICByZXR1cm4gdGhpcy5wMS5pc1BvaW50RXF1YWwocG9pbnQpID8gdGhpcy5wMiA6IHRoaXMucDFcbiAgfVxuXG4gIGFyZUVkZ2VzRXF1YWwgKG90aGVyRWRnZSkge1xuICAgIGlmICh0aGlzLnAxLmlzUG9pbnRFcXVhbChvdGhlckVkZ2UucDEpICYmIHRoaXMucDIuaXNQb2ludEVxdWFsKG90aGVyRWRnZS5wMikpIHJldHVybiB0cnVlXG4gICAgaWYgKHRoaXMucDEuaXNQb2ludEVxdWFsKG90aGVyRWRnZS5wMikgJiYgdGhpcy5wMi5pc1BvaW50RXF1YWwob3RoZXJFZGdlLnAxKSkgcmV0dXJuIHRydWVcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNvbnRhaW5zUG9pbnQgKHBvaW50KSB7XG4gICAgaWYgKHRoaXMucDEuaXNQb2ludEVxdWFsKHBvaW50KSB8fCB0aGlzLnAyLmlzUG9pbnRFcXVhbChwb2ludCkpIHJldHVybiB0cnVlXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Edge.js\n");

/***/ }),

/***/ "./src/Point.js":
/*!**********************!*\
  !*** ./src/Point.js ***!
  \**********************/
/*! exports provided: Point */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Point\", function() { return Point; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n\n\nclass Point {\n\n  constructor (coords, polygonID) {\n    if (polygonID === null) polygonID = -1\n    this.x = coords[0]\n    this.y = coords[1]\n    this.polygonID = polygonID\n    this.edges = []\n    this.prevPoint = null\n    this.nextPoint = null\n  }\n\n  isPointEqual (otherPoint) {\n    return this.x === otherPoint.x && this.y === otherPoint.y\n  }\n\n  angleToPoint (otherPoint) {\n    if (this.isPointEqual(otherPoint)) return 0\n    const dx = otherPoint.x - this.x\n    const dy = otherPoint.y - this.y\n    if (dx === 0) dy < 1 ? _utils__WEBPACK_IMPORTED_MODULE_0__[\"pi1\"] : _utils__WEBPACK_IMPORTED_MODULE_0__[\"pi2\"]\n    if (dy === 0) dx < 0 ? Math.PI : 0\n    if (dx < 0) return Math.PI + Math.atan(dy / dx)\n    if (dy < 0) return 2 * Math.PI + Math.atan(dy / dx)\n    return Math.atan(dy / dx)\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvUG9pbnQuanM/YzYxYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBa0M7O0FBRTNCOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMENBQUcsR0FBRywwQ0FBRztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9zcmMvUG9pbnQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwaTEsIHBpMiB9IGZyb20gJy4vdXRpbHMnXG5cbmV4cG9ydCBjbGFzcyBQb2ludCB7XG5cbiAgY29uc3RydWN0b3IgKGNvb3JkcywgcG9seWdvbklEKSB7XG4gICAgaWYgKHBvbHlnb25JRCA9PT0gbnVsbCkgcG9seWdvbklEID0gLTFcbiAgICB0aGlzLnggPSBjb29yZHNbMF1cbiAgICB0aGlzLnkgPSBjb29yZHNbMV1cbiAgICB0aGlzLnBvbHlnb25JRCA9IHBvbHlnb25JRFxuICAgIHRoaXMuZWRnZXMgPSBbXVxuICAgIHRoaXMucHJldlBvaW50ID0gbnVsbFxuICAgIHRoaXMubmV4dFBvaW50ID0gbnVsbFxuICB9XG5cbiAgaXNQb2ludEVxdWFsIChvdGhlclBvaW50KSB7XG4gICAgcmV0dXJuIHRoaXMueCA9PT0gb3RoZXJQb2ludC54ICYmIHRoaXMueSA9PT0gb3RoZXJQb2ludC55XG4gIH1cblxuICBhbmdsZVRvUG9pbnQgKG90aGVyUG9pbnQpIHtcbiAgICBpZiAodGhpcy5pc1BvaW50RXF1YWwob3RoZXJQb2ludCkpIHJldHVybiAwXG4gICAgY29uc3QgZHggPSBvdGhlclBvaW50LnggLSB0aGlzLnhcbiAgICBjb25zdCBkeSA9IG90aGVyUG9pbnQueSAtIHRoaXMueVxuICAgIGlmIChkeCA9PT0gMCkgZHkgPCAxID8gcGkxIDogcGkyXG4gICAgaWYgKGR5ID09PSAwKSBkeCA8IDAgPyBNYXRoLlBJIDogMFxuICAgIGlmIChkeCA8IDApIHJldHVybiBNYXRoLlBJICsgTWF0aC5hdGFuKGR5IC8gZHgpXG4gICAgaWYgKGR5IDwgMCkgcmV0dXJuIDIgKiBNYXRoLlBJICsgTWF0aC5hdGFuKGR5IC8gZHgpXG4gICAgcmV0dXJuIE1hdGguYXRhbihkeSAvIGR4KVxuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Point.js\n");

/***/ }),

/***/ "./src/convex-hull.js":
/*!****************************!*\
  !*** ./src/convex-hull.js ***!
  \****************************/
/*! exports provided: makeConvexhull, convexhull */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"makeConvexhull\", function() { return makeConvexhull; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"convexhull\", function() { return convexhull; });\n/* \n * Convex hull algorithm - Library (JavaScript)\n * \n * Copyright (c) 2018 Project Nayuki\n * https://www.nayuki.io/page/convex-hull-algorithm\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public License\n * along with this program (see COPYING.txt and COPYING.LESSER.txt).\n * If not, see <http://www.gnu.org/licenses/>.\n */\n\n\n\n\n\t// Returns a new array of points representing the convex hull of\n\t// the given set of points. The convex hull excludes collinear points.\n\t// This algorithm runs in O(n log n) time.\nfunction makeConvexhull(points) {\n\t\tvar newPoints = points.slice();\n\t\tnewPoints.sort(POINT_COMPARATOR);\n\t\treturn makeHullPresorted(newPoints);\n\t};\n\nfunction convexhull() {\n\n};\n\n\t// Returns the convex hull, assuming that each points[i] <= points[i + 1]. Runs in O(n) time.\n\tfunction makeHullPresorted(points) {\n\t\tif (points.length <= 1)\n\t\t\treturn points.slice();\n\t\t\n\t\t// Andrew's monotone chain algorithm. Positive y coordinates correspond to \"up\"\n\t\t// as per the mathematical convention, instead of \"down\" as per the computer\n\t\t// graphics convention. This doesn't affect the correctness of the result.\n\t\t\n\t\tvar upperHull = [];\n\t\tfor (var i = 0; i < points.length; i++) {\n\t\t\tvar p = points[i];\n\t\t\twhile (upperHull.length >= 2) {\n\t\t\t\tvar q = upperHull[upperHull.length - 1];\n\t\t\t\tvar r = upperHull[upperHull.length - 2];\n\t\t\t\tif ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x))\n\t\t\t\t\tupperHull.pop();\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tupperHull.push(p);\n\t\t}\n\t\tupperHull.pop();\n\t\t\n\t\tvar lowerHull = [];\n\t\tfor (var i = points.length - 1; i >= 0; i--) {\n\t\t\tvar p = points[i];\n\t\t\twhile (lowerHull.length >= 2) {\n\t\t\t\tvar q = lowerHull[lowerHull.length - 1];\n\t\t\t\tvar r = lowerHull[lowerHull.length - 2];\n\t\t\t\tif ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x))\n\t\t\t\t\tlowerHull.pop();\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlowerHull.push(p);\n\t\t}\n\t\tlowerHull.pop();\n\t\t\n\t\tif (upperHull.length == 1 && lowerHull.length == 1 && upperHull[0].x == lowerHull[0].x && upperHull[0].y == lowerHull[0].y)\n\t\t\treturn upperHull;\n\t\telse\n\t\t\treturn upperHull.concat(lowerHull);\n\t};\n\t\n\t\n\tfunction POINT_COMPARATOR(a, b) {\n\t\tif (a.x < b.x)\n\t\t\treturn -1;\n\t\telse if (a.x > b.x)\n\t\t\treturn +1;\n\t\telse if (a.y < b.y)\n\t\t\treturn -1;\n\t\telse if (a.y > b.y)\n\t\t\treturn +1;\n\t\telse\n\t\t\treturn 0;\n\t};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29udmV4LWh1bGwuanM/NDRlMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7OztBQUdiO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vc3JjL2NvbnZleC1odWxsLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogXG4gKiBDb252ZXggaHVsbCBhbGdvcml0aG0gLSBMaWJyYXJ5IChKYXZhU2NyaXB0KVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTggUHJvamVjdCBOYXl1a2lcbiAqIGh0dHBzOi8vd3d3Lm5heXVraS5pby9wYWdlL2NvbnZleC1odWxsLWFsZ29yaXRobVxuICogXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICogKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiAqIFxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICogR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4gKiBcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0gKHNlZSBDT1BZSU5HLnR4dCBhbmQgQ09QWUlORy5MRVNTRVIudHh0KS5cbiAqIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5cdC8vIFJldHVybnMgYSBuZXcgYXJyYXkgb2YgcG9pbnRzIHJlcHJlc2VudGluZyB0aGUgY29udmV4IGh1bGwgb2Zcblx0Ly8gdGhlIGdpdmVuIHNldCBvZiBwb2ludHMuIFRoZSBjb252ZXggaHVsbCBleGNsdWRlcyBjb2xsaW5lYXIgcG9pbnRzLlxuXHQvLyBUaGlzIGFsZ29yaXRobSBydW5zIGluIE8obiBsb2cgbikgdGltZS5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlQ29udmV4aHVsbChwb2ludHMpIHtcblx0XHR2YXIgbmV3UG9pbnRzID0gcG9pbnRzLnNsaWNlKCk7XG5cdFx0bmV3UG9pbnRzLnNvcnQoUE9JTlRfQ09NUEFSQVRPUik7XG5cdFx0cmV0dXJuIG1ha2VIdWxsUHJlc29ydGVkKG5ld1BvaW50cyk7XG5cdH07XG5cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXhodWxsKCkge1xuXG59O1xuXG5cdC8vIFJldHVybnMgdGhlIGNvbnZleCBodWxsLCBhc3N1bWluZyB0aGF0IGVhY2ggcG9pbnRzW2ldIDw9IHBvaW50c1tpICsgMV0uIFJ1bnMgaW4gTyhuKSB0aW1lLlxuXHRmdW5jdGlvbiBtYWtlSHVsbFByZXNvcnRlZChwb2ludHMpIHtcblx0XHRpZiAocG9pbnRzLmxlbmd0aCA8PSAxKVxuXHRcdFx0cmV0dXJuIHBvaW50cy5zbGljZSgpO1xuXHRcdFxuXHRcdC8vIEFuZHJldydzIG1vbm90b25lIGNoYWluIGFsZ29yaXRobS4gUG9zaXRpdmUgeSBjb29yZGluYXRlcyBjb3JyZXNwb25kIHRvIFwidXBcIlxuXHRcdC8vIGFzIHBlciB0aGUgbWF0aGVtYXRpY2FsIGNvbnZlbnRpb24sIGluc3RlYWQgb2YgXCJkb3duXCIgYXMgcGVyIHRoZSBjb21wdXRlclxuXHRcdC8vIGdyYXBoaWNzIGNvbnZlbnRpb24uIFRoaXMgZG9lc24ndCBhZmZlY3QgdGhlIGNvcnJlY3RuZXNzIG9mIHRoZSByZXN1bHQuXG5cdFx0XG5cdFx0dmFyIHVwcGVySHVsbCA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgcCA9IHBvaW50c1tpXTtcblx0XHRcdHdoaWxlICh1cHBlckh1bGwubGVuZ3RoID49IDIpIHtcblx0XHRcdFx0dmFyIHEgPSB1cHBlckh1bGxbdXBwZXJIdWxsLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHR2YXIgciA9IHVwcGVySHVsbFt1cHBlckh1bGwubGVuZ3RoIC0gMl07XG5cdFx0XHRcdGlmICgocS54IC0gci54KSAqIChwLnkgLSByLnkpID49IChxLnkgLSByLnkpICogKHAueCAtIHIueCkpXG5cdFx0XHRcdFx0dXBwZXJIdWxsLnBvcCgpO1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHR1cHBlckh1bGwucHVzaChwKTtcblx0XHR9XG5cdFx0dXBwZXJIdWxsLnBvcCgpO1xuXHRcdFxuXHRcdHZhciBsb3dlckh1bGwgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gcG9pbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHR2YXIgcCA9IHBvaW50c1tpXTtcblx0XHRcdHdoaWxlIChsb3dlckh1bGwubGVuZ3RoID49IDIpIHtcblx0XHRcdFx0dmFyIHEgPSBsb3dlckh1bGxbbG93ZXJIdWxsLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHR2YXIgciA9IGxvd2VySHVsbFtsb3dlckh1bGwubGVuZ3RoIC0gMl07XG5cdFx0XHRcdGlmICgocS54IC0gci54KSAqIChwLnkgLSByLnkpID49IChxLnkgLSByLnkpICogKHAueCAtIHIueCkpXG5cdFx0XHRcdFx0bG93ZXJIdWxsLnBvcCgpO1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRsb3dlckh1bGwucHVzaChwKTtcblx0XHR9XG5cdFx0bG93ZXJIdWxsLnBvcCgpO1xuXHRcdFxuXHRcdGlmICh1cHBlckh1bGwubGVuZ3RoID09IDEgJiYgbG93ZXJIdWxsLmxlbmd0aCA9PSAxICYmIHVwcGVySHVsbFswXS54ID09IGxvd2VySHVsbFswXS54ICYmIHVwcGVySHVsbFswXS55ID09IGxvd2VySHVsbFswXS55KVxuXHRcdFx0cmV0dXJuIHVwcGVySHVsbDtcblx0XHRlbHNlXG5cdFx0XHRyZXR1cm4gdXBwZXJIdWxsLmNvbmNhdChsb3dlckh1bGwpO1xuXHR9O1xuXHRcblx0XG5cdGZ1bmN0aW9uIFBPSU5UX0NPTVBBUkFUT1IoYSwgYikge1xuXHRcdGlmIChhLnggPCBiLngpXG5cdFx0XHRyZXR1cm4gLTE7XG5cdFx0ZWxzZSBpZiAoYS54ID4gYi54KVxuXHRcdFx0cmV0dXJuICsxO1xuXHRcdGVsc2UgaWYgKGEueSA8IGIueSlcblx0XHRcdHJldHVybiAtMTtcblx0XHRlbHNlIGlmIChhLnkgPiBiLnkpXG5cdFx0XHRyZXR1cm4gKzE7XG5cdFx0ZWxzZVxuXHRcdFx0cmV0dXJuIDA7XG5cdH07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/convex-hull.js\n");

/***/ }),

/***/ "./src/graphHelper.js":
/*!****************************!*\
  !*** ./src/graphHelper.js ***!
  \****************************/
/*! exports provided: loadGraphFromFile, createGraphFromData, findRouteThroughGraph, updateGraphWithDynamicJSON */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadGraphFromFile\", function() { return loadGraphFromFile; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createGraphFromData\", function() { return createGraphFromData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findRouteThroughGraph\", function() { return findRouteThroughGraph; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"updateGraphWithDynamicJSON\", function() { return updateGraphWithDynamicJSON; });\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'ngraph.fromjson'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'ngraph.path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module './graphCreation.worker.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n/* harmony import */ var _mapHelpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mapHelpers */ \"./src/mapHelpers.js\");\n\n\n\n\n\n\n\nvar dataJSON = \"\"\n\nfunction loadGraphFromFile (dataWithEdges) {\n  // function reqListener () {\n  //   const startLoad = window.performance.now()\n  //   dataJSON = this.responseText\n  //   const graph = fromjson(dataJSON)\n  //   dataJSON = dataJSON.substring(0, dataJSON.length-2)\n  //   dataJSON = dataJSON.substring(10, dataJSON.length)\n  //   console.log(graph.getNodesCount())\n  //   const endLoad = window.performance.now()\n  //   const timeTakenToLoad = parseInt(endLoad - startLoad)\n  //   console.log('Time to load: ', timeTakenToLoad)\n\n  //   setGraph(graph)\n  //   return findRouteThroughGraph(graph)\n  // }\n  Object(_mapHelpers__WEBPACK_IMPORTED_MODULE_1__[\"clearGraphRelatedData\"])()\n  const startLoad = window.performance.now()\n  dataJSON = dataWithEdges\n  const graph = !(function webpackMissingModule() { var e = new Error(\"Cannot find module 'ngraph.fromjson'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(dataJSON)\n  dataJSON = dataJSON.substring(0, dataJSON.length-2)\n  dataJSON = dataJSON.substring(10, dataJSON.length)\n  console.log(graph.getNodesCount())\n  const endLoad = window.performance.now()\n  const timeTakenToLoad = parseInt(endLoad - startLoad)\n  console.log('Time to load: ', timeTakenToLoad)\n\n  Object(_mapHelpers__WEBPACK_IMPORTED_MODULE_1__[\"setGraph\"])(graph)\n  return findRouteThroughGraph(graph)\n\n\n\n\n\n\n\n  // var oReq = new XMLHttpRequest() //eslint-disable-line\n  // oReq.addEventListener('load', reqListener)\n  // oReq.open('GET', filename)\n  // oReq.send()\n}\n\nfunction createGraphFromData (data) {\n  Object(_mapHelpers__WEBPACK_IMPORTED_MODULE_1__[\"clearGraphRelatedData\"])()\n  const worker = new !(function webpackMissingModule() { var e = new Error(\"Cannot find module './graphCreation.worker.js'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())() //eslint-disable-line\n\n  const startCreation = window.performance.now()\n  worker.postMessage(data)\n\n  worker.onmessage = function (e) {\n    const endCreation = window.performance.now()\n    const timeTakenToCreate = parseInt(endCreation - startCreation)\n    console.log('Time to construct: ', timeTakenToCreate)\n    const graph = !(function webpackMissingModule() { var e = new Error(\"Cannot find module 'ngraph.fromjson'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(e.data)\n    console.log(graph.getNodesCount())\n    Object(_mapHelpers__WEBPACK_IMPORTED_MODULE_1__[\"setGraph\"])(graph)\n    return findRouteThroughGraph(graph)\n  }\n}\n\nfunction findRouteThroughGraph (graph) {\n  const pathFinder = !(function webpackMissingModule() { var e = new Error(\"Cannot find module 'ngraph.path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()).nba(graph, {\n    distance (fromNode, toNode) {\n      const dx = fromNode.data.x - toNode.data.x\n      const dy = fromNode.data.y - toNode.data.y\n      return Math.sqrt(dx * dx + dy * dy)\n    }\n  })\n  return Object(_mapHelpers__WEBPACK_IMPORTED_MODULE_1__[\"setPathFinder\"])(pathFinder)\n}\n\nfunction updateGraphWithDynamicJSON (dynamicNodesJSON, dynamicEdgesJSON) {\n    const startLoad = window.performance.now()\n    const graph = !(function webpackMissingModule() { var e = new Error(\"Cannot find module 'ngraph.fromjson'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())('{\"nodes\":[' + dynamicNodesJSON + dataJSON + dynamicEdgesJSON + \"]}\")\n    console.log(graph.getNodesCount())\n    const endLoad = window.performance.now()\n    const timeTakenToLoad = parseInt(endLoad - startLoad)\n    console.log('Time to load: ', timeTakenToLoad)\n\n    Object(_mapHelpers__WEBPACK_IMPORTED_MODULE_1__[\"setGraph\"])(graph)\n    findRouteThroughGraph(graph)\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZ3JhcGhIZWxwZXIuanM/MjhkYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBc0M7QUFDUjs7QUFFZ0I7O0FBRStCOztBQUU3RTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUUseUVBQXFCO0FBQ3ZCO0FBQ0E7QUFDQSxnQkFBZ0IseUlBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUUsNERBQVE7QUFDVjs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1AsRUFBRSx5RUFBcUI7QUFDdkIscUJBQXFCLG1KQUFNOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlJQUFRO0FBQzFCO0FBQ0EsSUFBSSw0REFBUTtBQUNaO0FBQ0E7QUFDQTs7QUFFTztBQUNQLHFCQUFxQixxSUFBSTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFNBQVMsaUVBQWE7QUFDdEI7O0FBRU87QUFDUDtBQUNBLGtCQUFrQix5SUFBUSxHQUFHLGlFQUFpRTtBQUM5RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLDREQUFRO0FBQ1o7QUFDQSIsImZpbGUiOiIuL3NyYy9ncmFwaEhlbHBlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmcm9tanNvbiBmcm9tICduZ3JhcGguZnJvbWpzb24nXG5pbXBvcnQgcGF0aCBmcm9tICduZ3JhcGgucGF0aCdcblxuaW1wb3J0IFdvcmtlciBmcm9tICcuL2dyYXBoQ3JlYXRpb24ud29ya2VyLmpzJ1xuXG5pbXBvcnQgeyBzZXRQYXRoRmluZGVyLCBzZXRHcmFwaCwgY2xlYXJHcmFwaFJlbGF0ZWREYXRhIH0gZnJvbSAnLi9tYXBIZWxwZXJzJ1xuXG52YXIgZGF0YUpTT04gPSBcIlwiXG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkR3JhcGhGcm9tRmlsZSAoZGF0YVdpdGhFZGdlcykge1xuICAvLyBmdW5jdGlvbiByZXFMaXN0ZW5lciAoKSB7XG4gIC8vICAgY29uc3Qgc3RhcnRMb2FkID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpXG4gIC8vICAgZGF0YUpTT04gPSB0aGlzLnJlc3BvbnNlVGV4dFxuICAvLyAgIGNvbnN0IGdyYXBoID0gZnJvbWpzb24oZGF0YUpTT04pXG4gIC8vICAgZGF0YUpTT04gPSBkYXRhSlNPTi5zdWJzdHJpbmcoMCwgZGF0YUpTT04ubGVuZ3RoLTIpXG4gIC8vICAgZGF0YUpTT04gPSBkYXRhSlNPTi5zdWJzdHJpbmcoMTAsIGRhdGFKU09OLmxlbmd0aClcbiAgLy8gICBjb25zb2xlLmxvZyhncmFwaC5nZXROb2Rlc0NvdW50KCkpXG4gIC8vICAgY29uc3QgZW5kTG9hZCA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKVxuICAvLyAgIGNvbnN0IHRpbWVUYWtlblRvTG9hZCA9IHBhcnNlSW50KGVuZExvYWQgLSBzdGFydExvYWQpXG4gIC8vICAgY29uc29sZS5sb2coJ1RpbWUgdG8gbG9hZDogJywgdGltZVRha2VuVG9Mb2FkKVxuXG4gIC8vICAgc2V0R3JhcGgoZ3JhcGgpXG4gIC8vICAgcmV0dXJuIGZpbmRSb3V0ZVRocm91Z2hHcmFwaChncmFwaClcbiAgLy8gfVxuICBjbGVhckdyYXBoUmVsYXRlZERhdGEoKVxuICBjb25zdCBzdGFydExvYWQgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KClcbiAgZGF0YUpTT04gPSBkYXRhV2l0aEVkZ2VzXG4gIGNvbnN0IGdyYXBoID0gZnJvbWpzb24oZGF0YUpTT04pXG4gIGRhdGFKU09OID0gZGF0YUpTT04uc3Vic3RyaW5nKDAsIGRhdGFKU09OLmxlbmd0aC0yKVxuICBkYXRhSlNPTiA9IGRhdGFKU09OLnN1YnN0cmluZygxMCwgZGF0YUpTT04ubGVuZ3RoKVxuICBjb25zb2xlLmxvZyhncmFwaC5nZXROb2Rlc0NvdW50KCkpXG4gIGNvbnN0IGVuZExvYWQgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KClcbiAgY29uc3QgdGltZVRha2VuVG9Mb2FkID0gcGFyc2VJbnQoZW5kTG9hZCAtIHN0YXJ0TG9hZClcbiAgY29uc29sZS5sb2coJ1RpbWUgdG8gbG9hZDogJywgdGltZVRha2VuVG9Mb2FkKVxuXG4gIHNldEdyYXBoKGdyYXBoKVxuICByZXR1cm4gZmluZFJvdXRlVGhyb3VnaEdyYXBoKGdyYXBoKVxuXG5cblxuXG5cblxuXG4gIC8vIHZhciBvUmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCkgLy9lc2xpbnQtZGlzYWJsZS1saW5lXG4gIC8vIG9SZXEuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHJlcUxpc3RlbmVyKVxuICAvLyBvUmVxLm9wZW4oJ0dFVCcsIGZpbGVuYW1lKVxuICAvLyBvUmVxLnNlbmQoKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlR3JhcGhGcm9tRGF0YSAoZGF0YSkge1xuICBjbGVhckdyYXBoUmVsYXRlZERhdGEoKVxuICBjb25zdCB3b3JrZXIgPSBuZXcgV29ya2VyKCkgLy9lc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgY29uc3Qgc3RhcnRDcmVhdGlvbiA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKVxuICB3b3JrZXIucG9zdE1lc3NhZ2UoZGF0YSlcblxuICB3b3JrZXIub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICBjb25zdCBlbmRDcmVhdGlvbiA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKVxuICAgIGNvbnN0IHRpbWVUYWtlblRvQ3JlYXRlID0gcGFyc2VJbnQoZW5kQ3JlYXRpb24gLSBzdGFydENyZWF0aW9uKVxuICAgIGNvbnNvbGUubG9nKCdUaW1lIHRvIGNvbnN0cnVjdDogJywgdGltZVRha2VuVG9DcmVhdGUpXG4gICAgY29uc3QgZ3JhcGggPSBmcm9tanNvbihlLmRhdGEpXG4gICAgY29uc29sZS5sb2coZ3JhcGguZ2V0Tm9kZXNDb3VudCgpKVxuICAgIHNldEdyYXBoKGdyYXBoKVxuICAgIHJldHVybiBmaW5kUm91dGVUaHJvdWdoR3JhcGgoZ3JhcGgpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRSb3V0ZVRocm91Z2hHcmFwaCAoZ3JhcGgpIHtcbiAgY29uc3QgcGF0aEZpbmRlciA9IHBhdGgubmJhKGdyYXBoLCB7XG4gICAgZGlzdGFuY2UgKGZyb21Ob2RlLCB0b05vZGUpIHtcbiAgICAgIGNvbnN0IGR4ID0gZnJvbU5vZGUuZGF0YS54IC0gdG9Ob2RlLmRhdGEueFxuICAgICAgY29uc3QgZHkgPSBmcm9tTm9kZS5kYXRhLnkgLSB0b05vZGUuZGF0YS55XG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIHNldFBhdGhGaW5kZXIocGF0aEZpbmRlcilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUdyYXBoV2l0aER5bmFtaWNKU09OIChkeW5hbWljTm9kZXNKU09OLCBkeW5hbWljRWRnZXNKU09OKSB7XG4gICAgY29uc3Qgc3RhcnRMb2FkID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpXG4gICAgY29uc3QgZ3JhcGggPSBmcm9tanNvbigne1wibm9kZXNcIjpbJyArIGR5bmFtaWNOb2Rlc0pTT04gKyBkYXRhSlNPTiArIGR5bmFtaWNFZGdlc0pTT04gKyBcIl19XCIpXG4gICAgY29uc29sZS5sb2coZ3JhcGguZ2V0Tm9kZXNDb3VudCgpKVxuICAgIGNvbnN0IGVuZExvYWQgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KClcbiAgICBjb25zdCB0aW1lVGFrZW5Ub0xvYWQgPSBwYXJzZUludChlbmRMb2FkIC0gc3RhcnRMb2FkKVxuICAgIGNvbnNvbGUubG9nKCdUaW1lIHRvIGxvYWQ6ICcsIHRpbWVUYWtlblRvTG9hZClcblxuICAgIHNldEdyYXBoKGdyYXBoKVxuICAgIGZpbmRSb3V0ZVRocm91Z2hHcmFwaChncmFwaClcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/graphHelper.js\n");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _mapHelpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mapHelpers */ \"./src/mapHelpers.js\");\n/* harmony import */ var _graphHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./graphHelper */ \"./src/graphHelper.js\");\n\n\n\n\n\n\n\n// import Vue from 'vue'\n// import App from './App.vue'\n// import VueWorker from 'vue-worker'\n\n// Vue.use(VueWorker)\n// new Vue({\n//   el: '#app',\n//   render: h => h(App)\n// })\n\n\n\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5qcz81NmQ3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFpRTtBQUNLOzs7Ozs7QUFNdEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSIsImZpbGUiOiIuL3NyYy9tYWluLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2V0dXBNYXAsIHNldERhdGEsIHNldHVwUm91dGVMYXllciB9IGZyb20gJy4vbWFwSGVscGVycydcbmltcG9ydCB7IGxvYWRHcmFwaEZyb21GaWxlLCBjcmVhdGVHcmFwaEZyb21EYXRhIH0gZnJvbSAnLi9ncmFwaEhlbHBlcidcblxuXG5cblxuXG4vLyBpbXBvcnQgVnVlIGZyb20gJ3Z1ZSdcbi8vIGltcG9ydCBBcHAgZnJvbSAnLi9BcHAudnVlJ1xuLy8gaW1wb3J0IFZ1ZVdvcmtlciBmcm9tICd2dWUtd29ya2VyJ1xuXG4vLyBWdWUudXNlKFZ1ZVdvcmtlcilcbi8vIG5ldyBWdWUoe1xuLy8gICBlbDogJyNhcHAnLFxuLy8gICByZW5kZXI6IGggPT4gaChBcHApXG4vLyB9KVxuXG5cblxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/main.js\n");

/***/ }),

/***/ "./src/mapHelpers.js":
/*!***************************!*\
  !*** ./src/mapHelpers.js ***!
  \***************************/
/*! exports provided: setupMap, setData, clearGraphRelatedData, setupRouteLayer, setPathFinder, setGraph */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setupMap\", function() { return setupMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setData\", function() { return setData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clearGraphRelatedData\", function() { return clearGraphRelatedData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setupRouteLayer\", function() { return setupRouteLayer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setPathFinder\", function() { return setPathFinder; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setGraph\", function() { return setGraph; });\n!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'ngraph.graph'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n/* harmony import */ var _Point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Point */ \"./src/Point.js\");\n/* harmony import */ var _setupStructure__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./setupStructure */ \"./src/setupStructure.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n/* harmony import */ var _src_main__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../src/main */ \"../src/main.js\");\n/* harmony import */ var _convex_hull__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./convex-hull */ \"./src/convex-hull.js\");\n/* harmony import */ var _graphHelper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./graphHelper */ \"./src/graphHelper.js\");\n\n\n\n\n\n\n\n\n\nlet map = null\nlet startMarker = null\nlet endMarker = null\nlet selectionLayer = null\nlet polyLayer = null\nlet points = null\nlet pointsLyr = null\nlet graphData = null\nlet foundPath = null\nlet pathFinder = null\nlet routeLayer = null\nlet points1 = []\nlet points2 = []\nlet pointsArr = []\nlet turfPolygons = []\nvar output = \"\"\nvar multiplier = 1000 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000\nvar updatingPathMarkers = false\nvar allTangents = []\nvar startPoint = null\nvar endPoint = null\n\n\nfunction setupMap (start, end, showMap) {\n  if(showMap){\n    map = L.map('map', {\n      minZoom: 1,\n      maxZoom: 20,\n      center: [0, 0],\n      zoom: 2,\n      crs: L.CRS.Simple\n    })\n\n    L.NumberedDivIcon = createNumberDiv()\n  }\n\n  if(start == null){\n    // var start = [73.19374999403954,0.6548828072845936]\n    // var end = [73.198449611664,0.691950189807585]\n\n    // var start = [73.20313720591366,0.66888427734375]\n    // var end = [73.22689209133387,0.6780517548322678]\n\n    // var start = [73.2007812410593,0.6654785238206387]\n    // var end = [73.2010742276907,0.7003906257450581]\n\n    // var start = [73.14657642738,0.6639903635426379]\n    // var end = [73.2010742276907,0.7003906257450581]\n\n\n    var start = [73.19707030057907,0.6677734404802322]\n    var end = [73.17901611328125,0.6834106449969113]\n\n\n\n\n\n    var start = [73.18628847599,0.6605490743581441]\n    var end = [73.169002590224,0.6689311701630487]\n\n\n\n\n    var start = [73.234375,0.14453119039535522]\n    var end = [73.169002590224,0.6689311701630487]\n  }\n\n\n  startPoint = new _Point__WEBPACK_IMPORTED_MODULE_1__[\"Point\"](start);\n  endPoint = new _Point__WEBPACK_IMPORTED_MODULE_1__[\"Point\"](end);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  // var start = [73.196550607681,0.6745385270131692]\n  // var end = [73.195617198944,0.6747423607673824]\n\n  // var start = [73.18461914360523,0.6880859322845936]\n  // var end = [73.198449611664,0.691950189807585]\n\n  if(showMap){\n    startMarker = L.marker([start[1],start[0]], {\n      draggable: true,\n      icon: new L.NumberedDivIcon()\n    }).addTo(map)\n\n    endMarker = L.marker([end[1],end[0]], {\n      draggable: true,\n      icon: new L.NumberedDivIcon()\n    }).addTo(map)\n\n    startMarker.on('drag', updatePathMarkers)\n    endMarker.on('drag', updatePathMarkers)\n    selectionLayer = L.layerGroup([]).addTo(map)\n  }\n}\n\nfunction setData (data, showMap) {\n  if(showMap){\n    polyLayer = L.geoJson(data, {\n      noClip: true,\n      stroke: false,\n      fillColor: '#8B99AE'\n    }).addTo(map)\n\n    map.fitBounds(polyLayer.getBounds(), {\n      padding: [20, 20]\n    })\n\n    points = turf.featureCollection([])\n\n    pointsLyr = L.layerGroup([], {\n      pane: 'popupPane'\n    }).addTo(map)\n\n    turf.meta.coordEach(data, function (currentCoord) {\n      points.features.push(turf.point([currentCoord[0], currentCoord[1]]))\n\n      var layer = L.circleMarker([currentCoord[1], currentCoord[0]], {\n        radius: 3,\n        opacity: 0,\n        fillOpacity: 0.5,\n        origPoint: [currentCoord[0], currentCoord[1]]\n      }).addTo(pointsLyr)\n      layer.on('mouseover', highlightFeature)\n      layer.on('mouseout', unhighlightFeature)\n\n    }, true)\n  }\n\n\n\n\n\n\n\n\n  Object(_src_main__WEBPACK_IMPORTED_MODULE_4__[\"loadPoints\"])(data)\n\n  for (var i = data.features.length - 1; i >= 0; i--) {\n    const edges = []\n    const polygons = []\n    points1 = []\n    Object(_setupStructure__WEBPACK_IMPORTED_MODULE_2__[\"setupStructure\"])(data.features[i], edges, points1, polygons, i)\n    pointsArr.push(points1.slice(0))\n  }\n\n  // for (var i = data.geometry.coordinates.length - 1; i >= 0; i--) {\n  //   const edges = []\n  //   const polygons = []\n  //   points1 = []\n  //   setupStructure(data.geometry.coordinates[i], edges, points1, polygons, i)\n  //   pointsArr.push(points1.slice(0))\n  // }\n\n  loadTurfPolygons(data)\n\n\n\n\n\n\n\n\n  // var tangents = getPolygonTangents(new Point([73.14657642738,0.6639903635426379]), pointsArr[11])\n\n  // console.log(\"\\tvar start = [\"+createNodeId2(new Point([73.14657642738,0.6639903635426379]))+\"]\\n\\tvar end = [\"+createNodeId2(tangents[1])+\"]\\n\\n\")\n\n\n\n\n\n    console.log('starting')\n\n  // for (var i = pointsArr.length - 1; i >= 0; i--) {\n  // // for (var i = 19 - 1; i >= 0; i--) {\n  //   // var i = 4;\n  //   // var j = 11;\n\n  //   // var i = 4;\n  //   // var j = 9;\n\n  //   // var i = 11;\n  //   // var j = 0;\n\n  //   for (var j = i - 1; j >= 0; j--) {\n  //   // for (var j = 5; j >= 2; j--) {\n  //   //   if(i == j) continue\n  //     // console.log('test')\n  //   // console.log('i: ' + i + ' j: ' + j)\n  //     // find4Tangents(pointsArr[i], pointsArr[j], turfPolygons[i], turfPolygons[j])\n  //     find4Tangents(pointsArr[i], pointsArr[j])\n\n  //   }\n\n\n  //   // find shortcuts to skip concave parts of polygons\n  //   var pArr = pointsArr[i]\n  //   var hull = makeConvexhull(pArr);\n  //   console.log('test')\n  //   var l = 0\n  //   for (var k = 0; k < hull.length; k++) {\n  //     var nextPoint = hull[ (k+1) % hull.length ]\n\n  //     // find the point that matches the point in the hull\n  //     while( !pArr[l].isPointEqual(hull[k])){\n  //       l = (l+1) % pArr.length\n  //     }\n      \n  //     // if the next point is different we need the line between\n  //     if( !pArr[l].nextPoint.isPointEqual(nextPoint)){\n  //       // if(isVisible(hull[k],nextPoint))\n  //         output += ',{\"fromId\":\"'+ createNodeId2(hull[k]) +'\",\"toId\":\"'+createNodeId2(nextPoint)+'\"}'\n  //     }\n  //   }\n  // }\n\n  // console.log(allTangents.length)\n  // for (var i = allTangents.length - 1; i >= 0; i--) {\n  //   console.log('test')\n  //   var p1 = allTangents[i]\n\n  //   var nodesVisible = getVisibleNodes(p1)\n\n  //   for (var k = nodesVisible.length - 1; k >= 0; k--) {\n  //     for (var j = i - 1; j >= 0; j--) {\n  //       var p2 = allTangents[j]\n\n  //       if(nodesVisible[k].x == p2.x && nodesVisible[k].y == p2.y ){\n  //         output += ',{\"fromId\":\"'+ createNodeId2(p1) +'\",\"toId\":\"'+createNodeId2(p2)+'\"}'\n  //       }\n\n  //       // if(isVisible(p1, p2))\n  //       //   output += ',{\"fromId\":\"'+ createNodeId2(p1) +'\",\"toId\":\"'+createNodeId2(p2)+'\"}'\n  //     }\n  //   }\n\n  // }\n\n\n  console.log(output)\n\n}\n\nfunction loadTurfPolygons(data){\n  for (var i = 0; i < pointsArr.length; i++) {\n    var aAsInt = []\n    var a = pointsArr[i]\n\n    for (var j = 0; j < a.length; j++) {\n      aAsInt.push([Math.round(a[j].x * multiplier), Math.round(a[j].y * multiplier)])\n    }\n    aAsInt.push([Math.round(a[0].x * multiplier), Math.round(a[0].y * multiplier)]) // just to make sure last is equal to first\n\n    turfPolygons.push(turf.polygon([aAsInt]));\n  }\n}\n\n  \n// determines the quadrant of a point \n// (used in compare()) \nfunction quad(p) \n{ \n    if (p.x >= 0 && p.y >= 0) \n        return 1; \n    if (p.x <= 0 && p.y >= 0) \n        return 2; \n    if (p.x <= 0 && p.y <= 0) \n        return 3; \n    return 4; \n} \n  \n// Checks whether the line is crossing the polygon \nfunction orientation( a, b, c) \n{ \n    var res = (b.y-a.y)*(c.x-b.x) - \n              (c.y-b.y)*(b.x-a.x); \n  \n    if (res == 0) \n        return 0; \n    if (res > 0) \n        return 1; \n    return -1; \n} \n  \nfunction clonePoints (points) {\n  return points.slice(0)\n}\n\nfunction sortPoints (point, clonedPoints) {\n  clonedPoints.sort((a, b) => {\n    var p = new _Point__WEBPACK_IMPORTED_MODULE_1__[\"Point\"]([a.x - mid.x, \n                                a.y - mid.y]); \n    var q = new _Point__WEBPACK_IMPORTED_MODULE_1__[\"Point\"]([b.x - mid.x, \n                                b.y - mid.y]); \n  \n    var one = quad(p); \n    var two = quad(q); \n  \n    if (one != two) \n        return (one < two ? -1 : 1); \n    return (p.y*q.x < q.y*p.x ? -1 : 1); \n  })\n}\n\n// function sortPoints (point, clonedPoints) {\n//   clonedPoints.sort((a, b) => {\n//     const angle1 = point.angleToPoint(a)\n//     const angle2 = point.angleToPoint(b)\n//     if (angle1 < angle2) return -1\n//     if (angle1 > angle2) return 1\n//     const dist1 = calcEdgeDistance(point, a)\n//     const dist2 = calcEdgeDistance(point, b)\n//     if (dist1 < dist2) return -1\n//     if (dist1 > dist2) return 1\n//     return 0\n//   })\n// }\n\nfunction getPolygonTangents(srcPoint, pointsArr){\n    // initialize using first point\n    var firstPoint = pointsArr[pointsArr.length - 1]\n    var angle = srcPoint.angleToPoint(firstPoint)\n    var leftMostAngle = angle\n    var rightMostAngle = angle\n    var leftMostPoint = firstPoint\n    var rightMostPoint = firstPoint\n        // routeLayer.setLatLngs([srcPoint, firstPoint])\n\n    for (var i =  pointsArr.length - 2;  i >= 0; i--) {\n        // is this point more towards left than left most point?\n        var angle = srcPoint.angleToPoint(pointsArr[i])\n        var diff1 = rightMostAngle - angle\n        diff1 = diff1 < 0 ? ((diff1 < -Math.PI) ? diff1 + Math.PI*2 : Math.PI * 3) : diff1\n        // diff1 = diff1 < 0 ? diff1 + Math.PI*2 : diff1\n\n        // is this point more towards right than right most point?\n        var angle = srcPoint.angleToPoint(pointsArr[i])\n        var diff2 = angle - leftMostAngle\n        diff2 = diff2 < 0 ? ((diff2 < -Math.PI) ? diff2 + Math.PI*2 : Math.PI * 3) : diff2\n        // diff2 = diff2 < 0 ? diff2 + Math.PI*2 : diff2\n\n        // if(i == 56)\n        //   i = i\n\n\n        /* if unchartered angle */\n        if(diff1 < Math.PI/2 || diff2 < Math.PI/2){\n          if(diff1 < diff2){\n            /* if closer to left most point */\n            rightMostAngle = angle\n            rightMostPoint = pointsArr[i]\n          }else{\n            leftMostAngle = angle\n            leftMostPoint = pointsArr[i]\n            // break\n          }\n        }\n    }\n\n    return [leftMostPoint, rightMostPoint]\n}\n\nfunction getDynamicEdgesJSON(startPoint, endPoint)\n{\n  var dynamicEdgesJSON = \"\"\n  // var startPoint = new Point([startPoint.geometry.coordinates[0], startPoint.geometry.coordinates[1]]);\n  // var endPoint = new Point([endPoint.geometry.coordinates[0], endPoint.geometry.coordinates[1]]);\n  Object(_src_main__WEBPACK_IMPORTED_MODULE_4__[\"addStartingAndEndingNodes\"])(startPoint, endPoint)\n\n\n  var pointsToConnect = []\n  var polygonIds = []\n  pointsToConnect.push([endPoint, startPoint])\n  pointsToConnect.push([startPoint, endPoint])\n  polygonIds.push(-1)\n  polygonIds.push(-1)\n  var k = 0\n\n  while(pointsToConnect.length != 0){\n    var oldPointsToConnect = pointsToConnect.slice(0)\n    var oldPolygonIds = polygonIds.slice(0)\n    pointsToConnect = []\n    polygonIds = []\n\n    for (var i = oldPointsToConnect.length - 1; i >= 0; i--) {\n      var srcPoint = oldPointsToConnect[i][0]\n      var destPoint = oldPointsToConnect[i][1]\n\n      var angle = srcPoint.angleToPoint(destPoint)\n      var noObstructingPolygons = true\n\n      for (var j = pointsArr.length - 1; j >= 0; j--) {\n        var tangents = getPolygonTangents(oldPointsToConnect[i][0], pointsArr[j])\n        var angle1 = srcPoint.angleToPoint(tangents[0])\n        var angle2 = srcPoint.angleToPoint(tangents[1])\n\n        // make all angles relative to right most angle (angle2) by making right most angle 0 (starting angle)\n        var angle0 = angle - angle2\n        angle1 -= angle2\n        angle2 -= angle2\n\n        if(angle2 < angle0 && angle0 < angle1){\n          var obstructingEdge = Object(_src_main__WEBPACK_IMPORTED_MODULE_4__[\"getObstructingEdge\"])(oldPointsToConnect[i][0], oldPointsToConnect[i][1], pointsArr[j])\n\n          if(obstructingEdge != null){\n            noObstructingPolygons = false\n            pointsToConnect.push([oldPointsToConnect[i][0], tangents[0]])\n            pointsToConnect.push([oldPointsToConnect[i][0], tangents[1]])\n            break;\n          }\n        }\n      }\n\n      if(noObstructingPolygons)\n        dynamicEdgesJSON += ',{\"fromId\":\"'+createNodeId2(oldPointsToConnect[i][0])+'\",\"toId\":\"'+createNodeId2(oldPointsToConnect[i][1])+'\"}'\n    }\n    k++\n  }\n\n  return dynamicEdgesJSON\n}\n\n// function getDynamicEdgesJSON(startPoint, endPoint)\n// {\n//   var dynamicEdgesJSON = \"\"\n//   // var nearestPoint\n//   // var start = turf.point([Math.round(startPoint.geometry.coordinates[0] * multiplier), Math.round(startPoint.geometry.coordinates[1] * multiplier)]);\n//   // var end = turf.point([Math.round(endPoint.geometry.coordinates[0] * multiplier), Math.round(endPoint.geometry.coordinates[1] * multiplier)]);\n//   var startPoint = new Point([startPoint.geometry.coordinates[0], startPoint.geometry.coordinates[1]]);\n//   var endPoint = new Point([endPoint.geometry.coordinates[0], endPoint.geometry.coordinates[1]]);\n//   addStartingAndEndingNodes(startPoint, endPoint)\n\n//   var pointsToConnect = []\n//   var polygonIds = []\n//   pointsToConnect.push([endPoint, startPoint])\n//   // pointsToConnect.push([startPoint, endPoint])\n//   polygonIds.push(-1)\n//   // polygonIds.push(-1)\n//   var k = 0\n\n//   while(pointsToConnect.length != 0){\n//     var oldPointsToConnect = pointsToConnect.slice(0)\n//     var oldPolygonIds = polygonIds.slice(0)\n//     pointsToConnect = []\n//     polygonIds = []\n//     for (var i = oldPointsToConnect.length - 1; i >= 0; i--) {\n//       // var turfPoint = turf.point([Math.round(oldPointsToConnect[i][0].x * multiplier), Math.round(oldPointsToConnect[i][0].y * multiplier)]);\n//       var obstructingEdge = getObstructingEdge(oldPointsToConnect[i][0], oldPointsToConnect[i][1])\n//       if(obstructingEdge == null){\n//         // if(isVisible(oldPointsToConnect[i][0], oldPointsToConnect[i][1]))\n//           dynamicEdgesJSON += ',{\"fromId\":\"'+createNodeId2(oldPointsToConnect[i][0])+'\",\"toId\":\"'+createNodeId2(oldPointsToConnect[i][1])+'\"}'\n//       }else{\n//         var j = turfPolygons.length - obstructingEdge.p1.polygonID - 1\n//         if(j == oldPolygonIds[i])\n//           dynamicEdgesJSON += ',{\"fromId\":\"'+createNodeId2(oldPointsToConnect[i][0])+'\",\"toId\":\"'+createNodeId2(oldPointsToConnect[i][1])+'\"}'\n//         else{\n//           var tangents = getPolygonTangents(oldPointsToConnect[i][0], pointsArr[j])\n//           pointsToConnect.push([oldPointsToConnect[i][0], tangents[0]])\n//           pointsToConnect.push([oldPointsToConnect[i][0], tangents[1]])\n//           polygonIds.push(j)\n//           polygonIds.push(j)\n\n\n\n\n\n\n\n\n\n\n\n//           // var features1 = turf.polygonTangents(turfPoint, turfPolygons[j]).features\n//           // if(features1.length > 2)\n//           //   alert('More than 2 tangents')\n\n//           // var nearestPoint = turf.nearestPoint(turf.point([features1[0].geometry.coordinates[0]/multiplier, features1[0].geometry.coordinates[1]/multiplier]), points)\n//           // var tangent1 = new Point([nearestPoint.geometry.coordinates[0], nearestPoint.geometry.coordinates[1]])\n//           // nearestPoint = turf.nearestPoint(turf.point([features1[1].geometry.coordinates[0]/multiplier, features1[1].geometry.coordinates[1]/multiplier]), points)\n//           // var tangent2 = new Point([nearestPoint.geometry.coordinates[0], nearestPoint.geometry.coordinates[1]])\n//           // pointsToConnect.push([oldPointsToConnect[i][0], tangent1])\n//           // pointsToConnect.push([oldPointsToConnect[i][0], tangent2])\n//           // polygonIds.push(j)\n//           // polygonIds.push(j)\n\n\n\n\n\n\n\n\n\n//           if(k==0){\n//             pointsToConnect.push([oldPointsToConnect[oldPointsToConnect.length-1-i][0], tangents[0]])\n//             pointsToConnect.push([oldPointsToConnect[oldPointsToConnect.length-1-i][0], tangents[1]])\n//             polygonIds.push(-1)\n//             polygonIds.push(-1)\n//           }\n\n\n//           // if(k==0){\n//           //   console.log(\"\\tvar start = [\"+createNodeId2(oldPointsToConnect[i][0])+\"]\\n\\tvar end = [\"+createNodeId2(tangents[0])+\"]\\n\\n\")\n//           //   console.log(\"\\tvar start = [\"+createNodeId2(oldPointsToConnect[i][0])+\"]\\n\\tvar end = [\"+createNodeId2(tangents[1])+\"]\\n\\n\")\n//           //   if(i==0)\n//           //     return dynamicEdgesJSON;\n//           // }\n\n//         }\n//       }\n//     }\n//     k++\n//   }\n\n//   // var nodesVisible1 = getVisibleNodes(startPoint, startPoint, endPoint)\n//   // var nodesVisible2 = getVisibleNodes(endPoint)\n//   // var startTangents = []\n//   // var endTangents = []\n\n//   // for (var i = 0; i < turfPolygons.length; i++) {\n//   //   console.log('test');\n\n//   //   var features1 = turf.polygonTangents(start, turfPolygons[i]).features\n//   //   var features2 = turf.polygonTangents(end, turfPolygons[i]).features\n\n//   //   var startTangent1 = new Point([features1[0].geometry.coordinates[0]/multiplier, features1[0].geometry.coordinates[1]/multiplier])\n//   //   var startTangent2 = new Point([features1[1].geometry.coordinates[0]/multiplier, features1[1].geometry.coordinates[1]/multiplier])\n//   //   startTangents.push(startTangent1)\n//   //   startTangents.push(startTangent2)\n\n//   //   var endTangent1 = new Point([features2[0].geometry.coordinates[0]/multiplier, features2[0].geometry.coordinates[1]/multiplier])\n//   //   var endTangent2 = new Point([features2[1].geometry.coordinates[0]/multiplier, features2[1].geometry.coordinates[1]/multiplier])\n//   //   endTangents.push(endTangent1)\n//   //   endTangents.push(endTangent2)\n\n//   //   if(i==11){\n//   //     console.log(\"\\tvar start = [\"+createNodeId2(startPoint)+\"]\\n\\tvar end = [\"+createNodeId(turf.nearestPoint(turf.point([startTangent1.x, startTangent1.y]), points))+\"]\\n\\n\")\n//   //     console.log(\"\\tvar start = [\"+createNodeId2(startPoint)+\"]\\n\\tvar end = [\"+createNodeId(turf.nearestPoint(turf.point([startTangent2.x, startTangent2.y]), points))+\"]\\n\\n\")\n//   //     console.log(\"\\tvar start = [\"+createNodeId2(endPoint)+\"]\\n\\tvar end = [\"+createNodeId(turf.nearestPoint(turf.point([endTangent1.x, endTangent1.y]), points))+\"]\\n\\n\")\n//   //     console.log(\"\\tvar start = [\"+createNodeId2(endPoint)+\"]\\n\\tvar end = [\"+createNodeId(turf.nearestPoint(turf.point([endTangent2.x, endTangent2.y]), points))+\"]\\n\\n\")\n//   //   }\n\n//   // }\n\n//   // for (var j = nodesVisible1.length - 1; j >= 0; j--) {\n//   //   for (var i = startTangents.length - 1; i >= 0; i--) {\n//   //     if(nodesVisible1[j].x == startTangents[i].x && nodesVisible1[j].y == startTangents[i].y ){\n//   //       nearestPoint = turf.nearestPoint(turf.point([startTangents[i].x, startTangents[i].y]), points)\n//   //       dynamicEdgesJSON += ',{\"fromId\":\"'+createNodeId2(startPoint)+'\",\"toId\":\"'+createNodeId(nearestPoint)+'\"}'\n//   //     }\n//   //   }\n//   //   // if(nodesVisible1[j].x == startTangent2.x && nodesVisible1[j].y == startTangent2.y ){\n//   //   //   nearestPoint = turf.nearestPoint(turf.point([startTangent2.x, startTangent2.y]), points)\n//   //   //   dynamicEdgesJSON += ',{\"fromId\":\"'+createNodeId2(startPoint)+'\",\"toId\":\"'+createNodeId(nearestPoint)+'\"}'\n//   //   // }\n//   // }\n\n//   // for (var j = nodesVisible2.length - 1; j >= 0; j--) {\n//   //   for (var i = endTangents.length - 1; i >= 0; i--) {\n//   //     if(nodesVisible2[j].x == endTangents[i].x && nodesVisible2[j].y == endTangents[i].y ){\n//   //       nearestPoint = turf.nearestPoint(turf.point([endTangents[i].x, endTangents[i].y]), points)\n//   //       dynamicEdgesJSON += ',{\"fromId\":\"'+createNodeId2(endPoint)+'\",\"toId\":\"'+createNodeId(nearestPoint)+'\"}'\n//   //     }\n//   //   }\n//   //   // if(nodesVisible2[j].x == endTangent1.x && nodesVisible2[j].y == endTangent1.y ){\n//   //   //   nearestPoint = turf.nearestPoint(turf.point([endTangent1.x, endTangent1.y]), points)\n//   //   //   dynamicEdgesJSON += ',{\"fromId\":\"'+createNodeId2(endPoint)+'\",\"toId\":\"'+createNodeId(nearestPoint)+'\"}'\n//   //   // }\n//   //   // if(nodesVisible2[j].x == endTangent2.x && nodesVisible2[j].y == endTangent2.y ){\n//   //   //   nearestPoint = turf.nearestPoint(turf.point([endTangent2.x, endTangent2.y]), points)\n//   //   //   dynamicEdgesJSON += ',{\"fromId\":\"'+createNodeId2(endPoint)+'\",\"toId\":\"'+createNodeId(nearestPoint)+'\"}'\n//   //   // }\n//   // }\n\n//   return dynamicEdgesJSON\n// }\n\n\nfunction getDynamicNodesJSON(startPoint, endPoint)\n{\n  var dynamicNodesJSON = \"\"\n  // var startPoint = new Point([startPoint.geometry.coordinates[0], startPoint.geometry.coordinates[1]]);\n  // var endPoint = new Point([endPoint.geometry.coordinates[0], endPoint.geometry.coordinates[1]]);\n\n  dynamicNodesJSON += '{\"id\":\"'+createNodeId2(startPoint)+'\",\"data\":{\"x\":'+startPoint.x+',\"y\":'+startPoint.y+'}},'\n  dynamicNodesJSON += '{\"id\":\"'+createNodeId2(endPoint)+'\",\"data\":{\"x\":'+endPoint.x+',\"y\":'+endPoint.y+'}},'\n\n  // points.push(startPoint)\n  // points.push(endPoint)\n\n  return dynamicNodesJSON\n}\n\n\n\n// Finds upper tangent of two polygons 'a' and 'b' \nfunction find4Tangents(a, b) \n// function find4Tangents(a, b, polygon1, polygon2) \n{ \n  // var aAsInt = []\n  // var bAsInt = []\n\n  // for (var i = 0; i < a.length; i++) {\n  //   aAsInt.push([Math.round(a[i].x * multiplier), Math.round(a[i].y * multiplier)])\n  // }\n  // aAsInt.push([Math.round(a[0].x * multiplier), Math.round(a[0].y * multiplier)]) // just to make sure last is equal to first\n\n  // for (var i = 0; i < b.length; i++) {\n  //   bAsInt.push([Math.round(b[i].x * multiplier), Math.round(b[i].y * multiplier)])\n  // }\n  // bAsInt.push([Math.round(b[0].x * multiplier), Math.round(b[0].y * multiplier)]) // just to make sure last is equal to first\n\n  // var polygon1 = turf.polygon([aAsInt]);\n  // var polygon2 = turf.polygon([bAsInt]);\n\n\n\n\n\n\n\n  var tangents1 = []\n  var tangents2 = []\n  tangents1.push([a[0].x, a[0].y])\n\n\n\n\n\n\n  var findTangentOfB = 1\n  var tangentPairs = []\n  var done1 = 0;\n  var done2 = 0;\n  var iterationsRemaining = 10\n\n  while( iterationsRemaining > 0){\n    var tangents = []\n    var srcTangets = findTangentOfB ? tangents1 : tangents2\n    var oldTangents = findTangentOfB ? tangents2.slice(0) : tangents1.slice(0)\n    var polygon = findTangentOfB ? b : a\n    var matches = 0\n    var oldTangentPairs = tangentPairs.slice(0)\n    tangentPairs = []\n\n    for (var i = 0; i < srcTangets.length; i++) {\n      var rawTangents = []\n      var point = new _Point__WEBPACK_IMPORTED_MODULE_1__[\"Point\"](srcTangets[i]);\n      var rawTangents = getPolygonTangents(point, polygon)\n      // tangents = []\n\n      // for (var j = 0; j < features.length; j++)\n      //   rawTangents.push(features[j])\n\n      var srcPoint = new _Point__WEBPACK_IMPORTED_MODULE_1__[\"Point\"](srcTangets[i])\n      var p1 = rawTangents[0]\n      var p2 = rawTangents[1]\n      var angle1 = srcPoint.angleToPoint(p1)\n      var angle2 = srcPoint.angleToPoint(p2)\n      var diff = angle1 - angle2\n      diff = diff < 0 ? diff + Math.PI*2 : diff\n\n      var rightTangent = rawTangents[1]\n      var leftTangent = rawTangents[0]\n\n      if(diff > Math.PI){\n        rightTangent = rawTangents[0]\n        leftTangent = rawTangents[1]\n      }\n\n\n      if(srcTangets.length <= 2){\n        tangents.push([leftTangent.x, leftTangent.y])\n        tangents.push([rightTangent.x, rightTangent.y])\n      }else{\n        if(typeof oldTangentPairs[i] == 'undefined')\n          continue;\n\n        var oldSource = new _Point__WEBPACK_IMPORTED_MODULE_1__[\"Point\"]([oldTangentPairs[i][1][0], oldTangentPairs[i][1][1]])\n        var dist1 = Object(_utils__WEBPACK_IMPORTED_MODULE_3__[\"calcEdgeDistance\"])(p1, oldSource)\n        var dist2 = Object(_utils__WEBPACK_IMPORTED_MODULE_3__[\"calcEdgeDistance\"])(p2, oldSource)\n\n        // var angle = srcPoint.angleToPoint(oldSource)\n        // var diff1 = angle1 - angle\n        // var diff2 = angle2 - angle\n        // diff1 = diff1 < 0 ? diff1 + Math.PI*2 : diff1\n        // diff2 = diff2 < 0 ? diff2 + Math.PI*2 : diff2\n\n        tangents.push(dist1 < dist2 ? [rawTangents[0].x, rawTangents[0].y] : [rawTangents[1].x, rawTangents[1].y])\n        // if(i == 0)\n        //   tangents.push(findTangentOfB ? leftTangent : leftTangent)\n        // else if(i == 1)\n        //   tangents.push(findTangentOfB ? leftTangent : rightTangent)\n        // else if(i == 2)\n        //   tangents.push(findTangentOfB ? rightTangent : leftTangent)\n        // else if(i == 3)\n        //   tangents.push(findTangentOfB ? rightTangent : rightTangent)\n      }\n\n\n      // if(srcTangets.length <= 2){\n      //   tangents.push(leftTangent)\n      //   tangents.push(rightTangent)\n      // }else{\n      //   if(i == 0)\n      //     tangents.push(findTangentOfB ? leftTangent : leftTangent)\n      //   else if(i == 1)\n      //     tangents.push(findTangentOfB ? leftTangent : rightTangent)\n      //   else if(i == 2)\n      //     tangents.push(findTangentOfB ? rightTangent : leftTangent)\n      //   else if(i == 3)\n      //     tangents.push(findTangentOfB ? rightTangent : rightTangent)\n      // }\n\n\n        for (var m = 0; m < tangents.length; m++) {\n        // for (var k = oldTangents.length - 1; k >= 0; k--) {\n          var tangent = tangents[m]\n          if(srcTangets.length > 2)\n            tangent = tangents[i]\n          // if(tangent[0] == oldTangents[k][0] && tangent[1] == oldTangents[k][1]){\n            // if(matches < 4){\n              // check for duplicates\n              var isUnique = true\n              for (var l = tangentPairs.length - 1; l >= 0; l--) {\n                if(tangentPairs[l][0][0] == tangent[0] && tangentPairs[l][0][1] == tangent[1])\n                  isUnique = false\n              }\n\n              if(isUnique){\n                tangentPairs.push([tangent, srcTangets[i]])\n              }\n              matches++\n\n              if(srcTangets.length > 2)\n                break\n            // }\n          // }\n        // }\n        }\n    }\n\n    if(findTangentOfB){\n      done2 = matches == 4 ? true : false\n      tangents2 = tangents.slice(0)\n    }else{\n      done1 = matches == 4 ? true : false\n      tangents1 = tangents.slice(0)\n    }\n\n    // if(iterationsRemaining == 7)\n    //   break\n\n    // if(matches < 4)\n    //   iterationsRemaining = 10\n\n    findTangentOfB = !findTangentOfB\n    iterationsRemaining--\n  }\n\n  for (var i = 0; i < tangentPairs.length; i++) {\n    // var tp1 = turf.point([tangentPairs[i][0][0],tangentPairs[i][0][1]]);\n    // var tp2 = turf.point([tangentPairs[i][1][0],tangentPairs[i][1][1]]);\n    // var nearestStart = turf.nearestPoint(tp1, points)\n    // var nearestEnd = turf.nearestPoint(tp2, points)\n    let p1 = new _Point__WEBPACK_IMPORTED_MODULE_1__[\"Point\"](tangentPairs[i][0])\n    let p2 = new _Point__WEBPACK_IMPORTED_MODULE_1__[\"Point\"](tangentPairs[i][1])\n\n\n\n    allTangents.push(p1)\n    allTangents.push(p2)\n\n    if(Object(_src_main__WEBPACK_IMPORTED_MODULE_4__[\"isVisible\"])(p1,p2))\n      output += ',{\"fromId\":\"'+createNodeId2(p1)+'\",\"toId\":\"'+createNodeId2(p2)+'\"}'\n    // if(i==0)\n      // console.log(\"\\tvar start = [\"+createNodeId2(p1)+\"]\\n\\tvar end = [\"+createNodeId2(p2)+\"]\\n\\n\")\n    // else{\n    //   var isVisible = true\n    //   var angle = p1.angleToPoint(p2)\n\n    //   for (var j = turfPolygons.length - 1; j >= 0; j--) {\n    //     var tpm1 = turf.point([tangentPairs[i][0][0] * multiplier,tangentPairs[i][0][1] * multiplier]);\n    //     var tpm2 = turf.point([tangentPairs[i][1][0] * multiplier,tangentPairs[i][1][1] * multiplier]);\n    //     if(turf.booleanPointInPolygon(tpm2, turfPolygons[i]))\n    //       continue\n\n    //     var features = turf.polygonTangents(tpm1, turfPolygons[j]).features\n    //     var t1 = new Point([features[0].geometry.coordinates[0]/multiplier, features[0].geometry.coordinates[1]/multiplier])\n    //     var t2 = new Point([features[1].geometry.coordinates[0]/multiplier, features[1].geometry.coordinates[1]/multiplier])\n    //     var angle1 = p1.angleToPoint(t1)\n    //     var angle2 = p1.angleToPoint(t2)\n    //     var diff = angle1 - angle2\n    //     diff = diff < 0 ? diff + Math.PI : diff\n\n    //     // ensure angle2 is the left one\n    //     if(diff > Math.PI/2){\n    //       var temp = angle1\n    //       angle1 = angle2\n    //       angle2 = temp\n    //     }\n\n    //     var diff1 = angle1 - angle\n    //     diff1 = diff1 < 0 ? diff1 + Math.PI : diff1\n\n    //     var diff2 = angle - angle2\n    //     diff2 = diff2 < 0 ? diff2 + Math.PI : diff2\n\n    //     // angle is between angle1 and angle2\n    //     if(diff1 < Math.PI/2 && diff2 < Math.PI/2){\n    //       const dist = calcEdgeDistance(p1, p2)\n    //       const dist1 = calcEdgeDistance(p1, t1)\n    //       const dist2 = calcEdgeDistance(p1, t2)\n\n    //       // if both tangents are closer\n    //       if(dist1<dist && dist2<dist){\n    //         isVisible = false\n    //         break;\n    //       }\n    //     }\n    //   }\n\n    //   if(isVisible)\n        // output += ',{\"fromId\":\"'+createNodeId(nearestStart)+'\",\"toId\":\"'+createNodeId(nearestEnd)+'\"}'\n    // }\n  }\n\n\n\n\n  // var m1 = L.marker([tangentPairs[0][0][0],tangentPairs[0][0][1], {\n  //   draggable: true,\n  //   icon: new L.NumberedDivIcon()\n  // })\n\n  // var m2 = L.marker(tangentPairs[0][1][0],tangentPairs[0][1][1], {\n  //   draggable: true,\n  //   icon: new L.NumberedDivIcon()\n  // })\n\n\n\n\n  // routeLayer.setLatLngs([])\n  // var nearestStart = turf.nearestPoint(t1, points)\n  // var nearestEnd = turf.nearestPoint(t2, points)\n  // foundPath = pathFinder.find(createNodeId(nearestStart), createNodeId(nearestEnd))\n  // drawPath()\n\n\n\n\n\n\n\n  // var tangents2 = [[features[0].geometry.coordinates[0]/multiplier, features[0].geometry.coordinates[1]/multiplier], \n  //                   [features[1].geometry.coordinates[0]/multiplier, features[1].geometry.coordinates[1]/multiplier]]\n\n\n\n\n\n  // var point = turf.point([Math.round(tangents2[0][0] * multiplier), Math.round(tangents2[0][1] * multiplier)]);\n  // var features = turf.polygonTangents(point, polygon1)\n  // var tangents1 = [[features[0].geometry.coordinates[0]/multiplier, features[0].geometry.coordinates[1]/multiplier], \n  //                   [features[1].geometry.coordinates[0]/multiplier, features[1].geometry.coordinates[1]/multiplier]]\n\n\n\n\n\n\n\n  // startMarker = L.marker([ a[0].x, a[0].y], {\n  //   draggable: true,\n  //   icon: new L.NumberedDivIcon()\n  // }).addTo(map)\n\n  // var tangent = [ tangents.features[0].geometry.coordinates[0]/multiplier, tangents.features[0].geometry.coordinates[1]/multiplier]\n\n  // endMarker = L.marker(tangent, {\n  //   draggable: true,\n  //   icon: new L.NumberedDivIcon()\n  // }).addTo(map)\n\n  // var nearestStart = turf.nearestPoint(startMarker.toGeoJSON(), points)\n  // var nearestEnd = turf.nearestPoint(endMarker.toGeoJSON(), points)\n  // foundPath = pathFinder.find(createNodeId(nearestStart), createNodeId(nearestEnd))\n  // drawPath()\n\n\n  // console.log(a[0].x + \",\" + a[0].y + \" \" + tangent[0] + \",\" + tangent[1])\n  // console.log('')\n\n\n\n\n\n\n\n\n\n\n    // // n1 -> number of points in polygon a \n    // // n2 -> number of points in polygon b \n    // var n1 = a.length, n2 = b.length; \n  \n    // // To find a point inside the convex polygon(centroid), \n    // // we sum up all the coordinates and then divide  by \n    // // n(number of points). But this would be a floating-point \n    // // value. So to get rid of this we multiply points \n    // // initially with n1 and then find the centre and \n    // // then divided it by n1 again. \n    // // Similarly we do divide and multiply for n2 (i.e., \n    // // elements of b) \n  \n    // // maxa and minb are used to check if polygon a \n    // // is left of b. \n    // var maxa = Number.MIN_SAFE_INTEGER; \n    // for (var i=0; i<n1; i++) \n    // { \n    //     maxa = Math.max(maxa, a[i].x); \n    //     mid.x  += a[i].x;\n    //     mid.y += a[i].y; \n    //     a[i].x *= n1; \n    //     a[i].y *= n1; \n    // } \n  \n    // // sorting the points in counter clockwise order \n    // // for polygon a \n    // const clonedA = clonePoints(a)\n    // sortPoints(a[0], clonedA)\n    // a = clonedA\n  \n    // for (var i=0; i<n1; i++) \n    // { \n    //     a[i].x /= n1; \n    //     a[i].y /= n1; \n    // } \n  \n    // mid = new Point([0,0])\n  \n    // var minb = Number.MAX_SAFE_INTEGER; \n    // for (var i=0; i<n2; i++) \n    // { \n    //     mid.x += b[i].x; \n    //     mid.y += b[i].y; \n    //     minb = Math.min(minb, b[i].x); \n    //     b[i].x *= n2; \n    //     b[i].y *= n2; \n    // } \n  \n    // // sorting the points in counter clockwise \n    // // order for polygon b \n    // const clonedB = clonePoints(b)\n    // sortPoints(b[0], clonedB)\n    // b = clonedB\n  \n    // for (var i=0; i<n2; i++) \n    // { \n    //     b[i].x/=n2; \n    //     b[i].y/=n2; \n    // } \n  \n    // // If a is to the right of b, swap a and b \n    // // This makes sure a is left of b. \n    // if (minb < maxa) \n    // { \n    //     b = [a, a = b][0];  // swap a and b    \n    //     n1 = a.length;\n    //     n2 = b.length;\n    // } \n  \n    // // ia -> rightmost point of a \n    // var ia = 0, ib = 0; \n    // for (var i=1; i<n1; i++) \n    //     if (a[i].x > a[ia].x) \n    //         ia = i; \n  \n    // // ib -> leftmost point of b \n    // for (var i=1; i<n2; i++) \n    //     if (b[i].x < b[ib].x) \n    //         ib=i; \n  \n    // // finding the upper tangent \n    // var inda = ia, indb = ib; \n    // var done = 0; \n    // while (!done) \n    // { \n    //     done = 1; \n    //     // const g = createGraph()\n    //     // g.addNode(createNodeId2(b[indb]), { x: b[indb].x, y: b[indb].y })\n    //     // g.addNode(createNodeId2(a[inda]), { x: a[inda].x, y: a[inda].y })\n    //     // g.addNode(createNodeId2(a[(inda+1)%n1]), { x: a[(inda+1)%n1].x, y: a[(inda+1)%n1].y })\n    //     // g.addLink(createNodeId2(b[indb]), createNodeId2(a[inda]))\n    //     // g.addLink(createNodeId2(a[inda]), createNodeId2(a[(inda+1)%n1]))\n    //     // setGraph(g)\n    //     // routeLayer.setLatLngs([b[indb], a[inda]])\n    //     // drawPath()\n\n    //     // routeLayer.setLatLngs([])\n\n\n    //     while (orientation(b[indb], a[inda], a[(inda+1)%n1]) > 0) \n    //         inda = (inda + 1) % n1; \n  \n    //     while (orientation(a[inda], b[indb], b[(n2+indb-1)%n2]) < 0) \n    //     { \n    //         indb = (n2+indb-1)%n2; \n    //         done = 0; \n    //     } \n    // } \n    // console.log(a[inda].x + \",\" + a[inda].y)\n  \n    // // cout << \"upper tangent (\" << a[inda].x << \",\"\n    // //     << a[inda].y << \") (\" << b[indb].x \n    // //     << \",\" << b[indb].y << \")\\n\"; \n} \n\n  function createNodeId2 (p) {\n    return p.x + ',' + p.y\n  }\n\nfunction clearGraphRelatedData () {\n  if (routeLayer !== null) routeLayer.setLatLngs([])\n  if (selectionLayer !== null) selectionLayer.clearLayers()\n}\n\nfunction setupRouteLayer () {\n  routeLayer = L.polyline([], {\n    color: '#EB3223'\n  }).addTo(map)\n}\n\nfunction setPathFinder (pathGraph) {\n  pathFinder = pathGraph\n  return updatePathMarkers()\n}\n\nfunction updatePathMarkers () {\n  if(updatingPathMarkers){\n    updatingPathMarkers = 0\n    return\n  }\n\n  updatingPathMarkers = true\n  const startCreation = window.performance.now()\n\n  if(routeLayer != null)\n    routeLayer.setLatLngs([])\n  Object(_src_main__WEBPACK_IMPORTED_MODULE_4__[\"restoreOriginalPointsAndEdges\"])()\n\n  if(routeLayer != null){\n    startPoint = new _Point__WEBPACK_IMPORTED_MODULE_1__[\"Point\"]([startMarker.toGeoJSON().geometry.coordinates[0], startMarker.toGeoJSON().geometry.coordinates[1]]);\n    endPoint = new _Point__WEBPACK_IMPORTED_MODULE_1__[\"Point\"]([endMarker.toGeoJSON().geometry.coordinates[0], endMarker.toGeoJSON().geometry.coordinates[1]]);\n  }\n\n  var dynamicNodesJSON = getDynamicNodesJSON(startPoint, endPoint)\n  var dynamicEdgesJSON = getDynamicEdgesJSON(startPoint, endPoint)\n  Object(_graphHelper__WEBPACK_IMPORTED_MODULE_6__[\"updateGraphWithDynamicJSON\"])(dynamicNodesJSON, dynamicEdgesJSON)\n\n  if(routeLayer != null){\n    var nearestStart = turf.nearestPoint(startMarker.toGeoJSON(), points)\n    var nearestEnd = turf.nearestPoint(endMarker.toGeoJSON(), points)\n    nearestStart = startMarker.toGeoJSON()\n    nearestEnd = endMarker.toGeoJSON()\n    foundPath = pathFinder.find(createNodeId(nearestStart), createNodeId(nearestEnd))\n    drawPath()\n  }else{\n    foundPath = pathFinder.find(createNodeId2(startPoint), createNodeId2(endPoint))\n  }\n  console.log(\"\\tvar start = [\"+createNodeId2(startPoint)+\"]\\n\\tvar end = [\"+createNodeId2(endPoint)+\"]\\n\\n\")\n\n  const endCreation = window.performance.now()\n  const timeTakenToCreate = parseInt(endCreation - startCreation)\n  console.log('Time to find path: ', timeTakenToCreate)\n\n  updatingPathMarkers = false\n\n  return foundPath\n}\n\nfunction drawPath () {\n  const pathLatLngs = foundPath.map(function (node) {\n    return [node.data.y, node.data.x]\n  })\n  routeLayer.setLatLngs(pathLatLngs)\n}\n\nfunction createNodeId (p) {\n  return p.geometry.coordinates[0] + ',' + p.geometry.coordinates[1]\n}\n\nfunction unhighlightFeature () {\n  selectionLayer.clearLayers()\n}\n\nfunction setGraph (gd) {\n  graphData = gd\n}\n\nfunction highlightFeature (e) {\n  selectionLayer.clearLayers()\n\n  const node = graphData.getNode(e.target._latlng.lng + ',' + e.target._latlng.lat)\n\n  graphData.forEachLinkedNode(e.target._latlng.lng + ',' + e.target._latlng.lat, function (linkedNode, link) {\n    L.polyline([[linkedNode.data.y, linkedNode.data.x], [node.data.y, node.data.x]], {\n      weight: 0.5,\n      opacity: 0.8,\n      pane: 'shadowPane',\n      interactive: false\n    }).addTo(selectionLayer)\n  })\n}\n\nfunction createNumberDiv () {\n  return L.Icon.extend({\n    options: {\n      iconSize: new L.Point(15, 15),\n      className: 'leaflet-div-icon'\n    },\n    createIcon: function () {\n      var div = document.createElement('div')\n      var numdiv = document.createElement('div')\n      numdiv.setAttribute('class', 'number')\n      numdiv.innerHTML = this.options['number'] || ''\n      div.appendChild(numdiv)\n      this._setIconStyles(div, 'icon')\n      return div\n    }\n  })\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFwSGVscGVycy5qcz9mYzY1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBc0M7QUFDUDtBQUNrQjtBQUM2QjtBQUN1RTtBQUN2RztBQUNZOzs7QUFHMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7OztBQUdBLG1CQUFtQiw0Q0FBSztBQUN4QixpQkFBaUIsNENBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJCdEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7Ozs7Ozs7OztBQVNBLEVBQUUsNERBQVU7O0FBRVosd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsSUFBSSxzRUFBYztBQUNsQjtBQUNBOztBQUVBLHVEQUF1RCxRQUFRO0FB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QTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0Esc0M7O0FBRUE7QUFDQSxZO0FBQ0EscUM7QUFDQSx3QjtBQUNBLFk7QUFDQSxRO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDO0FBQ0EsQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRSwrRUFBNkI7O0FBRS9CO0FBQ0EscUJBQXFCLDRDQUFLO0FBQzFCLG1CQUFtQiw0Q0FBSztBQUN4Qjs7QUFFQTtBQUNBO0FBQ0EsRUFBRSwrRUFBMEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJmaWxlIjoiLi9zcmMvbWFwSGVscGVycy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcmVhdGVHcmFwaCBmcm9tICduZ3JhcGguZ3JhcGgnXG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4vUG9pbnQnXG5pbXBvcnQgeyBzZXR1cFN0cnVjdHVyZSB9IGZyb20gJy4vc2V0dXBTdHJ1Y3R1cmUnXG5pbXBvcnQgeyBJTkYsIGVkZ2VJbnRlcnNlY3QsIG9uU2VnbWVudCwgY2N3LCBjYWxjRWRnZURpc3RhbmNlIH0gZnJvbSAnLi91dGlscydcbmltcG9ydCB7IGlzVmlzaWJsZSwgZ2V0VmlzaWJsZU5vZGVzLCBsb2FkUG9pbnRzLCByZXN0b3JlT3JpZ2luYWxQb2ludHNBbmRFZGdlcywgZ2V0T2JzdHJ1Y3RpbmdFZGdlLCBhZGRTdGFydGluZ0FuZEVuZGluZ05vZGVzIH0gZnJvbSAnLi4vLi4vc3JjL21haW4nXG5pbXBvcnQgeyBtYWtlQ29udmV4aHVsbCB9IGZyb20gJy4vY29udmV4LWh1bGwnXG5pbXBvcnQgeyB1cGRhdGVHcmFwaFdpdGhEeW5hbWljSlNPTiB9IGZyb20gJy4vZ3JhcGhIZWxwZXInXG5cblxubGV0IG1hcCA9IG51bGxcbmxldCBzdGFydE1hcmtlciA9IG51bGxcbmxldCBlbmRNYXJrZXIgPSBudWxsXG5sZXQgc2VsZWN0aW9uTGF5ZXIgPSBudWxsXG5sZXQgcG9seUxheWVyID0gbnVsbFxubGV0IHBvaW50cyA9IG51bGxcbmxldCBwb2ludHNMeXIgPSBudWxsXG5sZXQgZ3JhcGhEYXRhID0gbnVsbFxubGV0IGZvdW5kUGF0aCA9IG51bGxcbmxldCBwYXRoRmluZGVyID0gbnVsbFxubGV0IHJvdXRlTGF5ZXIgPSBudWxsXG5sZXQgcG9pbnRzMSA9IFtdXG5sZXQgcG9pbnRzMiA9IFtdXG5sZXQgcG9pbnRzQXJyID0gW11cbmxldCB0dXJmUG9seWdvbnMgPSBbXVxudmFyIG91dHB1dCA9IFwiXCJcbnZhciBtdWx0aXBsaWVyID0gMTAwMCAqIDEwMDAgKiAxMDAwICogMTAwMCAqIDEwMDAgKiAxMDAwICogMTAwMCAqIDEwMDBcbnZhciB1cGRhdGluZ1BhdGhNYXJrZXJzID0gZmFsc2VcbnZhciBhbGxUYW5nZW50cyA9IFtdXG52YXIgc3RhcnRQb2ludCA9IG51bGxcbnZhciBlbmRQb2ludCA9IG51bGxcblxuXG5leHBvcnQgZnVuY3Rpb24gc2V0dXBNYXAgKHN0YXJ0LCBlbmQsIHNob3dNYXApIHtcbiAgaWYoc2hvd01hcCl7XG4gICAgbWFwID0gTC5tYXAoJ21hcCcsIHtcbiAgICAgIG1pblpvb206IDEsXG4gICAgICBtYXhab29tOiAyMCxcbiAgICAgIGNlbnRlcjogWzAsIDBdLFxuICAgICAgem9vbTogMixcbiAgICAgIGNyczogTC5DUlMuU2ltcGxlXG4gICAgfSlcblxuICAgIEwuTnVtYmVyZWREaXZJY29uID0gY3JlYXRlTnVtYmVyRGl2KClcbiAgfVxuXG4gIGlmKHN0YXJ0ID09IG51bGwpe1xuICAgIC8vIHZhciBzdGFydCA9IFs3My4xOTM3NDk5OTQwMzk1NCwwLjY1NDg4MjgwNzI4NDU5MzZdXG4gICAgLy8gdmFyIGVuZCA9IFs3My4xOTg0NDk2MTE2NjQsMC42OTE5NTAxODk4MDc1ODVdXG5cbiAgICAvLyB2YXIgc3RhcnQgPSBbNzMuMjAzMTM3MjA1OTEzNjYsMC42Njg4ODQyNzczNDM3NV1cbiAgICAvLyB2YXIgZW5kID0gWzczLjIyNjg5MjA5MTMzMzg3LDAuNjc4MDUxNzU0ODMyMjY3OF1cblxuICAgIC8vIHZhciBzdGFydCA9IFs3My4yMDA3ODEyNDEwNTkzLDAuNjY1NDc4NTIzODIwNjM4N11cbiAgICAvLyB2YXIgZW5kID0gWzczLjIwMTA3NDIyNzY5MDcsMC43MDAzOTA2MjU3NDUwNTgxXVxuXG4gICAgLy8gdmFyIHN0YXJ0ID0gWzczLjE0NjU3NjQyNzM4LDAuNjYzOTkwMzYzNTQyNjM3OV1cbiAgICAvLyB2YXIgZW5kID0gWzczLjIwMTA3NDIyNzY5MDcsMC43MDAzOTA2MjU3NDUwNTgxXVxuXG5cbiAgICB2YXIgc3RhcnQgPSBbNzMuMTk3MDcwMzAwNTc5MDcsMC42Njc3NzM0NDA0ODAyMzIyXVxuICAgIHZhciBlbmQgPSBbNzMuMTc5MDE2MTEzMjgxMjUsMC42ODM0MTA2NDQ5OTY5MTEzXVxuXG5cblxuXG5cbiAgICB2YXIgc3RhcnQgPSBbNzMuMTg2Mjg4NDc1OTksMC42NjA1NDkwNzQzNTgxNDQxXVxuICAgIHZhciBlbmQgPSBbNzMuMTY5MDAyNTkwMjI0LDAuNjY4OTMxMTcwMTYzMDQ4N11cblxuXG5cblxuICAgIHZhciBzdGFydCA9IFs3My4yMzQzNzUsMC4xNDQ1MzExOTAzOTUzNTUyMl1cbiAgICB2YXIgZW5kID0gWzczLjE2OTAwMjU5MDIyNCwwLjY2ODkzMTE3MDE2MzA0ODddXG4gIH1cblxuXG4gIHN0YXJ0UG9pbnQgPSBuZXcgUG9pbnQoc3RhcnQpO1xuICBlbmRQb2ludCA9IG5ldyBQb2ludChlbmQpO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbiAgLy8gdmFyIHN0YXJ0ID0gWzczLjE5NjU1MDYwNzY4MSwwLjY3NDUzODUyNzAxMzE2OTJdXG4gIC8vIHZhciBlbmQgPSBbNzMuMTk1NjE3MTk4OTQ0LDAuNjc0NzQyMzYwNzY3MzgyNF1cblxuICAvLyB2YXIgc3RhcnQgPSBbNzMuMTg0NjE5MTQzNjA1MjMsMC42ODgwODU5MzIyODQ1OTM2XVxuICAvLyB2YXIgZW5kID0gWzczLjE5ODQ0OTYxMTY2NCwwLjY5MTk1MDE4OTgwNzU4NV1cblxuICBpZihzaG93TWFwKXtcbiAgICBzdGFydE1hcmtlciA9IEwubWFya2VyKFtzdGFydFsxXSxzdGFydFswXV0sIHtcbiAgICAgIGRyYWdnYWJsZTogdHJ1ZSxcbiAgICAgIGljb246IG5ldyBMLk51bWJlcmVkRGl2SWNvbigpXG4gICAgfSkuYWRkVG8obWFwKVxuXG4gICAgZW5kTWFya2VyID0gTC5tYXJrZXIoW2VuZFsxXSxlbmRbMF1dLCB7XG4gICAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgICBpY29uOiBuZXcgTC5OdW1iZXJlZERpdkljb24oKVxuICAgIH0pLmFkZFRvKG1hcClcblxuICAgIHN0YXJ0TWFya2VyLm9uKCdkcmFnJywgdXBkYXRlUGF0aE1hcmtlcnMpXG4gICAgZW5kTWFya2VyLm9uKCdkcmFnJywgdXBkYXRlUGF0aE1hcmtlcnMpXG4gICAgc2VsZWN0aW9uTGF5ZXIgPSBMLmxheWVyR3JvdXAoW10pLmFkZFRvKG1hcClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0RGF0YSAoZGF0YSwgc2hvd01hcCkge1xuICBpZihzaG93TWFwKXtcbiAgICBwb2x5TGF5ZXIgPSBMLmdlb0pzb24oZGF0YSwge1xuICAgICAgbm9DbGlwOiB0cnVlLFxuICAgICAgc3Ryb2tlOiBmYWxzZSxcbiAgICAgIGZpbGxDb2xvcjogJyM4Qjk5QUUnXG4gICAgfSkuYWRkVG8obWFwKVxuXG4gICAgbWFwLmZpdEJvdW5kcyhwb2x5TGF5ZXIuZ2V0Qm91bmRzKCksIHtcbiAgICAgIHBhZGRpbmc6IFsyMCwgMjBdXG4gICAgfSlcblxuICAgIHBvaW50cyA9IHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW10pXG5cbiAgICBwb2ludHNMeXIgPSBMLmxheWVyR3JvdXAoW10sIHtcbiAgICAgIHBhbmU6ICdwb3B1cFBhbmUnXG4gICAgfSkuYWRkVG8obWFwKVxuXG4gICAgdHVyZi5tZXRhLmNvb3JkRWFjaChkYXRhLCBmdW5jdGlvbiAoY3VycmVudENvb3JkKSB7XG4gICAgICBwb2ludHMuZmVhdHVyZXMucHVzaCh0dXJmLnBvaW50KFtjdXJyZW50Q29vcmRbMF0sIGN1cnJlbnRDb29yZFsxXV0pKVxuXG4gICAgICB2YXIgbGF5ZXIgPSBMLmNpcmNsZU1hcmtlcihbY3VycmVudENvb3JkWzFdLCBjdXJyZW50Q29vcmRbMF1dLCB7XG4gICAgICAgIHJhZGl1czogMyxcbiAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgZmlsbE9wYWNpdHk6IDAuNSxcbiAgICAgICAgb3JpZ1BvaW50OiBbY3VycmVudENvb3JkWzBdLCBjdXJyZW50Q29vcmRbMV1dXG4gICAgICB9KS5hZGRUbyhwb2ludHNMeXIpXG4gICAgICBsYXllci5vbignbW91c2VvdmVyJywgaGlnaGxpZ2h0RmVhdHVyZSlcbiAgICAgIGxheWVyLm9uKCdtb3VzZW91dCcsIHVuaGlnaGxpZ2h0RmVhdHVyZSlcblxuICAgIH0sIHRydWUpXG4gIH1cblxuXG5cblxuXG5cblxuXG4gIGxvYWRQb2ludHMoZGF0YSlcblxuICBmb3IgKHZhciBpID0gZGF0YS5mZWF0dXJlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IGVkZ2VzID0gW11cbiAgICBjb25zdCBwb2x5Z29ucyA9IFtdXG4gICAgcG9pbnRzMSA9IFtdXG4gICAgc2V0dXBTdHJ1Y3R1cmUoZGF0YS5mZWF0dXJlc1tpXSwgZWRnZXMsIHBvaW50czEsIHBvbHlnb25zLCBpKVxuICAgIHBvaW50c0Fyci5wdXNoKHBvaW50czEuc2xpY2UoMCkpXG4gIH1cblxuICAvLyBmb3IgKHZhciBpID0gZGF0YS5nZW9tZXRyeS5jb29yZGluYXRlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAvLyAgIGNvbnN0IGVkZ2VzID0gW11cbiAgLy8gICBjb25zdCBwb2x5Z29ucyA9IFtdXG4gIC8vICAgcG9pbnRzMSA9IFtdXG4gIC8vICAgc2V0dXBTdHJ1Y3R1cmUoZGF0YS5nZW9tZXRyeS5jb29yZGluYXRlc1tpXSwgZWRnZXMsIHBvaW50czEsIHBvbHlnb25zLCBpKVxuICAvLyAgIHBvaW50c0Fyci5wdXNoKHBvaW50czEuc2xpY2UoMCkpXG4gIC8vIH1cblxuICBsb2FkVHVyZlBvbHlnb25zKGRhdGEpXG5cblxuXG5cblxuXG5cblxuICAvLyB2YXIgdGFuZ2VudHMgPSBnZXRQb2x5Z29uVGFuZ2VudHMobmV3IFBvaW50KFs3My4xNDY1NzY0MjczOCwwLjY2Mzk5MDM2MzU0MjYzNzldKSwgcG9pbnRzQXJyWzExXSlcblxuICAvLyBjb25zb2xlLmxvZyhcIlxcdHZhciBzdGFydCA9IFtcIitjcmVhdGVOb2RlSWQyKG5ldyBQb2ludChbNzMuMTQ2NTc2NDI3MzgsMC42NjM5OTAzNjM1NDI2Mzc5XSkpK1wiXVxcblxcdHZhciBlbmQgPSBbXCIrY3JlYXRlTm9kZUlkMih0YW5nZW50c1sxXSkrXCJdXFxuXFxuXCIpXG5cblxuXG5cblxuICAgIGNvbnNvbGUubG9nKCdzdGFydGluZycpXG5cbiAgLy8gZm9yICh2YXIgaSA9IHBvaW50c0Fyci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAvLyAvLyBmb3IgKHZhciBpID0gMTkgLSAxOyBpID49IDA7IGktLSkge1xuICAvLyAgIC8vIHZhciBpID0gNDtcbiAgLy8gICAvLyB2YXIgaiA9IDExO1xuXG4gIC8vICAgLy8gdmFyIGkgPSA0O1xuICAvLyAgIC8vIHZhciBqID0gOTtcblxuICAvLyAgIC8vIHZhciBpID0gMTE7XG4gIC8vICAgLy8gdmFyIGogPSAwO1xuXG4gIC8vICAgZm9yICh2YXIgaiA9IGkgLSAxOyBqID49IDA7IGotLSkge1xuICAvLyAgIC8vIGZvciAodmFyIGogPSA1OyBqID49IDI7IGotLSkge1xuICAvLyAgIC8vICAgaWYoaSA9PSBqKSBjb250aW51ZVxuICAvLyAgICAgLy8gY29uc29sZS5sb2coJ3Rlc3QnKVxuICAvLyAgIC8vIGNvbnNvbGUubG9nKCdpOiAnICsgaSArICcgajogJyArIGopXG4gIC8vICAgICAvLyBmaW5kNFRhbmdlbnRzKHBvaW50c0FycltpXSwgcG9pbnRzQXJyW2pdLCB0dXJmUG9seWdvbnNbaV0sIHR1cmZQb2x5Z29uc1tqXSlcbiAgLy8gICAgIGZpbmQ0VGFuZ2VudHMocG9pbnRzQXJyW2ldLCBwb2ludHNBcnJbal0pXG5cbiAgLy8gICB9XG5cblxuICAvLyAgIC8vIGZpbmQgc2hvcnRjdXRzIHRvIHNraXAgY29uY2F2ZSBwYXJ0cyBvZiBwb2x5Z29uc1xuICAvLyAgIHZhciBwQXJyID0gcG9pbnRzQXJyW2ldXG4gIC8vICAgdmFyIGh1bGwgPSBtYWtlQ29udmV4aHVsbChwQXJyKTtcbiAgLy8gICBjb25zb2xlLmxvZygndGVzdCcpXG4gIC8vICAgdmFyIGwgPSAwXG4gIC8vICAgZm9yICh2YXIgayA9IDA7IGsgPCBodWxsLmxlbmd0aDsgaysrKSB7XG4gIC8vICAgICB2YXIgbmV4dFBvaW50ID0gaHVsbFsgKGsrMSkgJSBodWxsLmxlbmd0aCBdXG5cbiAgLy8gICAgIC8vIGZpbmQgdGhlIHBvaW50IHRoYXQgbWF0Y2hlcyB0aGUgcG9pbnQgaW4gdGhlIGh1bGxcbiAgLy8gICAgIHdoaWxlKCAhcEFycltsXS5pc1BvaW50RXF1YWwoaHVsbFtrXSkpe1xuICAvLyAgICAgICBsID0gKGwrMSkgJSBwQXJyLmxlbmd0aFxuICAvLyAgICAgfVxuICAgICAgXG4gIC8vICAgICAvLyBpZiB0aGUgbmV4dCBwb2ludCBpcyBkaWZmZXJlbnQgd2UgbmVlZCB0aGUgbGluZSBiZXR3ZWVuXG4gIC8vICAgICBpZiggIXBBcnJbbF0ubmV4dFBvaW50LmlzUG9pbnRFcXVhbChuZXh0UG9pbnQpKXtcbiAgLy8gICAgICAgLy8gaWYoaXNWaXNpYmxlKGh1bGxba10sbmV4dFBvaW50KSlcbiAgLy8gICAgICAgICBvdXRwdXQgKz0gJyx7XCJmcm9tSWRcIjpcIicrIGNyZWF0ZU5vZGVJZDIoaHVsbFtrXSkgKydcIixcInRvSWRcIjpcIicrY3JlYXRlTm9kZUlkMihuZXh0UG9pbnQpKydcIn0nXG4gIC8vICAgICB9XG4gIC8vICAgfVxuICAvLyB9XG5cbiAgLy8gY29uc29sZS5sb2coYWxsVGFuZ2VudHMubGVuZ3RoKVxuICAvLyBmb3IgKHZhciBpID0gYWxsVGFuZ2VudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgLy8gICBjb25zb2xlLmxvZygndGVzdCcpXG4gIC8vICAgdmFyIHAxID0gYWxsVGFuZ2VudHNbaV1cblxuICAvLyAgIHZhciBub2Rlc1Zpc2libGUgPSBnZXRWaXNpYmxlTm9kZXMocDEpXG5cbiAgLy8gICBmb3IgKHZhciBrID0gbm9kZXNWaXNpYmxlLmxlbmd0aCAtIDE7IGsgPj0gMDsgay0tKSB7XG4gIC8vICAgICBmb3IgKHZhciBqID0gaSAtIDE7IGogPj0gMDsgai0tKSB7XG4gIC8vICAgICAgIHZhciBwMiA9IGFsbFRhbmdlbnRzW2pdXG5cbiAgLy8gICAgICAgaWYobm9kZXNWaXNpYmxlW2tdLnggPT0gcDIueCAmJiBub2Rlc1Zpc2libGVba10ueSA9PSBwMi55ICl7XG4gIC8vICAgICAgICAgb3V0cHV0ICs9ICcse1wiZnJvbUlkXCI6XCInKyBjcmVhdGVOb2RlSWQyKHAxKSArJ1wiLFwidG9JZFwiOlwiJytjcmVhdGVOb2RlSWQyKHAyKSsnXCJ9J1xuICAvLyAgICAgICB9XG5cbiAgLy8gICAgICAgLy8gaWYoaXNWaXNpYmxlKHAxLCBwMikpXG4gIC8vICAgICAgIC8vICAgb3V0cHV0ICs9ICcse1wiZnJvbUlkXCI6XCInKyBjcmVhdGVOb2RlSWQyKHAxKSArJ1wiLFwidG9JZFwiOlwiJytjcmVhdGVOb2RlSWQyKHAyKSsnXCJ9J1xuICAvLyAgICAgfVxuICAvLyAgIH1cblxuICAvLyB9XG5cblxuICBjb25zb2xlLmxvZyhvdXRwdXQpXG5cbn1cblxuZnVuY3Rpb24gbG9hZFR1cmZQb2x5Z29ucyhkYXRhKXtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHNBcnIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYUFzSW50ID0gW11cbiAgICB2YXIgYSA9IHBvaW50c0FycltpXVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBhLmxlbmd0aDsgaisrKSB7XG4gICAgICBhQXNJbnQucHVzaChbTWF0aC5yb3VuZChhW2pdLnggKiBtdWx0aXBsaWVyKSwgTWF0aC5yb3VuZChhW2pdLnkgKiBtdWx0aXBsaWVyKV0pXG4gICAgfVxuICAgIGFBc0ludC5wdXNoKFtNYXRoLnJvdW5kKGFbMF0ueCAqIG11bHRpcGxpZXIpLCBNYXRoLnJvdW5kKGFbMF0ueSAqIG11bHRpcGxpZXIpXSkgLy8ganVzdCB0byBtYWtlIHN1cmUgbGFzdCBpcyBlcXVhbCB0byBmaXJzdFxuXG4gICAgdHVyZlBvbHlnb25zLnB1c2godHVyZi5wb2x5Z29uKFthQXNJbnRdKSk7XG4gIH1cbn1cblxuICBcbi8vIGRldGVybWluZXMgdGhlIHF1YWRyYW50IG9mIGEgcG9pbnQgXG4vLyAodXNlZCBpbiBjb21wYXJlKCkpIFxuZnVuY3Rpb24gcXVhZChwKSBcbnsgXG4gICAgaWYgKHAueCA+PSAwICYmIHAueSA+PSAwKSBcbiAgICAgICAgcmV0dXJuIDE7IFxuICAgIGlmIChwLnggPD0gMCAmJiBwLnkgPj0gMCkgXG4gICAgICAgIHJldHVybiAyOyBcbiAgICBpZiAocC54IDw9IDAgJiYgcC55IDw9IDApIFxuICAgICAgICByZXR1cm4gMzsgXG4gICAgcmV0dXJuIDQ7IFxufSBcbiAgXG4vLyBDaGVja3Mgd2hldGhlciB0aGUgbGluZSBpcyBjcm9zc2luZyB0aGUgcG9seWdvbiBcbmZ1bmN0aW9uIG9yaWVudGF0aW9uKCBhLCBiLCBjKSBcbnsgXG4gICAgdmFyIHJlcyA9IChiLnktYS55KSooYy54LWIueCkgLSBcbiAgICAgICAgICAgICAgKGMueS1iLnkpKihiLngtYS54KTsgXG4gIFxuICAgIGlmIChyZXMgPT0gMCkgXG4gICAgICAgIHJldHVybiAwOyBcbiAgICBpZiAocmVzID4gMCkgXG4gICAgICAgIHJldHVybiAxOyBcbiAgICByZXR1cm4gLTE7IFxufSBcbiAgXG5mdW5jdGlvbiBjbG9uZVBvaW50cyAocG9pbnRzKSB7XG4gIHJldHVybiBwb2ludHMuc2xpY2UoMClcbn1cblxuZnVuY3Rpb24gc29ydFBvaW50cyAocG9pbnQsIGNsb25lZFBvaW50cykge1xuICBjbG9uZWRQb2ludHMuc29ydCgoYSwgYikgPT4ge1xuICAgIHZhciBwID0gbmV3IFBvaW50KFthLnggLSBtaWQueCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEueSAtIG1pZC55XSk7IFxuICAgIHZhciBxID0gbmV3IFBvaW50KFtiLnggLSBtaWQueCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIueSAtIG1pZC55XSk7IFxuICBcbiAgICB2YXIgb25lID0gcXVhZChwKTsgXG4gICAgdmFyIHR3byA9IHF1YWQocSk7IFxuICBcbiAgICBpZiAob25lICE9IHR3bykgXG4gICAgICAgIHJldHVybiAob25lIDwgdHdvID8gLTEgOiAxKTsgXG4gICAgcmV0dXJuIChwLnkqcS54IDwgcS55KnAueCA/IC0xIDogMSk7IFxuICB9KVxufVxuXG4vLyBmdW5jdGlvbiBzb3J0UG9pbnRzIChwb2ludCwgY2xvbmVkUG9pbnRzKSB7XG4vLyAgIGNsb25lZFBvaW50cy5zb3J0KChhLCBiKSA9PiB7XG4vLyAgICAgY29uc3QgYW5nbGUxID0gcG9pbnQuYW5nbGVUb1BvaW50KGEpXG4vLyAgICAgY29uc3QgYW5nbGUyID0gcG9pbnQuYW5nbGVUb1BvaW50KGIpXG4vLyAgICAgaWYgKGFuZ2xlMSA8IGFuZ2xlMikgcmV0dXJuIC0xXG4vLyAgICAgaWYgKGFuZ2xlMSA+IGFuZ2xlMikgcmV0dXJuIDFcbi8vICAgICBjb25zdCBkaXN0MSA9IGNhbGNFZGdlRGlzdGFuY2UocG9pbnQsIGEpXG4vLyAgICAgY29uc3QgZGlzdDIgPSBjYWxjRWRnZURpc3RhbmNlKHBvaW50LCBiKVxuLy8gICAgIGlmIChkaXN0MSA8IGRpc3QyKSByZXR1cm4gLTFcbi8vICAgICBpZiAoZGlzdDEgPiBkaXN0MikgcmV0dXJuIDFcbi8vICAgICByZXR1cm4gMFxuLy8gICB9KVxuLy8gfVxuXG5mdW5jdGlvbiBnZXRQb2x5Z29uVGFuZ2VudHMoc3JjUG9pbnQsIHBvaW50c0Fycil7XG4gICAgLy8gaW5pdGlhbGl6ZSB1c2luZyBmaXJzdCBwb2ludFxuICAgIHZhciBmaXJzdFBvaW50ID0gcG9pbnRzQXJyW3BvaW50c0Fyci5sZW5ndGggLSAxXVxuICAgIHZhciBhbmdsZSA9IHNyY1BvaW50LmFuZ2xlVG9Qb2ludChmaXJzdFBvaW50KVxuICAgIHZhciBsZWZ0TW9zdEFuZ2xlID0gYW5nbGVcbiAgICB2YXIgcmlnaHRNb3N0QW5nbGUgPSBhbmdsZVxuICAgIHZhciBsZWZ0TW9zdFBvaW50ID0gZmlyc3RQb2ludFxuICAgIHZhciByaWdodE1vc3RQb2ludCA9IGZpcnN0UG9pbnRcbiAgICAgICAgLy8gcm91dGVMYXllci5zZXRMYXRMbmdzKFtzcmNQb2ludCwgZmlyc3RQb2ludF0pXG5cbiAgICBmb3IgKHZhciBpID0gIHBvaW50c0Fyci5sZW5ndGggLSAyOyAgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgLy8gaXMgdGhpcyBwb2ludCBtb3JlIHRvd2FyZHMgbGVmdCB0aGFuIGxlZnQgbW9zdCBwb2ludD9cbiAgICAgICAgdmFyIGFuZ2xlID0gc3JjUG9pbnQuYW5nbGVUb1BvaW50KHBvaW50c0FycltpXSlcbiAgICAgICAgdmFyIGRpZmYxID0gcmlnaHRNb3N0QW5nbGUgLSBhbmdsZVxuICAgICAgICBkaWZmMSA9IGRpZmYxIDwgMCA/ICgoZGlmZjEgPCAtTWF0aC5QSSkgPyBkaWZmMSArIE1hdGguUEkqMiA6IE1hdGguUEkgKiAzKSA6IGRpZmYxXG4gICAgICAgIC8vIGRpZmYxID0gZGlmZjEgPCAwID8gZGlmZjEgKyBNYXRoLlBJKjIgOiBkaWZmMVxuXG4gICAgICAgIC8vIGlzIHRoaXMgcG9pbnQgbW9yZSB0b3dhcmRzIHJpZ2h0IHRoYW4gcmlnaHQgbW9zdCBwb2ludD9cbiAgICAgICAgdmFyIGFuZ2xlID0gc3JjUG9pbnQuYW5nbGVUb1BvaW50KHBvaW50c0FycltpXSlcbiAgICAgICAgdmFyIGRpZmYyID0gYW5nbGUgLSBsZWZ0TW9zdEFuZ2xlXG4gICAgICAgIGRpZmYyID0gZGlmZjIgPCAwID8gKChkaWZmMiA8IC1NYXRoLlBJKSA/IGRpZmYyICsgTWF0aC5QSSoyIDogTWF0aC5QSSAqIDMpIDogZGlmZjJcbiAgICAgICAgLy8gZGlmZjIgPSBkaWZmMiA8IDAgPyBkaWZmMiArIE1hdGguUEkqMiA6IGRpZmYyXG5cbiAgICAgICAgLy8gaWYoaSA9PSA1NilcbiAgICAgICAgLy8gICBpID0gaVxuXG5cbiAgICAgICAgLyogaWYgdW5jaGFydGVyZWQgYW5nbGUgKi9cbiAgICAgICAgaWYoZGlmZjEgPCBNYXRoLlBJLzIgfHwgZGlmZjIgPCBNYXRoLlBJLzIpe1xuICAgICAgICAgIGlmKGRpZmYxIDwgZGlmZjIpe1xuICAgICAgICAgICAgLyogaWYgY2xvc2VyIHRvIGxlZnQgbW9zdCBwb2ludCAqL1xuICAgICAgICAgICAgcmlnaHRNb3N0QW5nbGUgPSBhbmdsZVxuICAgICAgICAgICAgcmlnaHRNb3N0UG9pbnQgPSBwb2ludHNBcnJbaV1cbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIGxlZnRNb3N0QW5nbGUgPSBhbmdsZVxuICAgICAgICAgICAgbGVmdE1vc3RQb2ludCA9IHBvaW50c0FycltpXVxuICAgICAgICAgICAgLy8gYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW2xlZnRNb3N0UG9pbnQsIHJpZ2h0TW9zdFBvaW50XVxufVxuXG5mdW5jdGlvbiBnZXREeW5hbWljRWRnZXNKU09OKHN0YXJ0UG9pbnQsIGVuZFBvaW50KVxue1xuICB2YXIgZHluYW1pY0VkZ2VzSlNPTiA9IFwiXCJcbiAgLy8gdmFyIHN0YXJ0UG9pbnQgPSBuZXcgUG9pbnQoW3N0YXJ0UG9pbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0sIHN0YXJ0UG9pbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV1dKTtcbiAgLy8gdmFyIGVuZFBvaW50ID0gbmV3IFBvaW50KFtlbmRQb2ludC5nZW9tZXRyeS5jb29yZGluYXRlc1swXSwgZW5kUG9pbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV1dKTtcbiAgYWRkU3RhcnRpbmdBbmRFbmRpbmdOb2RlcyhzdGFydFBvaW50LCBlbmRQb2ludClcblxuXG4gIHZhciBwb2ludHNUb0Nvbm5lY3QgPSBbXVxuICB2YXIgcG9seWdvbklkcyA9IFtdXG4gIHBvaW50c1RvQ29ubmVjdC5wdXNoKFtlbmRQb2ludCwgc3RhcnRQb2ludF0pXG4gIHBvaW50c1RvQ29ubmVjdC5wdXNoKFtzdGFydFBvaW50LCBlbmRQb2ludF0pXG4gIHBvbHlnb25JZHMucHVzaCgtMSlcbiAgcG9seWdvbklkcy5wdXNoKC0xKVxuICB2YXIgayA9IDBcblxuICB3aGlsZShwb2ludHNUb0Nvbm5lY3QubGVuZ3RoICE9IDApe1xuICAgIHZhciBvbGRQb2ludHNUb0Nvbm5lY3QgPSBwb2ludHNUb0Nvbm5lY3Quc2xpY2UoMClcbiAgICB2YXIgb2xkUG9seWdvbklkcyA9IHBvbHlnb25JZHMuc2xpY2UoMClcbiAgICBwb2ludHNUb0Nvbm5lY3QgPSBbXVxuICAgIHBvbHlnb25JZHMgPSBbXVxuXG4gICAgZm9yICh2YXIgaSA9IG9sZFBvaW50c1RvQ29ubmVjdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIHNyY1BvaW50ID0gb2xkUG9pbnRzVG9Db25uZWN0W2ldWzBdXG4gICAgICB2YXIgZGVzdFBvaW50ID0gb2xkUG9pbnRzVG9Db25uZWN0W2ldWzFdXG5cbiAgICAgIHZhciBhbmdsZSA9IHNyY1BvaW50LmFuZ2xlVG9Qb2ludChkZXN0UG9pbnQpXG4gICAgICB2YXIgbm9PYnN0cnVjdGluZ1BvbHlnb25zID0gdHJ1ZVxuXG4gICAgICBmb3IgKHZhciBqID0gcG9pbnRzQXJyLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgIHZhciB0YW5nZW50cyA9IGdldFBvbHlnb25UYW5nZW50cyhvbGRQb2ludHNUb0Nvbm5lY3RbaV1bMF0sIHBvaW50c0FycltqXSlcbiAgICAgICAgdmFyIGFuZ2xlMSA9IHNyY1BvaW50LmFuZ2xlVG9Qb2ludCh0YW5nZW50c1swXSlcbiAgICAgICAgdmFyIGFuZ2xlMiA9IHNyY1BvaW50LmFuZ2xlVG9Qb2ludCh0YW5nZW50c1sxXSlcblxuICAgICAgICAvLyBtYWtlIGFsbCBhbmdsZXMgcmVsYXRpdmUgdG8gcmlnaHQgbW9zdCBhbmdsZSAoYW5nbGUyKSBieSBtYWtpbmcgcmlnaHQgbW9zdCBhbmdsZSAwIChzdGFydGluZyBhbmdsZSlcbiAgICAgICAgdmFyIGFuZ2xlMCA9IGFuZ2xlIC0gYW5nbGUyXG4gICAgICAgIGFuZ2xlMSAtPSBhbmdsZTJcbiAgICAgICAgYW5nbGUyIC09IGFuZ2xlMlxuXG4gICAgICAgIGlmKGFuZ2xlMiA8IGFuZ2xlMCAmJiBhbmdsZTAgPCBhbmdsZTEpe1xuICAgICAgICAgIHZhciBvYnN0cnVjdGluZ0VkZ2UgPSBnZXRPYnN0cnVjdGluZ0VkZ2Uob2xkUG9pbnRzVG9Db25uZWN0W2ldWzBdLCBvbGRQb2ludHNUb0Nvbm5lY3RbaV1bMV0sIHBvaW50c0FycltqXSlcblxuICAgICAgICAgIGlmKG9ic3RydWN0aW5nRWRnZSAhPSBudWxsKXtcbiAgICAgICAgICAgIG5vT2JzdHJ1Y3RpbmdQb2x5Z29ucyA9IGZhbHNlXG4gICAgICAgICAgICBwb2ludHNUb0Nvbm5lY3QucHVzaChbb2xkUG9pbnRzVG9Db25uZWN0W2ldWzBdLCB0YW5nZW50c1swXV0pXG4gICAgICAgICAgICBwb2ludHNUb0Nvbm5lY3QucHVzaChbb2xkUG9pbnRzVG9Db25uZWN0W2ldWzBdLCB0YW5nZW50c1sxXV0pXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYobm9PYnN0cnVjdGluZ1BvbHlnb25zKVxuICAgICAgICBkeW5hbWljRWRnZXNKU09OICs9ICcse1wiZnJvbUlkXCI6XCInK2NyZWF0ZU5vZGVJZDIob2xkUG9pbnRzVG9Db25uZWN0W2ldWzBdKSsnXCIsXCJ0b0lkXCI6XCInK2NyZWF0ZU5vZGVJZDIob2xkUG9pbnRzVG9Db25uZWN0W2ldWzFdKSsnXCJ9J1xuICAgIH1cbiAgICBrKytcbiAgfVxuXG4gIHJldHVybiBkeW5hbWljRWRnZXNKU09OXG59XG5cbi8vIGZ1bmN0aW9uIGdldER5bmFtaWNFZGdlc0pTT04oc3RhcnRQb2ludCwgZW5kUG9pbnQpXG4vLyB7XG4vLyAgIHZhciBkeW5hbWljRWRnZXNKU09OID0gXCJcIlxuLy8gICAvLyB2YXIgbmVhcmVzdFBvaW50XG4vLyAgIC8vIHZhciBzdGFydCA9IHR1cmYucG9pbnQoW01hdGgucm91bmQoc3RhcnRQb2ludC5nZW9tZXRyeS5jb29yZGluYXRlc1swXSAqIG11bHRpcGxpZXIpLCBNYXRoLnJvdW5kKHN0YXJ0UG9pbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV0gKiBtdWx0aXBsaWVyKV0pO1xuLy8gICAvLyB2YXIgZW5kID0gdHVyZi5wb2ludChbTWF0aC5yb3VuZChlbmRQb2ludC5nZW9tZXRyeS5jb29yZGluYXRlc1swXSAqIG11bHRpcGxpZXIpLCBNYXRoLnJvdW5kKGVuZFBvaW50Lmdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdICogbXVsdGlwbGllcildKTtcbi8vICAgdmFyIHN0YXJ0UG9pbnQgPSBuZXcgUG9pbnQoW3N0YXJ0UG9pbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0sIHN0YXJ0UG9pbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV1dKTtcbi8vICAgdmFyIGVuZFBvaW50ID0gbmV3IFBvaW50KFtlbmRQb2ludC5nZW9tZXRyeS5jb29yZGluYXRlc1swXSwgZW5kUG9pbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV1dKTtcbi8vICAgYWRkU3RhcnRpbmdBbmRFbmRpbmdOb2RlcyhzdGFydFBvaW50LCBlbmRQb2ludClcblxuLy8gICB2YXIgcG9pbnRzVG9Db25uZWN0ID0gW11cbi8vICAgdmFyIHBvbHlnb25JZHMgPSBbXVxuLy8gICBwb2ludHNUb0Nvbm5lY3QucHVzaChbZW5kUG9pbnQsIHN0YXJ0UG9pbnRdKVxuLy8gICAvLyBwb2ludHNUb0Nvbm5lY3QucHVzaChbc3RhcnRQb2ludCwgZW5kUG9pbnRdKVxuLy8gICBwb2x5Z29uSWRzLnB1c2goLTEpXG4vLyAgIC8vIHBvbHlnb25JZHMucHVzaCgtMSlcbi8vICAgdmFyIGsgPSAwXG5cbi8vICAgd2hpbGUocG9pbnRzVG9Db25uZWN0Lmxlbmd0aCAhPSAwKXtcbi8vICAgICB2YXIgb2xkUG9pbnRzVG9Db25uZWN0ID0gcG9pbnRzVG9Db25uZWN0LnNsaWNlKDApXG4vLyAgICAgdmFyIG9sZFBvbHlnb25JZHMgPSBwb2x5Z29uSWRzLnNsaWNlKDApXG4vLyAgICAgcG9pbnRzVG9Db25uZWN0ID0gW11cbi8vICAgICBwb2x5Z29uSWRzID0gW11cbi8vICAgICBmb3IgKHZhciBpID0gb2xkUG9pbnRzVG9Db25uZWN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4vLyAgICAgICAvLyB2YXIgdHVyZlBvaW50ID0gdHVyZi5wb2ludChbTWF0aC5yb3VuZChvbGRQb2ludHNUb0Nvbm5lY3RbaV1bMF0ueCAqIG11bHRpcGxpZXIpLCBNYXRoLnJvdW5kKG9sZFBvaW50c1RvQ29ubmVjdFtpXVswXS55ICogbXVsdGlwbGllcildKTtcbi8vICAgICAgIHZhciBvYnN0cnVjdGluZ0VkZ2UgPSBnZXRPYnN0cnVjdGluZ0VkZ2Uob2xkUG9pbnRzVG9Db25uZWN0W2ldWzBdLCBvbGRQb2ludHNUb0Nvbm5lY3RbaV1bMV0pXG4vLyAgICAgICBpZihvYnN0cnVjdGluZ0VkZ2UgPT0gbnVsbCl7XG4vLyAgICAgICAgIC8vIGlmKGlzVmlzaWJsZShvbGRQb2ludHNUb0Nvbm5lY3RbaV1bMF0sIG9sZFBvaW50c1RvQ29ubmVjdFtpXVsxXSkpXG4vLyAgICAgICAgICAgZHluYW1pY0VkZ2VzSlNPTiArPSAnLHtcImZyb21JZFwiOlwiJytjcmVhdGVOb2RlSWQyKG9sZFBvaW50c1RvQ29ubmVjdFtpXVswXSkrJ1wiLFwidG9JZFwiOlwiJytjcmVhdGVOb2RlSWQyKG9sZFBvaW50c1RvQ29ubmVjdFtpXVsxXSkrJ1wifSdcbi8vICAgICAgIH1lbHNle1xuLy8gICAgICAgICB2YXIgaiA9IHR1cmZQb2x5Z29ucy5sZW5ndGggLSBvYnN0cnVjdGluZ0VkZ2UucDEucG9seWdvbklEIC0gMVxuLy8gICAgICAgICBpZihqID09IG9sZFBvbHlnb25JZHNbaV0pXG4vLyAgICAgICAgICAgZHluYW1pY0VkZ2VzSlNPTiArPSAnLHtcImZyb21JZFwiOlwiJytjcmVhdGVOb2RlSWQyKG9sZFBvaW50c1RvQ29ubmVjdFtpXVswXSkrJ1wiLFwidG9JZFwiOlwiJytjcmVhdGVOb2RlSWQyKG9sZFBvaW50c1RvQ29ubmVjdFtpXVsxXSkrJ1wifSdcbi8vICAgICAgICAgZWxzZXtcbi8vICAgICAgICAgICB2YXIgdGFuZ2VudHMgPSBnZXRQb2x5Z29uVGFuZ2VudHMob2xkUG9pbnRzVG9Db25uZWN0W2ldWzBdLCBwb2ludHNBcnJbal0pXG4vLyAgICAgICAgICAgcG9pbnRzVG9Db25uZWN0LnB1c2goW29sZFBvaW50c1RvQ29ubmVjdFtpXVswXSwgdGFuZ2VudHNbMF1dKVxuLy8gICAgICAgICAgIHBvaW50c1RvQ29ubmVjdC5wdXNoKFtvbGRQb2ludHNUb0Nvbm5lY3RbaV1bMF0sIHRhbmdlbnRzWzFdXSlcbi8vICAgICAgICAgICBwb2x5Z29uSWRzLnB1c2goailcbi8vICAgICAgICAgICBwb2x5Z29uSWRzLnB1c2goailcblxuXG5cblxuXG5cblxuXG5cblxuXG4vLyAgICAgICAgICAgLy8gdmFyIGZlYXR1cmVzMSA9IHR1cmYucG9seWdvblRhbmdlbnRzKHR1cmZQb2ludCwgdHVyZlBvbHlnb25zW2pdKS5mZWF0dXJlc1xuLy8gICAgICAgICAgIC8vIGlmKGZlYXR1cmVzMS5sZW5ndGggPiAyKVxuLy8gICAgICAgICAgIC8vICAgYWxlcnQoJ01vcmUgdGhhbiAyIHRhbmdlbnRzJylcblxuLy8gICAgICAgICAgIC8vIHZhciBuZWFyZXN0UG9pbnQgPSB0dXJmLm5lYXJlc3RQb2ludCh0dXJmLnBvaW50KFtmZWF0dXJlczFbMF0uZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0vbXVsdGlwbGllciwgZmVhdHVyZXMxWzBdLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdL211bHRpcGxpZXJdKSwgcG9pbnRzKVxuLy8gICAgICAgICAgIC8vIHZhciB0YW5nZW50MSA9IG5ldyBQb2ludChbbmVhcmVzdFBvaW50Lmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdLCBuZWFyZXN0UG9pbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV1dKVxuLy8gICAgICAgICAgIC8vIG5lYXJlc3RQb2ludCA9IHR1cmYubmVhcmVzdFBvaW50KHR1cmYucG9pbnQoW2ZlYXR1cmVzMVsxXS5nZW9tZXRyeS5jb29yZGluYXRlc1swXS9tdWx0aXBsaWVyLCBmZWF0dXJlczFbMV0uZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV0vbXVsdGlwbGllcl0pLCBwb2ludHMpXG4vLyAgICAgICAgICAgLy8gdmFyIHRhbmdlbnQyID0gbmV3IFBvaW50KFtuZWFyZXN0UG9pbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0sIG5lYXJlc3RQb2ludC5nZW9tZXRyeS5jb29yZGluYXRlc1sxXV0pXG4vLyAgICAgICAgICAgLy8gcG9pbnRzVG9Db25uZWN0LnB1c2goW29sZFBvaW50c1RvQ29ubmVjdFtpXVswXSwgdGFuZ2VudDFdKVxuLy8gICAgICAgICAgIC8vIHBvaW50c1RvQ29ubmVjdC5wdXNoKFtvbGRQb2ludHNUb0Nvbm5lY3RbaV1bMF0sIHRhbmdlbnQyXSlcbi8vICAgICAgICAgICAvLyBwb2x5Z29uSWRzLnB1c2goailcbi8vICAgICAgICAgICAvLyBwb2x5Z29uSWRzLnB1c2goailcblxuXG5cblxuXG5cblxuXG5cbi8vICAgICAgICAgICBpZihrPT0wKXtcbi8vICAgICAgICAgICAgIHBvaW50c1RvQ29ubmVjdC5wdXNoKFtvbGRQb2ludHNUb0Nvbm5lY3Rbb2xkUG9pbnRzVG9Db25uZWN0Lmxlbmd0aC0xLWldWzBdLCB0YW5nZW50c1swXV0pXG4vLyAgICAgICAgICAgICBwb2ludHNUb0Nvbm5lY3QucHVzaChbb2xkUG9pbnRzVG9Db25uZWN0W29sZFBvaW50c1RvQ29ubmVjdC5sZW5ndGgtMS1pXVswXSwgdGFuZ2VudHNbMV1dKVxuLy8gICAgICAgICAgICAgcG9seWdvbklkcy5wdXNoKC0xKVxuLy8gICAgICAgICAgICAgcG9seWdvbklkcy5wdXNoKC0xKVxuLy8gICAgICAgICAgIH1cblxuXG4vLyAgICAgICAgICAgLy8gaWYoaz09MCl7XG4vLyAgICAgICAgICAgLy8gICBjb25zb2xlLmxvZyhcIlxcdHZhciBzdGFydCA9IFtcIitjcmVhdGVOb2RlSWQyKG9sZFBvaW50c1RvQ29ubmVjdFtpXVswXSkrXCJdXFxuXFx0dmFyIGVuZCA9IFtcIitjcmVhdGVOb2RlSWQyKHRhbmdlbnRzWzBdKStcIl1cXG5cXG5cIilcbi8vICAgICAgICAgICAvLyAgIGNvbnNvbGUubG9nKFwiXFx0dmFyIHN0YXJ0ID0gW1wiK2NyZWF0ZU5vZGVJZDIob2xkUG9pbnRzVG9Db25uZWN0W2ldWzBdKStcIl1cXG5cXHR2YXIgZW5kID0gW1wiK2NyZWF0ZU5vZGVJZDIodGFuZ2VudHNbMV0pK1wiXVxcblxcblwiKVxuLy8gICAgICAgICAgIC8vICAgaWYoaT09MClcbi8vICAgICAgICAgICAvLyAgICAgcmV0dXJuIGR5bmFtaWNFZGdlc0pTT047XG4vLyAgICAgICAgICAgLy8gfVxuXG4vLyAgICAgICAgIH1cbi8vICAgICAgIH1cbi8vICAgICB9XG4vLyAgICAgaysrXG4vLyAgIH1cblxuLy8gICAvLyB2YXIgbm9kZXNWaXNpYmxlMSA9IGdldFZpc2libGVOb2RlcyhzdGFydFBvaW50LCBzdGFydFBvaW50LCBlbmRQb2ludClcbi8vICAgLy8gdmFyIG5vZGVzVmlzaWJsZTIgPSBnZXRWaXNpYmxlTm9kZXMoZW5kUG9pbnQpXG4vLyAgIC8vIHZhciBzdGFydFRhbmdlbnRzID0gW11cbi8vICAgLy8gdmFyIGVuZFRhbmdlbnRzID0gW11cblxuLy8gICAvLyBmb3IgKHZhciBpID0gMDsgaSA8IHR1cmZQb2x5Z29ucy5sZW5ndGg7IGkrKykge1xuLy8gICAvLyAgIGNvbnNvbGUubG9nKCd0ZXN0Jyk7XG5cbi8vICAgLy8gICB2YXIgZmVhdHVyZXMxID0gdHVyZi5wb2x5Z29uVGFuZ2VudHMoc3RhcnQsIHR1cmZQb2x5Z29uc1tpXSkuZmVhdHVyZXNcbi8vICAgLy8gICB2YXIgZmVhdHVyZXMyID0gdHVyZi5wb2x5Z29uVGFuZ2VudHMoZW5kLCB0dXJmUG9seWdvbnNbaV0pLmZlYXR1cmVzXG5cbi8vICAgLy8gICB2YXIgc3RhcnRUYW5nZW50MSA9IG5ldyBQb2ludChbZmVhdHVyZXMxWzBdLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdL211bHRpcGxpZXIsIGZlYXR1cmVzMVswXS5nZW9tZXRyeS5jb29yZGluYXRlc1sxXS9tdWx0aXBsaWVyXSlcbi8vICAgLy8gICB2YXIgc3RhcnRUYW5nZW50MiA9IG5ldyBQb2ludChbZmVhdHVyZXMxWzFdLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdL211bHRpcGxpZXIsIGZlYXR1cmVzMVsxXS5nZW9tZXRyeS5jb29yZGluYXRlc1sxXS9tdWx0aXBsaWVyXSlcbi8vICAgLy8gICBzdGFydFRhbmdlbnRzLnB1c2goc3RhcnRUYW5nZW50MSlcbi8vICAgLy8gICBzdGFydFRhbmdlbnRzLnB1c2goc3RhcnRUYW5nZW50MilcblxuLy8gICAvLyAgIHZhciBlbmRUYW5nZW50MSA9IG5ldyBQb2ludChbZmVhdHVyZXMyWzBdLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdL211bHRpcGxpZXIsIGZlYXR1cmVzMlswXS5nZW9tZXRyeS5jb29yZGluYXRlc1sxXS9tdWx0aXBsaWVyXSlcbi8vICAgLy8gICB2YXIgZW5kVGFuZ2VudDIgPSBuZXcgUG9pbnQoW2ZlYXR1cmVzMlsxXS5nZW9tZXRyeS5jb29yZGluYXRlc1swXS9tdWx0aXBsaWVyLCBmZWF0dXJlczJbMV0uZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV0vbXVsdGlwbGllcl0pXG4vLyAgIC8vICAgZW5kVGFuZ2VudHMucHVzaChlbmRUYW5nZW50MSlcbi8vICAgLy8gICBlbmRUYW5nZW50cy5wdXNoKGVuZFRhbmdlbnQyKVxuXG4vLyAgIC8vICAgaWYoaT09MTEpe1xuLy8gICAvLyAgICAgY29uc29sZS5sb2coXCJcXHR2YXIgc3RhcnQgPSBbXCIrY3JlYXRlTm9kZUlkMihzdGFydFBvaW50KStcIl1cXG5cXHR2YXIgZW5kID0gW1wiK2NyZWF0ZU5vZGVJZCh0dXJmLm5lYXJlc3RQb2ludCh0dXJmLnBvaW50KFtzdGFydFRhbmdlbnQxLngsIHN0YXJ0VGFuZ2VudDEueV0pLCBwb2ludHMpKStcIl1cXG5cXG5cIilcbi8vICAgLy8gICAgIGNvbnNvbGUubG9nKFwiXFx0dmFyIHN0YXJ0ID0gW1wiK2NyZWF0ZU5vZGVJZDIoc3RhcnRQb2ludCkrXCJdXFxuXFx0dmFyIGVuZCA9IFtcIitjcmVhdGVOb2RlSWQodHVyZi5uZWFyZXN0UG9pbnQodHVyZi5wb2ludChbc3RhcnRUYW5nZW50Mi54LCBzdGFydFRhbmdlbnQyLnldKSwgcG9pbnRzKSkrXCJdXFxuXFxuXCIpXG4vLyAgIC8vICAgICBjb25zb2xlLmxvZyhcIlxcdHZhciBzdGFydCA9IFtcIitjcmVhdGVOb2RlSWQyKGVuZFBvaW50KStcIl1cXG5cXHR2YXIgZW5kID0gW1wiK2NyZWF0ZU5vZGVJZCh0dXJmLm5lYXJlc3RQb2ludCh0dXJmLnBvaW50KFtlbmRUYW5nZW50MS54LCBlbmRUYW5nZW50MS55XSksIHBvaW50cykpK1wiXVxcblxcblwiKVxuLy8gICAvLyAgICAgY29uc29sZS5sb2coXCJcXHR2YXIgc3RhcnQgPSBbXCIrY3JlYXRlTm9kZUlkMihlbmRQb2ludCkrXCJdXFxuXFx0dmFyIGVuZCA9IFtcIitjcmVhdGVOb2RlSWQodHVyZi5uZWFyZXN0UG9pbnQodHVyZi5wb2ludChbZW5kVGFuZ2VudDIueCwgZW5kVGFuZ2VudDIueV0pLCBwb2ludHMpKStcIl1cXG5cXG5cIilcbi8vICAgLy8gICB9XG5cbi8vICAgLy8gfVxuXG4vLyAgIC8vIGZvciAodmFyIGogPSBub2Rlc1Zpc2libGUxLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4vLyAgIC8vICAgZm9yICh2YXIgaSA9IHN0YXJ0VGFuZ2VudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbi8vICAgLy8gICAgIGlmKG5vZGVzVmlzaWJsZTFbal0ueCA9PSBzdGFydFRhbmdlbnRzW2ldLnggJiYgbm9kZXNWaXNpYmxlMVtqXS55ID09IHN0YXJ0VGFuZ2VudHNbaV0ueSApe1xuLy8gICAvLyAgICAgICBuZWFyZXN0UG9pbnQgPSB0dXJmLm5lYXJlc3RQb2ludCh0dXJmLnBvaW50KFtzdGFydFRhbmdlbnRzW2ldLngsIHN0YXJ0VGFuZ2VudHNbaV0ueV0pLCBwb2ludHMpXG4vLyAgIC8vICAgICAgIGR5bmFtaWNFZGdlc0pTT04gKz0gJyx7XCJmcm9tSWRcIjpcIicrY3JlYXRlTm9kZUlkMihzdGFydFBvaW50KSsnXCIsXCJ0b0lkXCI6XCInK2NyZWF0ZU5vZGVJZChuZWFyZXN0UG9pbnQpKydcIn0nXG4vLyAgIC8vICAgICB9XG4vLyAgIC8vICAgfVxuLy8gICAvLyAgIC8vIGlmKG5vZGVzVmlzaWJsZTFbal0ueCA9PSBzdGFydFRhbmdlbnQyLnggJiYgbm9kZXNWaXNpYmxlMVtqXS55ID09IHN0YXJ0VGFuZ2VudDIueSApe1xuLy8gICAvLyAgIC8vICAgbmVhcmVzdFBvaW50ID0gdHVyZi5uZWFyZXN0UG9pbnQodHVyZi5wb2ludChbc3RhcnRUYW5nZW50Mi54LCBzdGFydFRhbmdlbnQyLnldKSwgcG9pbnRzKVxuLy8gICAvLyAgIC8vICAgZHluYW1pY0VkZ2VzSlNPTiArPSAnLHtcImZyb21JZFwiOlwiJytjcmVhdGVOb2RlSWQyKHN0YXJ0UG9pbnQpKydcIixcInRvSWRcIjpcIicrY3JlYXRlTm9kZUlkKG5lYXJlc3RQb2ludCkrJ1wifSdcbi8vICAgLy8gICAvLyB9XG4vLyAgIC8vIH1cblxuLy8gICAvLyBmb3IgKHZhciBqID0gbm9kZXNWaXNpYmxlMi5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuLy8gICAvLyAgIGZvciAodmFyIGkgPSBlbmRUYW5nZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuLy8gICAvLyAgICAgaWYobm9kZXNWaXNpYmxlMltqXS54ID09IGVuZFRhbmdlbnRzW2ldLnggJiYgbm9kZXNWaXNpYmxlMltqXS55ID09IGVuZFRhbmdlbnRzW2ldLnkgKXtcbi8vICAgLy8gICAgICAgbmVhcmVzdFBvaW50ID0gdHVyZi5uZWFyZXN0UG9pbnQodHVyZi5wb2ludChbZW5kVGFuZ2VudHNbaV0ueCwgZW5kVGFuZ2VudHNbaV0ueV0pLCBwb2ludHMpXG4vLyAgIC8vICAgICAgIGR5bmFtaWNFZGdlc0pTT04gKz0gJyx7XCJmcm9tSWRcIjpcIicrY3JlYXRlTm9kZUlkMihlbmRQb2ludCkrJ1wiLFwidG9JZFwiOlwiJytjcmVhdGVOb2RlSWQobmVhcmVzdFBvaW50KSsnXCJ9J1xuLy8gICAvLyAgICAgfVxuLy8gICAvLyAgIH1cbi8vICAgLy8gICAvLyBpZihub2Rlc1Zpc2libGUyW2pdLnggPT0gZW5kVGFuZ2VudDEueCAmJiBub2Rlc1Zpc2libGUyW2pdLnkgPT0gZW5kVGFuZ2VudDEueSApe1xuLy8gICAvLyAgIC8vICAgbmVhcmVzdFBvaW50ID0gdHVyZi5uZWFyZXN0UG9pbnQodHVyZi5wb2ludChbZW5kVGFuZ2VudDEueCwgZW5kVGFuZ2VudDEueV0pLCBwb2ludHMpXG4vLyAgIC8vICAgLy8gICBkeW5hbWljRWRnZXNKU09OICs9ICcse1wiZnJvbUlkXCI6XCInK2NyZWF0ZU5vZGVJZDIoZW5kUG9pbnQpKydcIixcInRvSWRcIjpcIicrY3JlYXRlTm9kZUlkKG5lYXJlc3RQb2ludCkrJ1wifSdcbi8vICAgLy8gICAvLyB9XG4vLyAgIC8vICAgLy8gaWYobm9kZXNWaXNpYmxlMltqXS54ID09IGVuZFRhbmdlbnQyLnggJiYgbm9kZXNWaXNpYmxlMltqXS55ID09IGVuZFRhbmdlbnQyLnkgKXtcbi8vICAgLy8gICAvLyAgIG5lYXJlc3RQb2ludCA9IHR1cmYubmVhcmVzdFBvaW50KHR1cmYucG9pbnQoW2VuZFRhbmdlbnQyLngsIGVuZFRhbmdlbnQyLnldKSwgcG9pbnRzKVxuLy8gICAvLyAgIC8vICAgZHluYW1pY0VkZ2VzSlNPTiArPSAnLHtcImZyb21JZFwiOlwiJytjcmVhdGVOb2RlSWQyKGVuZFBvaW50KSsnXCIsXCJ0b0lkXCI6XCInK2NyZWF0ZU5vZGVJZChuZWFyZXN0UG9pbnQpKydcIn0nXG4vLyAgIC8vICAgLy8gfVxuLy8gICAvLyB9XG5cbi8vICAgcmV0dXJuIGR5bmFtaWNFZGdlc0pTT05cbi8vIH1cblxuXG5mdW5jdGlvbiBnZXREeW5hbWljTm9kZXNKU09OKHN0YXJ0UG9pbnQsIGVuZFBvaW50KVxue1xuICB2YXIgZHluYW1pY05vZGVzSlNPTiA9IFwiXCJcbiAgLy8gdmFyIHN0YXJ0UG9pbnQgPSBuZXcgUG9pbnQoW3N0YXJ0UG9pbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0sIHN0YXJ0UG9pbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV1dKTtcbiAgLy8gdmFyIGVuZFBvaW50ID0gbmV3IFBvaW50KFtlbmRQb2ludC5nZW9tZXRyeS5jb29yZGluYXRlc1swXSwgZW5kUG9pbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV1dKTtcblxuICBkeW5hbWljTm9kZXNKU09OICs9ICd7XCJpZFwiOlwiJytjcmVhdGVOb2RlSWQyKHN0YXJ0UG9pbnQpKydcIixcImRhdGFcIjp7XCJ4XCI6JytzdGFydFBvaW50LngrJyxcInlcIjonK3N0YXJ0UG9pbnQueSsnfX0sJ1xuICBkeW5hbWljTm9kZXNKU09OICs9ICd7XCJpZFwiOlwiJytjcmVhdGVOb2RlSWQyKGVuZFBvaW50KSsnXCIsXCJkYXRhXCI6e1wieFwiOicrZW5kUG9pbnQueCsnLFwieVwiOicrZW5kUG9pbnQueSsnfX0sJ1xuXG4gIC8vIHBvaW50cy5wdXNoKHN0YXJ0UG9pbnQpXG4gIC8vIHBvaW50cy5wdXNoKGVuZFBvaW50KVxuXG4gIHJldHVybiBkeW5hbWljTm9kZXNKU09OXG59XG5cblxuXG4vLyBGaW5kcyB1cHBlciB0YW5nZW50IG9mIHR3byBwb2x5Z29ucyAnYScgYW5kICdiJyBcbmZ1bmN0aW9uIGZpbmQ0VGFuZ2VudHMoYSwgYikgXG4vLyBmdW5jdGlvbiBmaW5kNFRhbmdlbnRzKGEsIGIsIHBvbHlnb24xLCBwb2x5Z29uMikgXG57IFxuICAvLyB2YXIgYUFzSW50ID0gW11cbiAgLy8gdmFyIGJBc0ludCA9IFtdXG5cbiAgLy8gZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gIC8vICAgYUFzSW50LnB1c2goW01hdGgucm91bmQoYVtpXS54ICogbXVsdGlwbGllciksIE1hdGgucm91bmQoYVtpXS55ICogbXVsdGlwbGllcildKVxuICAvLyB9XG4gIC8vIGFBc0ludC5wdXNoKFtNYXRoLnJvdW5kKGFbMF0ueCAqIG11bHRpcGxpZXIpLCBNYXRoLnJvdW5kKGFbMF0ueSAqIG11bHRpcGxpZXIpXSkgLy8ganVzdCB0byBtYWtlIHN1cmUgbGFzdCBpcyBlcXVhbCB0byBmaXJzdFxuXG4gIC8vIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAvLyAgIGJBc0ludC5wdXNoKFtNYXRoLnJvdW5kKGJbaV0ueCAqIG11bHRpcGxpZXIpLCBNYXRoLnJvdW5kKGJbaV0ueSAqIG11bHRpcGxpZXIpXSlcbiAgLy8gfVxuICAvLyBiQXNJbnQucHVzaChbTWF0aC5yb3VuZChiWzBdLnggKiBtdWx0aXBsaWVyKSwgTWF0aC5yb3VuZChiWzBdLnkgKiBtdWx0aXBsaWVyKV0pIC8vIGp1c3QgdG8gbWFrZSBzdXJlIGxhc3QgaXMgZXF1YWwgdG8gZmlyc3RcblxuICAvLyB2YXIgcG9seWdvbjEgPSB0dXJmLnBvbHlnb24oW2FBc0ludF0pO1xuICAvLyB2YXIgcG9seWdvbjIgPSB0dXJmLnBvbHlnb24oW2JBc0ludF0pO1xuXG5cblxuXG5cblxuXG4gIHZhciB0YW5nZW50czEgPSBbXVxuICB2YXIgdGFuZ2VudHMyID0gW11cbiAgdGFuZ2VudHMxLnB1c2goW2FbMF0ueCwgYVswXS55XSlcblxuXG5cblxuXG5cbiAgdmFyIGZpbmRUYW5nZW50T2ZCID0gMVxuICB2YXIgdGFuZ2VudFBhaXJzID0gW11cbiAgdmFyIGRvbmUxID0gMDtcbiAgdmFyIGRvbmUyID0gMDtcbiAgdmFyIGl0ZXJhdGlvbnNSZW1haW5pbmcgPSAxMFxuXG4gIHdoaWxlKCBpdGVyYXRpb25zUmVtYWluaW5nID4gMCl7XG4gICAgdmFyIHRhbmdlbnRzID0gW11cbiAgICB2YXIgc3JjVGFuZ2V0cyA9IGZpbmRUYW5nZW50T2ZCID8gdGFuZ2VudHMxIDogdGFuZ2VudHMyXG4gICAgdmFyIG9sZFRhbmdlbnRzID0gZmluZFRhbmdlbnRPZkIgPyB0YW5nZW50czIuc2xpY2UoMCkgOiB0YW5nZW50czEuc2xpY2UoMClcbiAgICB2YXIgcG9seWdvbiA9IGZpbmRUYW5nZW50T2ZCID8gYiA6IGFcbiAgICB2YXIgbWF0Y2hlcyA9IDBcbiAgICB2YXIgb2xkVGFuZ2VudFBhaXJzID0gdGFuZ2VudFBhaXJzLnNsaWNlKDApXG4gICAgdGFuZ2VudFBhaXJzID0gW11cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3JjVGFuZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJhd1RhbmdlbnRzID0gW11cbiAgICAgIHZhciBwb2ludCA9IG5ldyBQb2ludChzcmNUYW5nZXRzW2ldKTtcbiAgICAgIHZhciByYXdUYW5nZW50cyA9IGdldFBvbHlnb25UYW5nZW50cyhwb2ludCwgcG9seWdvbilcbiAgICAgIC8vIHRhbmdlbnRzID0gW11cblxuICAgICAgLy8gZm9yICh2YXIgaiA9IDA7IGogPCBmZWF0dXJlcy5sZW5ndGg7IGorKylcbiAgICAgIC8vICAgcmF3VGFuZ2VudHMucHVzaChmZWF0dXJlc1tqXSlcblxuICAgICAgdmFyIHNyY1BvaW50ID0gbmV3IFBvaW50KHNyY1RhbmdldHNbaV0pXG4gICAgICB2YXIgcDEgPSByYXdUYW5nZW50c1swXVxuICAgICAgdmFyIHAyID0gcmF3VGFuZ2VudHNbMV1cbiAgICAgIHZhciBhbmdsZTEgPSBzcmNQb2ludC5hbmdsZVRvUG9pbnQocDEpXG4gICAgICB2YXIgYW5nbGUyID0gc3JjUG9pbnQuYW5nbGVUb1BvaW50KHAyKVxuICAgICAgdmFyIGRpZmYgPSBhbmdsZTEgLSBhbmdsZTJcbiAgICAgIGRpZmYgPSBkaWZmIDwgMCA/IGRpZmYgKyBNYXRoLlBJKjIgOiBkaWZmXG5cbiAgICAgIHZhciByaWdodFRhbmdlbnQgPSByYXdUYW5nZW50c1sxXVxuICAgICAgdmFyIGxlZnRUYW5nZW50ID0gcmF3VGFuZ2VudHNbMF1cblxuICAgICAgaWYoZGlmZiA+IE1hdGguUEkpe1xuICAgICAgICByaWdodFRhbmdlbnQgPSByYXdUYW5nZW50c1swXVxuICAgICAgICBsZWZ0VGFuZ2VudCA9IHJhd1RhbmdlbnRzWzFdXG4gICAgICB9XG5cblxuICAgICAgaWYoc3JjVGFuZ2V0cy5sZW5ndGggPD0gMil7XG4gICAgICAgIHRhbmdlbnRzLnB1c2goW2xlZnRUYW5nZW50LngsIGxlZnRUYW5nZW50LnldKVxuICAgICAgICB0YW5nZW50cy5wdXNoKFtyaWdodFRhbmdlbnQueCwgcmlnaHRUYW5nZW50LnldKVxuICAgICAgfWVsc2V7XG4gICAgICAgIGlmKHR5cGVvZiBvbGRUYW5nZW50UGFpcnNbaV0gPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgdmFyIG9sZFNvdXJjZSA9IG5ldyBQb2ludChbb2xkVGFuZ2VudFBhaXJzW2ldWzFdWzBdLCBvbGRUYW5nZW50UGFpcnNbaV1bMV1bMV1dKVxuICAgICAgICB2YXIgZGlzdDEgPSBjYWxjRWRnZURpc3RhbmNlKHAxLCBvbGRTb3VyY2UpXG4gICAgICAgIHZhciBkaXN0MiA9IGNhbGNFZGdlRGlzdGFuY2UocDIsIG9sZFNvdXJjZSlcblxuICAgICAgICAvLyB2YXIgYW5nbGUgPSBzcmNQb2ludC5hbmdsZVRvUG9pbnQob2xkU291cmNlKVxuICAgICAgICAvLyB2YXIgZGlmZjEgPSBhbmdsZTEgLSBhbmdsZVxuICAgICAgICAvLyB2YXIgZGlmZjIgPSBhbmdsZTIgLSBhbmdsZVxuICAgICAgICAvLyBkaWZmMSA9IGRpZmYxIDwgMCA/IGRpZmYxICsgTWF0aC5QSSoyIDogZGlmZjFcbiAgICAgICAgLy8gZGlmZjIgPSBkaWZmMiA8IDAgPyBkaWZmMiArIE1hdGguUEkqMiA6IGRpZmYyXG5cbiAgICAgICAgdGFuZ2VudHMucHVzaChkaXN0MSA8IGRpc3QyID8gW3Jhd1RhbmdlbnRzWzBdLngsIHJhd1RhbmdlbnRzWzBdLnldIDogW3Jhd1RhbmdlbnRzWzFdLngsIHJhd1RhbmdlbnRzWzFdLnldKVxuICAgICAgICAvLyBpZihpID09IDApXG4gICAgICAgIC8vICAgdGFuZ2VudHMucHVzaChmaW5kVGFuZ2VudE9mQiA/IGxlZnRUYW5nZW50IDogbGVmdFRhbmdlbnQpXG4gICAgICAgIC8vIGVsc2UgaWYoaSA9PSAxKVxuICAgICAgICAvLyAgIHRhbmdlbnRzLnB1c2goZmluZFRhbmdlbnRPZkIgPyBsZWZ0VGFuZ2VudCA6IHJpZ2h0VGFuZ2VudClcbiAgICAgICAgLy8gZWxzZSBpZihpID09IDIpXG4gICAgICAgIC8vICAgdGFuZ2VudHMucHVzaChmaW5kVGFuZ2VudE9mQiA/IHJpZ2h0VGFuZ2VudCA6IGxlZnRUYW5nZW50KVxuICAgICAgICAvLyBlbHNlIGlmKGkgPT0gMylcbiAgICAgICAgLy8gICB0YW5nZW50cy5wdXNoKGZpbmRUYW5nZW50T2ZCID8gcmlnaHRUYW5nZW50IDogcmlnaHRUYW5nZW50KVxuICAgICAgfVxuXG5cbiAgICAgIC8vIGlmKHNyY1RhbmdldHMubGVuZ3RoIDw9IDIpe1xuICAgICAgLy8gICB0YW5nZW50cy5wdXNoKGxlZnRUYW5nZW50KVxuICAgICAgLy8gICB0YW5nZW50cy5wdXNoKHJpZ2h0VGFuZ2VudClcbiAgICAgIC8vIH1lbHNle1xuICAgICAgLy8gICBpZihpID09IDApXG4gICAgICAvLyAgICAgdGFuZ2VudHMucHVzaChmaW5kVGFuZ2VudE9mQiA/IGxlZnRUYW5nZW50IDogbGVmdFRhbmdlbnQpXG4gICAgICAvLyAgIGVsc2UgaWYoaSA9PSAxKVxuICAgICAgLy8gICAgIHRhbmdlbnRzLnB1c2goZmluZFRhbmdlbnRPZkIgPyBsZWZ0VGFuZ2VudCA6IHJpZ2h0VGFuZ2VudClcbiAgICAgIC8vICAgZWxzZSBpZihpID09IDIpXG4gICAgICAvLyAgICAgdGFuZ2VudHMucHVzaChmaW5kVGFuZ2VudE9mQiA/IHJpZ2h0VGFuZ2VudCA6IGxlZnRUYW5nZW50KVxuICAgICAgLy8gICBlbHNlIGlmKGkgPT0gMylcbiAgICAgIC8vICAgICB0YW5nZW50cy5wdXNoKGZpbmRUYW5nZW50T2ZCID8gcmlnaHRUYW5nZW50IDogcmlnaHRUYW5nZW50KVxuICAgICAgLy8gfVxuXG5cbiAgICAgICAgZm9yICh2YXIgbSA9IDA7IG0gPCB0YW5nZW50cy5sZW5ndGg7IG0rKykge1xuICAgICAgICAvLyBmb3IgKHZhciBrID0gb2xkVGFuZ2VudHMubGVuZ3RoIC0gMTsgayA+PSAwOyBrLS0pIHtcbiAgICAgICAgICB2YXIgdGFuZ2VudCA9IHRhbmdlbnRzW21dXG4gICAgICAgICAgaWYoc3JjVGFuZ2V0cy5sZW5ndGggPiAyKVxuICAgICAgICAgICAgdGFuZ2VudCA9IHRhbmdlbnRzW2ldXG4gICAgICAgICAgLy8gaWYodGFuZ2VudFswXSA9PSBvbGRUYW5nZW50c1trXVswXSAmJiB0YW5nZW50WzFdID09IG9sZFRhbmdlbnRzW2tdWzFdKXtcbiAgICAgICAgICAgIC8vIGlmKG1hdGNoZXMgPCA0KXtcbiAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGR1cGxpY2F0ZXNcbiAgICAgICAgICAgICAgdmFyIGlzVW5pcXVlID0gdHJ1ZVxuICAgICAgICAgICAgICBmb3IgKHZhciBsID0gdGFuZ2VudFBhaXJzLmxlbmd0aCAtIDE7IGwgPj0gMDsgbC0tKSB7XG4gICAgICAgICAgICAgICAgaWYodGFuZ2VudFBhaXJzW2xdWzBdWzBdID09IHRhbmdlbnRbMF0gJiYgdGFuZ2VudFBhaXJzW2xdWzBdWzFdID09IHRhbmdlbnRbMV0pXG4gICAgICAgICAgICAgICAgICBpc1VuaXF1ZSA9IGZhbHNlXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZihpc1VuaXF1ZSl7XG4gICAgICAgICAgICAgICAgdGFuZ2VudFBhaXJzLnB1c2goW3RhbmdlbnQsIHNyY1RhbmdldHNbaV1dKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG1hdGNoZXMrK1xuXG4gICAgICAgICAgICAgIGlmKHNyY1RhbmdldHMubGVuZ3RoID4gMilcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgIC8vIH1cbiAgICAgICAgLy8gfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYoZmluZFRhbmdlbnRPZkIpe1xuICAgICAgZG9uZTIgPSBtYXRjaGVzID09IDQgPyB0cnVlIDogZmFsc2VcbiAgICAgIHRhbmdlbnRzMiA9IHRhbmdlbnRzLnNsaWNlKDApXG4gICAgfWVsc2V7XG4gICAgICBkb25lMSA9IG1hdGNoZXMgPT0gNCA/IHRydWUgOiBmYWxzZVxuICAgICAgdGFuZ2VudHMxID0gdGFuZ2VudHMuc2xpY2UoMClcbiAgICB9XG5cbiAgICAvLyBpZihpdGVyYXRpb25zUmVtYWluaW5nID09IDcpXG4gICAgLy8gICBicmVha1xuXG4gICAgLy8gaWYobWF0Y2hlcyA8IDQpXG4gICAgLy8gICBpdGVyYXRpb25zUmVtYWluaW5nID0gMTBcblxuICAgIGZpbmRUYW5nZW50T2ZCID0gIWZpbmRUYW5nZW50T2ZCXG4gICAgaXRlcmF0aW9uc1JlbWFpbmluZy0tXG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRhbmdlbnRQYWlycy5sZW5ndGg7IGkrKykge1xuICAgIC8vIHZhciB0cDEgPSB0dXJmLnBvaW50KFt0YW5nZW50UGFpcnNbaV1bMF1bMF0sdGFuZ2VudFBhaXJzW2ldWzBdWzFdXSk7XG4gICAgLy8gdmFyIHRwMiA9IHR1cmYucG9pbnQoW3RhbmdlbnRQYWlyc1tpXVsxXVswXSx0YW5nZW50UGFpcnNbaV1bMV1bMV1dKTtcbiAgICAvLyB2YXIgbmVhcmVzdFN0YXJ0ID0gdHVyZi5uZWFyZXN0UG9pbnQodHAxLCBwb2ludHMpXG4gICAgLy8gdmFyIG5lYXJlc3RFbmQgPSB0dXJmLm5lYXJlc3RQb2ludCh0cDIsIHBvaW50cylcbiAgICBsZXQgcDEgPSBuZXcgUG9pbnQodGFuZ2VudFBhaXJzW2ldWzBdKVxuICAgIGxldCBwMiA9IG5ldyBQb2ludCh0YW5nZW50UGFpcnNbaV1bMV0pXG5cblxuXG4gICAgYWxsVGFuZ2VudHMucHVzaChwMSlcbiAgICBhbGxUYW5nZW50cy5wdXNoKHAyKVxuXG4gICAgaWYoaXNWaXNpYmxlKHAxLHAyKSlcbiAgICAgIG91dHB1dCArPSAnLHtcImZyb21JZFwiOlwiJytjcmVhdGVOb2RlSWQyKHAxKSsnXCIsXCJ0b0lkXCI6XCInK2NyZWF0ZU5vZGVJZDIocDIpKydcIn0nXG4gICAgLy8gaWYoaT09MClcbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiXFx0dmFyIHN0YXJ0ID0gW1wiK2NyZWF0ZU5vZGVJZDIocDEpK1wiXVxcblxcdHZhciBlbmQgPSBbXCIrY3JlYXRlTm9kZUlkMihwMikrXCJdXFxuXFxuXCIpXG4gICAgLy8gZWxzZXtcbiAgICAvLyAgIHZhciBpc1Zpc2libGUgPSB0cnVlXG4gICAgLy8gICB2YXIgYW5nbGUgPSBwMS5hbmdsZVRvUG9pbnQocDIpXG5cbiAgICAvLyAgIGZvciAodmFyIGogPSB0dXJmUG9seWdvbnMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAvLyAgICAgdmFyIHRwbTEgPSB0dXJmLnBvaW50KFt0YW5nZW50UGFpcnNbaV1bMF1bMF0gKiBtdWx0aXBsaWVyLHRhbmdlbnRQYWlyc1tpXVswXVsxXSAqIG11bHRpcGxpZXJdKTtcbiAgICAvLyAgICAgdmFyIHRwbTIgPSB0dXJmLnBvaW50KFt0YW5nZW50UGFpcnNbaV1bMV1bMF0gKiBtdWx0aXBsaWVyLHRhbmdlbnRQYWlyc1tpXVsxXVsxXSAqIG11bHRpcGxpZXJdKTtcbiAgICAvLyAgICAgaWYodHVyZi5ib29sZWFuUG9pbnRJblBvbHlnb24odHBtMiwgdHVyZlBvbHlnb25zW2ldKSlcbiAgICAvLyAgICAgICBjb250aW51ZVxuXG4gICAgLy8gICAgIHZhciBmZWF0dXJlcyA9IHR1cmYucG9seWdvblRhbmdlbnRzKHRwbTEsIHR1cmZQb2x5Z29uc1tqXSkuZmVhdHVyZXNcbiAgICAvLyAgICAgdmFyIHQxID0gbmV3IFBvaW50KFtmZWF0dXJlc1swXS5nZW9tZXRyeS5jb29yZGluYXRlc1swXS9tdWx0aXBsaWVyLCBmZWF0dXJlc1swXS5nZW9tZXRyeS5jb29yZGluYXRlc1sxXS9tdWx0aXBsaWVyXSlcbiAgICAvLyAgICAgdmFyIHQyID0gbmV3IFBvaW50KFtmZWF0dXJlc1sxXS5nZW9tZXRyeS5jb29yZGluYXRlc1swXS9tdWx0aXBsaWVyLCBmZWF0dXJlc1sxXS5nZW9tZXRyeS5jb29yZGluYXRlc1sxXS9tdWx0aXBsaWVyXSlcbiAgICAvLyAgICAgdmFyIGFuZ2xlMSA9IHAxLmFuZ2xlVG9Qb2ludCh0MSlcbiAgICAvLyAgICAgdmFyIGFuZ2xlMiA9IHAxLmFuZ2xlVG9Qb2ludCh0MilcbiAgICAvLyAgICAgdmFyIGRpZmYgPSBhbmdsZTEgLSBhbmdsZTJcbiAgICAvLyAgICAgZGlmZiA9IGRpZmYgPCAwID8gZGlmZiArIE1hdGguUEkgOiBkaWZmXG5cbiAgICAvLyAgICAgLy8gZW5zdXJlIGFuZ2xlMiBpcyB0aGUgbGVmdCBvbmVcbiAgICAvLyAgICAgaWYoZGlmZiA+IE1hdGguUEkvMil7XG4gICAgLy8gICAgICAgdmFyIHRlbXAgPSBhbmdsZTFcbiAgICAvLyAgICAgICBhbmdsZTEgPSBhbmdsZTJcbiAgICAvLyAgICAgICBhbmdsZTIgPSB0ZW1wXG4gICAgLy8gICAgIH1cblxuICAgIC8vICAgICB2YXIgZGlmZjEgPSBhbmdsZTEgLSBhbmdsZVxuICAgIC8vICAgICBkaWZmMSA9IGRpZmYxIDwgMCA/IGRpZmYxICsgTWF0aC5QSSA6IGRpZmYxXG5cbiAgICAvLyAgICAgdmFyIGRpZmYyID0gYW5nbGUgLSBhbmdsZTJcbiAgICAvLyAgICAgZGlmZjIgPSBkaWZmMiA8IDAgPyBkaWZmMiArIE1hdGguUEkgOiBkaWZmMlxuXG4gICAgLy8gICAgIC8vIGFuZ2xlIGlzIGJldHdlZW4gYW5nbGUxIGFuZCBhbmdsZTJcbiAgICAvLyAgICAgaWYoZGlmZjEgPCBNYXRoLlBJLzIgJiYgZGlmZjIgPCBNYXRoLlBJLzIpe1xuICAgIC8vICAgICAgIGNvbnN0IGRpc3QgPSBjYWxjRWRnZURpc3RhbmNlKHAxLCBwMilcbiAgICAvLyAgICAgICBjb25zdCBkaXN0MSA9IGNhbGNFZGdlRGlzdGFuY2UocDEsIHQxKVxuICAgIC8vICAgICAgIGNvbnN0IGRpc3QyID0gY2FsY0VkZ2VEaXN0YW5jZShwMSwgdDIpXG5cbiAgICAvLyAgICAgICAvLyBpZiBib3RoIHRhbmdlbnRzIGFyZSBjbG9zZXJcbiAgICAvLyAgICAgICBpZihkaXN0MTxkaXN0ICYmIGRpc3QyPGRpc3Qpe1xuICAgIC8vICAgICAgICAgaXNWaXNpYmxlID0gZmFsc2VcbiAgICAvLyAgICAgICAgIGJyZWFrO1xuICAgIC8vICAgICAgIH1cbiAgICAvLyAgICAgfVxuICAgIC8vICAgfVxuXG4gICAgLy8gICBpZihpc1Zpc2libGUpXG4gICAgICAgIC8vIG91dHB1dCArPSAnLHtcImZyb21JZFwiOlwiJytjcmVhdGVOb2RlSWQobmVhcmVzdFN0YXJ0KSsnXCIsXCJ0b0lkXCI6XCInK2NyZWF0ZU5vZGVJZChuZWFyZXN0RW5kKSsnXCJ9J1xuICAgIC8vIH1cbiAgfVxuXG5cblxuXG4gIC8vIHZhciBtMSA9IEwubWFya2VyKFt0YW5nZW50UGFpcnNbMF1bMF1bMF0sdGFuZ2VudFBhaXJzWzBdWzBdWzFdLCB7XG4gIC8vICAgZHJhZ2dhYmxlOiB0cnVlLFxuICAvLyAgIGljb246IG5ldyBMLk51bWJlcmVkRGl2SWNvbigpXG4gIC8vIH0pXG5cbiAgLy8gdmFyIG0yID0gTC5tYXJrZXIodGFuZ2VudFBhaXJzWzBdWzFdWzBdLHRhbmdlbnRQYWlyc1swXVsxXVsxXSwge1xuICAvLyAgIGRyYWdnYWJsZTogdHJ1ZSxcbiAgLy8gICBpY29uOiBuZXcgTC5OdW1iZXJlZERpdkljb24oKVxuICAvLyB9KVxuXG5cblxuXG4gIC8vIHJvdXRlTGF5ZXIuc2V0TGF0TG5ncyhbXSlcbiAgLy8gdmFyIG5lYXJlc3RTdGFydCA9IHR1cmYubmVhcmVzdFBvaW50KHQxLCBwb2ludHMpXG4gIC8vIHZhciBuZWFyZXN0RW5kID0gdHVyZi5uZWFyZXN0UG9pbnQodDIsIHBvaW50cylcbiAgLy8gZm91bmRQYXRoID0gcGF0aEZpbmRlci5maW5kKGNyZWF0ZU5vZGVJZChuZWFyZXN0U3RhcnQpLCBjcmVhdGVOb2RlSWQobmVhcmVzdEVuZCkpXG4gIC8vIGRyYXdQYXRoKClcblxuXG5cblxuXG5cblxuICAvLyB2YXIgdGFuZ2VudHMyID0gW1tmZWF0dXJlc1swXS5nZW9tZXRyeS5jb29yZGluYXRlc1swXS9tdWx0aXBsaWVyLCBmZWF0dXJlc1swXS5nZW9tZXRyeS5jb29yZGluYXRlc1sxXS9tdWx0aXBsaWVyXSwgXG4gIC8vICAgICAgICAgICAgICAgICAgIFtmZWF0dXJlc1sxXS5nZW9tZXRyeS5jb29yZGluYXRlc1swXS9tdWx0aXBsaWVyLCBmZWF0dXJlc1sxXS5nZW9tZXRyeS5jb29yZGluYXRlc1sxXS9tdWx0aXBsaWVyXV1cblxuXG5cblxuXG4gIC8vIHZhciBwb2ludCA9IHR1cmYucG9pbnQoW01hdGgucm91bmQodGFuZ2VudHMyWzBdWzBdICogbXVsdGlwbGllciksIE1hdGgucm91bmQodGFuZ2VudHMyWzBdWzFdICogbXVsdGlwbGllcildKTtcbiAgLy8gdmFyIGZlYXR1cmVzID0gdHVyZi5wb2x5Z29uVGFuZ2VudHMocG9pbnQsIHBvbHlnb24xKVxuICAvLyB2YXIgdGFuZ2VudHMxID0gW1tmZWF0dXJlc1swXS5nZW9tZXRyeS5jb29yZGluYXRlc1swXS9tdWx0aXBsaWVyLCBmZWF0dXJlc1swXS5nZW9tZXRyeS5jb29yZGluYXRlc1sxXS9tdWx0aXBsaWVyXSwgXG4gIC8vICAgICAgICAgICAgICAgICAgIFtmZWF0dXJlc1sxXS5nZW9tZXRyeS5jb29yZGluYXRlc1swXS9tdWx0aXBsaWVyLCBmZWF0dXJlc1sxXS5nZW9tZXRyeS5jb29yZGluYXRlc1sxXS9tdWx0aXBsaWVyXV1cblxuXG5cblxuXG5cblxuICAvLyBzdGFydE1hcmtlciA9IEwubWFya2VyKFsgYVswXS54LCBhWzBdLnldLCB7XG4gIC8vICAgZHJhZ2dhYmxlOiB0cnVlLFxuICAvLyAgIGljb246IG5ldyBMLk51bWJlcmVkRGl2SWNvbigpXG4gIC8vIH0pLmFkZFRvKG1hcClcblxuICAvLyB2YXIgdGFuZ2VudCA9IFsgdGFuZ2VudHMuZmVhdHVyZXNbMF0uZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0vbXVsdGlwbGllciwgdGFuZ2VudHMuZmVhdHVyZXNbMF0uZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV0vbXVsdGlwbGllcl1cblxuICAvLyBlbmRNYXJrZXIgPSBMLm1hcmtlcih0YW5nZW50LCB7XG4gIC8vICAgZHJhZ2dhYmxlOiB0cnVlLFxuICAvLyAgIGljb246IG5ldyBMLk51bWJlcmVkRGl2SWNvbigpXG4gIC8vIH0pLmFkZFRvKG1hcClcblxuICAvLyB2YXIgbmVhcmVzdFN0YXJ0ID0gdHVyZi5uZWFyZXN0UG9pbnQoc3RhcnRNYXJrZXIudG9HZW9KU09OKCksIHBvaW50cylcbiAgLy8gdmFyIG5lYXJlc3RFbmQgPSB0dXJmLm5lYXJlc3RQb2ludChlbmRNYXJrZXIudG9HZW9KU09OKCksIHBvaW50cylcbiAgLy8gZm91bmRQYXRoID0gcGF0aEZpbmRlci5maW5kKGNyZWF0ZU5vZGVJZChuZWFyZXN0U3RhcnQpLCBjcmVhdGVOb2RlSWQobmVhcmVzdEVuZCkpXG4gIC8vIGRyYXdQYXRoKClcblxuXG4gIC8vIGNvbnNvbGUubG9nKGFbMF0ueCArIFwiLFwiICsgYVswXS55ICsgXCIgXCIgKyB0YW5nZW50WzBdICsgXCIsXCIgKyB0YW5nZW50WzFdKVxuICAvLyBjb25zb2xlLmxvZygnJylcblxuXG5cblxuXG5cblxuXG5cblxuICAgIC8vIC8vIG4xIC0+IG51bWJlciBvZiBwb2ludHMgaW4gcG9seWdvbiBhIFxuICAgIC8vIC8vIG4yIC0+IG51bWJlciBvZiBwb2ludHMgaW4gcG9seWdvbiBiIFxuICAgIC8vIHZhciBuMSA9IGEubGVuZ3RoLCBuMiA9IGIubGVuZ3RoOyBcbiAgXG4gICAgLy8gLy8gVG8gZmluZCBhIHBvaW50IGluc2lkZSB0aGUgY29udmV4IHBvbHlnb24oY2VudHJvaWQpLCBcbiAgICAvLyAvLyB3ZSBzdW0gdXAgYWxsIHRoZSBjb29yZGluYXRlcyBhbmQgdGhlbiBkaXZpZGUgIGJ5IFxuICAgIC8vIC8vIG4obnVtYmVyIG9mIHBvaW50cykuIEJ1dCB0aGlzIHdvdWxkIGJlIGEgZmxvYXRpbmctcG9pbnQgXG4gICAgLy8gLy8gdmFsdWUuIFNvIHRvIGdldCByaWQgb2YgdGhpcyB3ZSBtdWx0aXBseSBwb2ludHMgXG4gICAgLy8gLy8gaW5pdGlhbGx5IHdpdGggbjEgYW5kIHRoZW4gZmluZCB0aGUgY2VudHJlIGFuZCBcbiAgICAvLyAvLyB0aGVuIGRpdmlkZWQgaXQgYnkgbjEgYWdhaW4uIFxuICAgIC8vIC8vIFNpbWlsYXJseSB3ZSBkbyBkaXZpZGUgYW5kIG11bHRpcGx5IGZvciBuMiAoaS5lLiwgXG4gICAgLy8gLy8gZWxlbWVudHMgb2YgYikgXG4gIFxuICAgIC8vIC8vIG1heGEgYW5kIG1pbmIgYXJlIHVzZWQgdG8gY2hlY2sgaWYgcG9seWdvbiBhIFxuICAgIC8vIC8vIGlzIGxlZnQgb2YgYi4gXG4gICAgLy8gdmFyIG1heGEgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjsgXG4gICAgLy8gZm9yICh2YXIgaT0wOyBpPG4xOyBpKyspIFxuICAgIC8vIHsgXG4gICAgLy8gICAgIG1heGEgPSBNYXRoLm1heChtYXhhLCBhW2ldLngpOyBcbiAgICAvLyAgICAgbWlkLnggICs9IGFbaV0ueDtcbiAgICAvLyAgICAgbWlkLnkgKz0gYVtpXS55OyBcbiAgICAvLyAgICAgYVtpXS54ICo9IG4xOyBcbiAgICAvLyAgICAgYVtpXS55ICo9IG4xOyBcbiAgICAvLyB9IFxuICBcbiAgICAvLyAvLyBzb3J0aW5nIHRoZSBwb2ludHMgaW4gY291bnRlciBjbG9ja3dpc2Ugb3JkZXIgXG4gICAgLy8gLy8gZm9yIHBvbHlnb24gYSBcbiAgICAvLyBjb25zdCBjbG9uZWRBID0gY2xvbmVQb2ludHMoYSlcbiAgICAvLyBzb3J0UG9pbnRzKGFbMF0sIGNsb25lZEEpXG4gICAgLy8gYSA9IGNsb25lZEFcbiAgXG4gICAgLy8gZm9yICh2YXIgaT0wOyBpPG4xOyBpKyspIFxuICAgIC8vIHsgXG4gICAgLy8gICAgIGFbaV0ueCAvPSBuMTsgXG4gICAgLy8gICAgIGFbaV0ueSAvPSBuMTsgXG4gICAgLy8gfSBcbiAgXG4gICAgLy8gbWlkID0gbmV3IFBvaW50KFswLDBdKVxuICBcbiAgICAvLyB2YXIgbWluYiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSOyBcbiAgICAvLyBmb3IgKHZhciBpPTA7IGk8bjI7IGkrKykgXG4gICAgLy8geyBcbiAgICAvLyAgICAgbWlkLnggKz0gYltpXS54OyBcbiAgICAvLyAgICAgbWlkLnkgKz0gYltpXS55OyBcbiAgICAvLyAgICAgbWluYiA9IE1hdGgubWluKG1pbmIsIGJbaV0ueCk7IFxuICAgIC8vICAgICBiW2ldLnggKj0gbjI7IFxuICAgIC8vICAgICBiW2ldLnkgKj0gbjI7IFxuICAgIC8vIH0gXG4gIFxuICAgIC8vIC8vIHNvcnRpbmcgdGhlIHBvaW50cyBpbiBjb3VudGVyIGNsb2Nrd2lzZSBcbiAgICAvLyAvLyBvcmRlciBmb3IgcG9seWdvbiBiIFxuICAgIC8vIGNvbnN0IGNsb25lZEIgPSBjbG9uZVBvaW50cyhiKVxuICAgIC8vIHNvcnRQb2ludHMoYlswXSwgY2xvbmVkQilcbiAgICAvLyBiID0gY2xvbmVkQlxuICBcbiAgICAvLyBmb3IgKHZhciBpPTA7IGk8bjI7IGkrKykgXG4gICAgLy8geyBcbiAgICAvLyAgICAgYltpXS54Lz1uMjsgXG4gICAgLy8gICAgIGJbaV0ueS89bjI7IFxuICAgIC8vIH0gXG4gIFxuICAgIC8vIC8vIElmIGEgaXMgdG8gdGhlIHJpZ2h0IG9mIGIsIHN3YXAgYSBhbmQgYiBcbiAgICAvLyAvLyBUaGlzIG1ha2VzIHN1cmUgYSBpcyBsZWZ0IG9mIGIuIFxuICAgIC8vIGlmIChtaW5iIDwgbWF4YSkgXG4gICAgLy8geyBcbiAgICAvLyAgICAgYiA9IFthLCBhID0gYl1bMF07ICAvLyBzd2FwIGEgYW5kIGIgICAgXG4gICAgLy8gICAgIG4xID0gYS5sZW5ndGg7XG4gICAgLy8gICAgIG4yID0gYi5sZW5ndGg7XG4gICAgLy8gfSBcbiAgXG4gICAgLy8gLy8gaWEgLT4gcmlnaHRtb3N0IHBvaW50IG9mIGEgXG4gICAgLy8gdmFyIGlhID0gMCwgaWIgPSAwOyBcbiAgICAvLyBmb3IgKHZhciBpPTE7IGk8bjE7IGkrKykgXG4gICAgLy8gICAgIGlmIChhW2ldLnggPiBhW2lhXS54KSBcbiAgICAvLyAgICAgICAgIGlhID0gaTsgXG4gIFxuICAgIC8vIC8vIGliIC0+IGxlZnRtb3N0IHBvaW50IG9mIGIgXG4gICAgLy8gZm9yICh2YXIgaT0xOyBpPG4yOyBpKyspIFxuICAgIC8vICAgICBpZiAoYltpXS54IDwgYltpYl0ueCkgXG4gICAgLy8gICAgICAgICBpYj1pOyBcbiAgXG4gICAgLy8gLy8gZmluZGluZyB0aGUgdXBwZXIgdGFuZ2VudCBcbiAgICAvLyB2YXIgaW5kYSA9IGlhLCBpbmRiID0gaWI7IFxuICAgIC8vIHZhciBkb25lID0gMDsgXG4gICAgLy8gd2hpbGUgKCFkb25lKSBcbiAgICAvLyB7IFxuICAgIC8vICAgICBkb25lID0gMTsgXG4gICAgLy8gICAgIC8vIGNvbnN0IGcgPSBjcmVhdGVHcmFwaCgpXG4gICAgLy8gICAgIC8vIGcuYWRkTm9kZShjcmVhdGVOb2RlSWQyKGJbaW5kYl0pLCB7IHg6IGJbaW5kYl0ueCwgeTogYltpbmRiXS55IH0pXG4gICAgLy8gICAgIC8vIGcuYWRkTm9kZShjcmVhdGVOb2RlSWQyKGFbaW5kYV0pLCB7IHg6IGFbaW5kYV0ueCwgeTogYVtpbmRhXS55IH0pXG4gICAgLy8gICAgIC8vIGcuYWRkTm9kZShjcmVhdGVOb2RlSWQyKGFbKGluZGErMSklbjFdKSwgeyB4OiBhWyhpbmRhKzEpJW4xXS54LCB5OiBhWyhpbmRhKzEpJW4xXS55IH0pXG4gICAgLy8gICAgIC8vIGcuYWRkTGluayhjcmVhdGVOb2RlSWQyKGJbaW5kYl0pLCBjcmVhdGVOb2RlSWQyKGFbaW5kYV0pKVxuICAgIC8vICAgICAvLyBnLmFkZExpbmsoY3JlYXRlTm9kZUlkMihhW2luZGFdKSwgY3JlYXRlTm9kZUlkMihhWyhpbmRhKzEpJW4xXSkpXG4gICAgLy8gICAgIC8vIHNldEdyYXBoKGcpXG4gICAgLy8gICAgIC8vIHJvdXRlTGF5ZXIuc2V0TGF0TG5ncyhbYltpbmRiXSwgYVtpbmRhXV0pXG4gICAgLy8gICAgIC8vIGRyYXdQYXRoKClcblxuICAgIC8vICAgICAvLyByb3V0ZUxheWVyLnNldExhdExuZ3MoW10pXG5cblxuICAgIC8vICAgICB3aGlsZSAob3JpZW50YXRpb24oYltpbmRiXSwgYVtpbmRhXSwgYVsoaW5kYSsxKSVuMV0pID4gMCkgXG4gICAgLy8gICAgICAgICBpbmRhID0gKGluZGEgKyAxKSAlIG4xOyBcbiAgXG4gICAgLy8gICAgIHdoaWxlIChvcmllbnRhdGlvbihhW2luZGFdLCBiW2luZGJdLCBiWyhuMitpbmRiLTEpJW4yXSkgPCAwKSBcbiAgICAvLyAgICAgeyBcbiAgICAvLyAgICAgICAgIGluZGIgPSAobjIraW5kYi0xKSVuMjsgXG4gICAgLy8gICAgICAgICBkb25lID0gMDsgXG4gICAgLy8gICAgIH0gXG4gICAgLy8gfSBcbiAgICAvLyBjb25zb2xlLmxvZyhhW2luZGFdLnggKyBcIixcIiArIGFbaW5kYV0ueSlcbiAgXG4gICAgLy8gLy8gY291dCA8PCBcInVwcGVyIHRhbmdlbnQgKFwiIDw8IGFbaW5kYV0ueCA8PCBcIixcIlxuICAgIC8vIC8vICAgICA8PCBhW2luZGFdLnkgPDwgXCIpIChcIiA8PCBiW2luZGJdLnggXG4gICAgLy8gLy8gICAgIDw8IFwiLFwiIDw8IGJbaW5kYl0ueSA8PCBcIilcXG5cIjsgXG59IFxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVJZDIgKHApIHtcbiAgICByZXR1cm4gcC54ICsgJywnICsgcC55XG4gIH1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyR3JhcGhSZWxhdGVkRGF0YSAoKSB7XG4gIGlmIChyb3V0ZUxheWVyICE9PSBudWxsKSByb3V0ZUxheWVyLnNldExhdExuZ3MoW10pXG4gIGlmIChzZWxlY3Rpb25MYXllciAhPT0gbnVsbCkgc2VsZWN0aW9uTGF5ZXIuY2xlYXJMYXllcnMoKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0dXBSb3V0ZUxheWVyICgpIHtcbiAgcm91dGVMYXllciA9IEwucG9seWxpbmUoW10sIHtcbiAgICBjb2xvcjogJyNFQjMyMjMnXG4gIH0pLmFkZFRvKG1hcClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldFBhdGhGaW5kZXIgKHBhdGhHcmFwaCkge1xuICBwYXRoRmluZGVyID0gcGF0aEdyYXBoXG4gIHJldHVybiB1cGRhdGVQYXRoTWFya2VycygpXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVBhdGhNYXJrZXJzICgpIHtcbiAgaWYodXBkYXRpbmdQYXRoTWFya2Vycyl7XG4gICAgdXBkYXRpbmdQYXRoTWFya2VycyA9IDBcbiAgICByZXR1cm5cbiAgfVxuXG4gIHVwZGF0aW5nUGF0aE1hcmtlcnMgPSB0cnVlXG4gIGNvbnN0IHN0YXJ0Q3JlYXRpb24gPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KClcblxuICBpZihyb3V0ZUxheWVyICE9IG51bGwpXG4gICAgcm91dGVMYXllci5zZXRMYXRMbmdzKFtdKVxuICByZXN0b3JlT3JpZ2luYWxQb2ludHNBbmRFZGdlcygpXG5cbiAgaWYocm91dGVMYXllciAhPSBudWxsKXtcbiAgICBzdGFydFBvaW50ID0gbmV3IFBvaW50KFtzdGFydE1hcmtlci50b0dlb0pTT04oKS5nZW9tZXRyeS5jb29yZGluYXRlc1swXSwgc3RhcnRNYXJrZXIudG9HZW9KU09OKCkuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV1dKTtcbiAgICBlbmRQb2ludCA9IG5ldyBQb2ludChbZW5kTWFya2VyLnRvR2VvSlNPTigpLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdLCBlbmRNYXJrZXIudG9HZW9KU09OKCkuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV1dKTtcbiAgfVxuXG4gIHZhciBkeW5hbWljTm9kZXNKU09OID0gZ2V0RHluYW1pY05vZGVzSlNPTihzdGFydFBvaW50LCBlbmRQb2ludClcbiAgdmFyIGR5bmFtaWNFZGdlc0pTT04gPSBnZXREeW5hbWljRWRnZXNKU09OKHN0YXJ0UG9pbnQsIGVuZFBvaW50KVxuICB1cGRhdGVHcmFwaFdpdGhEeW5hbWljSlNPTihkeW5hbWljTm9kZXNKU09OLCBkeW5hbWljRWRnZXNKU09OKVxuXG4gIGlmKHJvdXRlTGF5ZXIgIT0gbnVsbCl7XG4gICAgdmFyIG5lYXJlc3RTdGFydCA9IHR1cmYubmVhcmVzdFBvaW50KHN0YXJ0TWFya2VyLnRvR2VvSlNPTigpLCBwb2ludHMpXG4gICAgdmFyIG5lYXJlc3RFbmQgPSB0dXJmLm5lYXJlc3RQb2ludChlbmRNYXJrZXIudG9HZW9KU09OKCksIHBvaW50cylcbiAgICBuZWFyZXN0U3RhcnQgPSBzdGFydE1hcmtlci50b0dlb0pTT04oKVxuICAgIG5lYXJlc3RFbmQgPSBlbmRNYXJrZXIudG9HZW9KU09OKClcbiAgICBmb3VuZFBhdGggPSBwYXRoRmluZGVyLmZpbmQoY3JlYXRlTm9kZUlkKG5lYXJlc3RTdGFydCksIGNyZWF0ZU5vZGVJZChuZWFyZXN0RW5kKSlcbiAgICBkcmF3UGF0aCgpXG4gIH1lbHNle1xuICAgIGZvdW5kUGF0aCA9IHBhdGhGaW5kZXIuZmluZChjcmVhdGVOb2RlSWQyKHN0YXJ0UG9pbnQpLCBjcmVhdGVOb2RlSWQyKGVuZFBvaW50KSlcbiAgfVxuICBjb25zb2xlLmxvZyhcIlxcdHZhciBzdGFydCA9IFtcIitjcmVhdGVOb2RlSWQyKHN0YXJ0UG9pbnQpK1wiXVxcblxcdHZhciBlbmQgPSBbXCIrY3JlYXRlTm9kZUlkMihlbmRQb2ludCkrXCJdXFxuXFxuXCIpXG5cbiAgY29uc3QgZW5kQ3JlYXRpb24gPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KClcbiAgY29uc3QgdGltZVRha2VuVG9DcmVhdGUgPSBwYXJzZUludChlbmRDcmVhdGlvbiAtIHN0YXJ0Q3JlYXRpb24pXG4gIGNvbnNvbGUubG9nKCdUaW1lIHRvIGZpbmQgcGF0aDogJywgdGltZVRha2VuVG9DcmVhdGUpXG5cbiAgdXBkYXRpbmdQYXRoTWFya2VycyA9IGZhbHNlXG5cbiAgcmV0dXJuIGZvdW5kUGF0aFxufVxuXG5mdW5jdGlvbiBkcmF3UGF0aCAoKSB7XG4gIGNvbnN0IHBhdGhMYXRMbmdzID0gZm91bmRQYXRoLm1hcChmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBbbm9kZS5kYXRhLnksIG5vZGUuZGF0YS54XVxuICB9KVxuICByb3V0ZUxheWVyLnNldExhdExuZ3MocGF0aExhdExuZ3MpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVJZCAocCkge1xuICByZXR1cm4gcC5nZW9tZXRyeS5jb29yZGluYXRlc1swXSArICcsJyArIHAuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV1cbn1cblxuZnVuY3Rpb24gdW5oaWdobGlnaHRGZWF0dXJlICgpIHtcbiAgc2VsZWN0aW9uTGF5ZXIuY2xlYXJMYXllcnMoKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0R3JhcGggKGdkKSB7XG4gIGdyYXBoRGF0YSA9IGdkXG59XG5cbmZ1bmN0aW9uIGhpZ2hsaWdodEZlYXR1cmUgKGUpIHtcbiAgc2VsZWN0aW9uTGF5ZXIuY2xlYXJMYXllcnMoKVxuXG4gIGNvbnN0IG5vZGUgPSBncmFwaERhdGEuZ2V0Tm9kZShlLnRhcmdldC5fbGF0bG5nLmxuZyArICcsJyArIGUudGFyZ2V0Ll9sYXRsbmcubGF0KVxuXG4gIGdyYXBoRGF0YS5mb3JFYWNoTGlua2VkTm9kZShlLnRhcmdldC5fbGF0bG5nLmxuZyArICcsJyArIGUudGFyZ2V0Ll9sYXRsbmcubGF0LCBmdW5jdGlvbiAobGlua2VkTm9kZSwgbGluaykge1xuICAgIEwucG9seWxpbmUoW1tsaW5rZWROb2RlLmRhdGEueSwgbGlua2VkTm9kZS5kYXRhLnhdLCBbbm9kZS5kYXRhLnksIG5vZGUuZGF0YS54XV0sIHtcbiAgICAgIHdlaWdodDogMC41LFxuICAgICAgb3BhY2l0eTogMC44LFxuICAgICAgcGFuZTogJ3NoYWRvd1BhbmUnLFxuICAgICAgaW50ZXJhY3RpdmU6IGZhbHNlXG4gICAgfSkuYWRkVG8oc2VsZWN0aW9uTGF5ZXIpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU51bWJlckRpdiAoKSB7XG4gIHJldHVybiBMLkljb24uZXh0ZW5kKHtcbiAgICBvcHRpb25zOiB7XG4gICAgICBpY29uU2l6ZTogbmV3IEwuUG9pbnQoMTUsIDE1KSxcbiAgICAgIGNsYXNzTmFtZTogJ2xlYWZsZXQtZGl2LWljb24nXG4gICAgfSxcbiAgICBjcmVhdGVJY29uOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgIHZhciBudW1kaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgbnVtZGl2LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnbnVtYmVyJylcbiAgICAgIG51bWRpdi5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnNbJ251bWJlciddIHx8ICcnXG4gICAgICBkaXYuYXBwZW5kQ2hpbGQobnVtZGl2KVxuICAgICAgdGhpcy5fc2V0SWNvblN0eWxlcyhkaXYsICdpY29uJylcbiAgICAgIHJldHVybiBkaXZcbiAgICB9XG4gIH0pXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/mapHelpers.js\n");

/***/ }),

/***/ "./src/setupStructure.js":
/*!*******************************!*\
  !*** ./src/setupStructure.js ***!
  \*******************************/
/*! exports provided: setupStructure */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setupStructure\", function() { return setupStructure; });\n/* harmony import */ var _Point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Point */ \"./src/Point.js\");\n/* harmony import */ var _Edge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Edge */ \"./src/Edge.js\");\n\n\n\nfunction setupStructure (coords, edges, points, polygons, polygonId) {\n  // const geom = geojson.type === 'Feature' ? geojson.geometry : geojson\n\n  // let coords = geom.coordinates\n\n  // // standardise the input\n  // if (geom.type === 'Polygon') coords = [coords]\n\n  coords = [coords]\n\n  for (let i = 0; i < coords.length; i++) {\n    const contour = []\n    polygons.push(contour)\n\n    if(coords[i] == undefined)\n      continue\n\n    for (let ii = 0; ii < coords[i].geometry.coordinates.length; ii++) {\n      let prevPoint = new _Point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"](coords[i].geometry.coordinates[ii][0], polygonId)\n      let currentPoint = new _Point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"](coords[i].geometry.coordinates[ii][1], polygonId)\n      prevPoint.nextPoint = currentPoint\n      let nextPoint = new _Point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"](coords[i].geometry.coordinates[ii][2], polygonId)\n      linkPoints(prevPoint, currentPoint, nextPoint)\n\n      points.push(prevPoint)\n\n      let prevEdge = new _Edge__WEBPACK_IMPORTED_MODULE_1__[\"Edge\"](prevPoint, currentPoint) // eslint-disable-line\n      edges.push(prevEdge)\n      contour.push(prevEdge)\n\n      // Save me for later\n      const firstPoint = prevPoint\n\n      prevPoint = currentPoint\n      currentPoint = nextPoint\n\n      for (let iii = 2; iii < coords[i].geometry.coordinates[ii].length - 2; iii++) {\n        points.push(prevPoint)\n\n        nextPoint = new _Point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"](coords[i].geometry.coordinates[ii][iii + 1], polygonId)\n\n        linkPoints(prevPoint, currentPoint, nextPoint)\n\n        const e = new _Edge__WEBPACK_IMPORTED_MODULE_1__[\"Edge\"](prevPoint, currentPoint) // eslint-disable-line\n\n        edges.push(e)\n        contour.push(e)\n\n        prevPoint = currentPoint\n        currentPoint = nextPoint\n        prevEdge = e\n      }\n\n      linkPoints(prevPoint, currentPoint, firstPoint)\n\n      const secondLastEdge = new _Edge__WEBPACK_IMPORTED_MODULE_1__[\"Edge\"](prevEdge.p2, currentPoint)\n\n      edges.push(secondLastEdge)\n      contour.push(secondLastEdge)\n\n      const lastEdge = new _Edge__WEBPACK_IMPORTED_MODULE_1__[\"Edge\"](currentPoint, firstPoint) // eslint-disable-line\n      linkPoints(currentPoint, firstPoint, firstPoint.nextPoint)\n\n      edges.push(lastEdge)\n      contour.push(lastEdge)\n\n      points.push(prevPoint)\n      points.push(nextPoint)\n    }\n  }\n}\n\n// export function setupStructure (coords, edges, points, polygons, polygonId) {\n//   // const geom = geojson.type === 'Feature' ? geojson.geometry : geojson\n\n//   // let coords = geom.coordinates\n\n//   // // standardise the input\n//   // if (geom.type === 'Polygon') coords = [coords]\n\n//   coords = [coords]\n\n//   for (let i = 0; i < coords.length; i++) {\n//     const contour = []\n//     polygons.push(contour)\n\n//     if(coords[i] == undefined)\n//       continue\n\n//     for (let ii = 0; ii < coords[i].length; ii++) {\n//       let prevPoint = new Point(coords[i][ii][0], polygonId)\n//       let currentPoint = new Point(coords[i][ii][1], polygonId)\n//       prevPoint.nextPoint = currentPoint\n//       let nextPoint = new Point(coords[i][ii][2], polygonId)\n//       linkPoints(prevPoint, currentPoint, nextPoint)\n\n//       points.push(prevPoint)\n\n//       let prevEdge = new Edge(prevPoint, currentPoint) // eslint-disable-line\n//       edges.push(prevEdge)\n//       contour.push(prevEdge)\n\n//       // Save me for later\n//       const firstPoint = prevPoint\n\n//       prevPoint = currentPoint\n//       currentPoint = nextPoint\n\n//       for (let iii = 2; iii < coords[i][ii].length - 2; iii++) {\n//         points.push(prevPoint)\n\n//         nextPoint = new Point(coords[i][ii][iii + 1], polygonId)\n\n//         linkPoints(prevPoint, currentPoint, nextPoint)\n\n//         const e = new Edge(prevPoint, currentPoint) // eslint-disable-line\n\n//         edges.push(e)\n//         contour.push(e)\n\n//         prevPoint = currentPoint\n//         currentPoint = nextPoint\n//         prevEdge = e\n//       }\n\n//       linkPoints(prevPoint, currentPoint, firstPoint)\n\n//       const secondLastEdge = new Edge(prevEdge.p2, currentPoint)\n\n//       edges.push(secondLastEdge)\n//       contour.push(secondLastEdge)\n\n//       const lastEdge = new Edge(currentPoint, firstPoint) // eslint-disable-line\n//       linkPoints(currentPoint, firstPoint, firstPoint.nextPoint)\n\n//       edges.push(lastEdge)\n//       contour.push(lastEdge)\n\n//       points.push(prevPoint)\n//       points.push(nextPoint)\n//     }\n//   }\n// }\n\nfunction linkPoints (prevPoint, currentPoint, nextPoint) {\n  currentPoint.prevPoint = prevPoint\n  currentPoint.nextPoint = nextPoint\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2V0dXBTdHJ1Y3R1cmUuanM/NDFhNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUErQjtBQUNGOztBQUV0QjtBQUNQOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLDRDQUE0QztBQUNoRSwwQkFBMEIsNENBQUs7QUFDL0IsNkJBQTZCLDRDQUFLO0FBQ2xDO0FBQ0EsMEJBQTBCLDRDQUFLO0FBQy9COztBQUVBOztBQUVBLHlCQUF5QiwwQ0FBSTtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIscURBQXFEO0FBQzVFOztBQUVBLHdCQUF3Qiw0Q0FBSzs7QUFFN0I7O0FBRUEsc0JBQXNCLDBDQUFJOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlDQUFpQywwQ0FBSTs7QUFFckM7QUFDQTs7QUFFQSwyQkFBMkIsMENBQUk7QUFDL0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQkFBMEIsZ0NBQWdDO0FBQzFEOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL3NyYy9zZXR1cFN0cnVjdHVyZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi9Qb2ludCdcbmltcG9ydCB7IEVkZ2UgfSBmcm9tICcuL0VkZ2UnXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXR1cFN0cnVjdHVyZSAoY29vcmRzLCBlZGdlcywgcG9pbnRzLCBwb2x5Z29ucywgcG9seWdvbklkKSB7XG4gIC8vIGNvbnN0IGdlb20gPSBnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlJyA/IGdlb2pzb24uZ2VvbWV0cnkgOiBnZW9qc29uXG5cbiAgLy8gbGV0IGNvb3JkcyA9IGdlb20uY29vcmRpbmF0ZXNcblxuICAvLyAvLyBzdGFuZGFyZGlzZSB0aGUgaW5wdXRcbiAgLy8gaWYgKGdlb20udHlwZSA9PT0gJ1BvbHlnb24nKSBjb29yZHMgPSBbY29vcmRzXVxuXG4gIGNvb3JkcyA9IFtjb29yZHNdXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjb250b3VyID0gW11cbiAgICBwb2x5Z29ucy5wdXNoKGNvbnRvdXIpXG5cbiAgICBpZihjb29yZHNbaV0gPT0gdW5kZWZpbmVkKVxuICAgICAgY29udGludWVcblxuICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCBjb29yZHNbaV0uZ2VvbWV0cnkuY29vcmRpbmF0ZXMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICBsZXQgcHJldlBvaW50ID0gbmV3IFBvaW50KGNvb3Jkc1tpXS5nZW9tZXRyeS5jb29yZGluYXRlc1tpaV1bMF0sIHBvbHlnb25JZClcbiAgICAgIGxldCBjdXJyZW50UG9pbnQgPSBuZXcgUG9pbnQoY29vcmRzW2ldLmdlb21ldHJ5LmNvb3JkaW5hdGVzW2lpXVsxXSwgcG9seWdvbklkKVxuICAgICAgcHJldlBvaW50Lm5leHRQb2ludCA9IGN1cnJlbnRQb2ludFxuICAgICAgbGV0IG5leHRQb2ludCA9IG5ldyBQb2ludChjb29yZHNbaV0uZ2VvbWV0cnkuY29vcmRpbmF0ZXNbaWldWzJdLCBwb2x5Z29uSWQpXG4gICAgICBsaW5rUG9pbnRzKHByZXZQb2ludCwgY3VycmVudFBvaW50LCBuZXh0UG9pbnQpXG5cbiAgICAgIHBvaW50cy5wdXNoKHByZXZQb2ludClcblxuICAgICAgbGV0IHByZXZFZGdlID0gbmV3IEVkZ2UocHJldlBvaW50LCBjdXJyZW50UG9pbnQpIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIGVkZ2VzLnB1c2gocHJldkVkZ2UpXG4gICAgICBjb250b3VyLnB1c2gocHJldkVkZ2UpXG5cbiAgICAgIC8vIFNhdmUgbWUgZm9yIGxhdGVyXG4gICAgICBjb25zdCBmaXJzdFBvaW50ID0gcHJldlBvaW50XG5cbiAgICAgIHByZXZQb2ludCA9IGN1cnJlbnRQb2ludFxuICAgICAgY3VycmVudFBvaW50ID0gbmV4dFBvaW50XG5cbiAgICAgIGZvciAobGV0IGlpaSA9IDI7IGlpaSA8IGNvb3Jkc1tpXS5nZW9tZXRyeS5jb29yZGluYXRlc1tpaV0ubGVuZ3RoIC0gMjsgaWlpKyspIHtcbiAgICAgICAgcG9pbnRzLnB1c2gocHJldlBvaW50KVxuXG4gICAgICAgIG5leHRQb2ludCA9IG5ldyBQb2ludChjb29yZHNbaV0uZ2VvbWV0cnkuY29vcmRpbmF0ZXNbaWldW2lpaSArIDFdLCBwb2x5Z29uSWQpXG5cbiAgICAgICAgbGlua1BvaW50cyhwcmV2UG9pbnQsIGN1cnJlbnRQb2ludCwgbmV4dFBvaW50KVxuXG4gICAgICAgIGNvbnN0IGUgPSBuZXcgRWRnZShwcmV2UG9pbnQsIGN1cnJlbnRQb2ludCkgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgICAgIGVkZ2VzLnB1c2goZSlcbiAgICAgICAgY29udG91ci5wdXNoKGUpXG5cbiAgICAgICAgcHJldlBvaW50ID0gY3VycmVudFBvaW50XG4gICAgICAgIGN1cnJlbnRQb2ludCA9IG5leHRQb2ludFxuICAgICAgICBwcmV2RWRnZSA9IGVcbiAgICAgIH1cblxuICAgICAgbGlua1BvaW50cyhwcmV2UG9pbnQsIGN1cnJlbnRQb2ludCwgZmlyc3RQb2ludClcblxuICAgICAgY29uc3Qgc2Vjb25kTGFzdEVkZ2UgPSBuZXcgRWRnZShwcmV2RWRnZS5wMiwgY3VycmVudFBvaW50KVxuXG4gICAgICBlZGdlcy5wdXNoKHNlY29uZExhc3RFZGdlKVxuICAgICAgY29udG91ci5wdXNoKHNlY29uZExhc3RFZGdlKVxuXG4gICAgICBjb25zdCBsYXN0RWRnZSA9IG5ldyBFZGdlKGN1cnJlbnRQb2ludCwgZmlyc3RQb2ludCkgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgbGlua1BvaW50cyhjdXJyZW50UG9pbnQsIGZpcnN0UG9pbnQsIGZpcnN0UG9pbnQubmV4dFBvaW50KVxuXG4gICAgICBlZGdlcy5wdXNoKGxhc3RFZGdlKVxuICAgICAgY29udG91ci5wdXNoKGxhc3RFZGdlKVxuXG4gICAgICBwb2ludHMucHVzaChwcmV2UG9pbnQpXG4gICAgICBwb2ludHMucHVzaChuZXh0UG9pbnQpXG4gICAgfVxuICB9XG59XG5cbi8vIGV4cG9ydCBmdW5jdGlvbiBzZXR1cFN0cnVjdHVyZSAoY29vcmRzLCBlZGdlcywgcG9pbnRzLCBwb2x5Z29ucywgcG9seWdvbklkKSB7XG4vLyAgIC8vIGNvbnN0IGdlb20gPSBnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlJyA/IGdlb2pzb24uZ2VvbWV0cnkgOiBnZW9qc29uXG5cbi8vICAgLy8gbGV0IGNvb3JkcyA9IGdlb20uY29vcmRpbmF0ZXNcblxuLy8gICAvLyAvLyBzdGFuZGFyZGlzZSB0aGUgaW5wdXRcbi8vICAgLy8gaWYgKGdlb20udHlwZSA9PT0gJ1BvbHlnb24nKSBjb29yZHMgPSBbY29vcmRzXVxuXG4vLyAgIGNvb3JkcyA9IFtjb29yZHNdXG5cbi8vICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcbi8vICAgICBjb25zdCBjb250b3VyID0gW11cbi8vICAgICBwb2x5Z29ucy5wdXNoKGNvbnRvdXIpXG5cbi8vICAgICBpZihjb29yZHNbaV0gPT0gdW5kZWZpbmVkKVxuLy8gICAgICAgY29udGludWVcblxuLy8gICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCBjb29yZHNbaV0ubGVuZ3RoOyBpaSsrKSB7XG4vLyAgICAgICBsZXQgcHJldlBvaW50ID0gbmV3IFBvaW50KGNvb3Jkc1tpXVtpaV1bMF0sIHBvbHlnb25JZClcbi8vICAgICAgIGxldCBjdXJyZW50UG9pbnQgPSBuZXcgUG9pbnQoY29vcmRzW2ldW2lpXVsxXSwgcG9seWdvbklkKVxuLy8gICAgICAgcHJldlBvaW50Lm5leHRQb2ludCA9IGN1cnJlbnRQb2ludFxuLy8gICAgICAgbGV0IG5leHRQb2ludCA9IG5ldyBQb2ludChjb29yZHNbaV1baWldWzJdLCBwb2x5Z29uSWQpXG4vLyAgICAgICBsaW5rUG9pbnRzKHByZXZQb2ludCwgY3VycmVudFBvaW50LCBuZXh0UG9pbnQpXG5cbi8vICAgICAgIHBvaW50cy5wdXNoKHByZXZQb2ludClcblxuLy8gICAgICAgbGV0IHByZXZFZGdlID0gbmV3IEVkZ2UocHJldlBvaW50LCBjdXJyZW50UG9pbnQpIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbi8vICAgICAgIGVkZ2VzLnB1c2gocHJldkVkZ2UpXG4vLyAgICAgICBjb250b3VyLnB1c2gocHJldkVkZ2UpXG5cbi8vICAgICAgIC8vIFNhdmUgbWUgZm9yIGxhdGVyXG4vLyAgICAgICBjb25zdCBmaXJzdFBvaW50ID0gcHJldlBvaW50XG5cbi8vICAgICAgIHByZXZQb2ludCA9IGN1cnJlbnRQb2ludFxuLy8gICAgICAgY3VycmVudFBvaW50ID0gbmV4dFBvaW50XG5cbi8vICAgICAgIGZvciAobGV0IGlpaSA9IDI7IGlpaSA8IGNvb3Jkc1tpXVtpaV0ubGVuZ3RoIC0gMjsgaWlpKyspIHtcbi8vICAgICAgICAgcG9pbnRzLnB1c2gocHJldlBvaW50KVxuXG4vLyAgICAgICAgIG5leHRQb2ludCA9IG5ldyBQb2ludChjb29yZHNbaV1baWldW2lpaSArIDFdLCBwb2x5Z29uSWQpXG5cbi8vICAgICAgICAgbGlua1BvaW50cyhwcmV2UG9pbnQsIGN1cnJlbnRQb2ludCwgbmV4dFBvaW50KVxuXG4vLyAgICAgICAgIGNvbnN0IGUgPSBuZXcgRWRnZShwcmV2UG9pbnQsIGN1cnJlbnRQb2ludCkgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4vLyAgICAgICAgIGVkZ2VzLnB1c2goZSlcbi8vICAgICAgICAgY29udG91ci5wdXNoKGUpXG5cbi8vICAgICAgICAgcHJldlBvaW50ID0gY3VycmVudFBvaW50XG4vLyAgICAgICAgIGN1cnJlbnRQb2ludCA9IG5leHRQb2ludFxuLy8gICAgICAgICBwcmV2RWRnZSA9IGVcbi8vICAgICAgIH1cblxuLy8gICAgICAgbGlua1BvaW50cyhwcmV2UG9pbnQsIGN1cnJlbnRQb2ludCwgZmlyc3RQb2ludClcblxuLy8gICAgICAgY29uc3Qgc2Vjb25kTGFzdEVkZ2UgPSBuZXcgRWRnZShwcmV2RWRnZS5wMiwgY3VycmVudFBvaW50KVxuXG4vLyAgICAgICBlZGdlcy5wdXNoKHNlY29uZExhc3RFZGdlKVxuLy8gICAgICAgY29udG91ci5wdXNoKHNlY29uZExhc3RFZGdlKVxuXG4vLyAgICAgICBjb25zdCBsYXN0RWRnZSA9IG5ldyBFZGdlKGN1cnJlbnRQb2ludCwgZmlyc3RQb2ludCkgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuLy8gICAgICAgbGlua1BvaW50cyhjdXJyZW50UG9pbnQsIGZpcnN0UG9pbnQsIGZpcnN0UG9pbnQubmV4dFBvaW50KVxuXG4vLyAgICAgICBlZGdlcy5wdXNoKGxhc3RFZGdlKVxuLy8gICAgICAgY29udG91ci5wdXNoKGxhc3RFZGdlKVxuXG4vLyAgICAgICBwb2ludHMucHVzaChwcmV2UG9pbnQpXG4vLyAgICAgICBwb2ludHMucHVzaChuZXh0UG9pbnQpXG4vLyAgICAgfVxuLy8gICB9XG4vLyB9XG5cbmZ1bmN0aW9uIGxpbmtQb2ludHMgKHByZXZQb2ludCwgY3VycmVudFBvaW50LCBuZXh0UG9pbnQpIHtcbiAgY3VycmVudFBvaW50LnByZXZQb2ludCA9IHByZXZQb2ludFxuICBjdXJyZW50UG9pbnQubmV4dFBvaW50ID0gbmV4dFBvaW50XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/setupStructure.js\n");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/*! exports provided: pi1, pi2, INF, edgeIntersect, ccw, onSegment, angle2, pointEdgeDistance, intersectPoint, calcEdgeDistance */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pi1\", function() { return pi1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pi2\", function() { return pi2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"INF\", function() { return INF; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"edgeIntersect\", function() { return edgeIntersect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ccw\", function() { return ccw; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"onSegment\", function() { return onSegment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"angle2\", function() { return angle2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pointEdgeDistance\", function() { return pointEdgeDistance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"intersectPoint\", function() { return intersectPoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"calcEdgeDistance\", function() { return calcEdgeDistance; });\n/* harmony import */ var _Point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Point */ \"./src/Point.js\");\n\n\nconst pi1 = Math.PI * 3 / 2\nconst pi2 = Math.PI / 2\n\nconst INF = 10000\nconst COLIN_TOLERANCE = 13\nconst T = Math.pow(10, COLIN_TOLERANCE)\nconst T2 = Math.pow(10.0, COLIN_TOLERANCE)\n\nfunction edgeIntersect (p1, q1, edge) {\n  const p2 = edge.p1\n  const q2 = edge.p2\n  const o1 = ccw(p1, q1, p2)\n  const o2 = ccw(p1, q1, q2)\n  const o3 = ccw(p2, q2, p1)\n  const o4 = ccw(p2, q2, q1)\n  if (o1 !== o2 && o3 !== o4) return true\n  if (o1 === 0 && onSegment(p1, p2, q1)) return true\n  if (o2 === 0 && onSegment(p1, q2, q1)) return true\n  if (o3 === 0 && onSegment(p2, p1, q2)) return true\n  if (o4 === 0 && onSegment(p2, q1, q2)) return true\n  return false\n}\n\nfunction ccw (a, b, c) {\n  const area = Math.round(((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) * T) / T2\n  if (area > 0) return 1\n  if (area < 0) return -1\n  return 0\n}\n\nfunction onSegment (p, q, r) {\n  if (q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x)) {\n    if (q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y)) return true\n  }\n  return false\n}\n\nfunction angle2 (p1, p2, p3) {\n  const a = Math.pow((p3.x - p2.x), 2) + Math.pow((p3.y - p2.y), 2)\n  const b = Math.pow((p3.x - p1.x), 2) + Math.pow((p3.y - p1.y), 2)\n  const c = Math.pow((p2.x - p1.x), 2) + Math.pow((p2.y - p1.y), 2)\n  return Math.acos((a + c - b) / (2 * Math.sqrt(a) * Math.sqrt(c)))\n}\n\nfunction pointEdgeDistance (p1, p2, edge) {\n  const ip = intersectPoint(p1, p2, edge)\n  return ip !== null ? calcEdgeDistance(p1, ip) : 0\n}\n\nfunction intersectPoint (p1, p2, edge) {\n  if (edge.containsPoint(p1)) return p1\n  if (edge.containsPoint(p2)) return p2\n  if (edge.p1.x === edge.p2.x) {\n    if (p1.x === p2.x) return null\n    const pslope = (p1.y - p2.y) / (p1.x - p2.x)\n    const intersectX = edge.p1.x\n    const intersectY = pslope * (intersectX - p1.x) + p1.y\n    return new _Point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"]([intersectX, intersectY], null)\n  }\n  if (p1.x === p2.x) {\n    const eslope = (edge.p1.y - edge.p2.y) / (edge.p1.x - edge.p2.x)\n    const intersectX = p1.x\n    const intersectY = eslope * (intersectX - edge.p1.x) + edge.p1.y\n    return new _Point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"]([intersectX, intersectY], null)\n  }\n\n  const pslope = (p1.y - p2.y) / (p1.x - p2.x)\n  const eslope = (edge.p1.y - edge.p2.y) / (edge.p1.x - edge.p2.x)\n\n  if (pslope === eslope) return null\n  const intersectX = (eslope * edge.p1.x - pslope * p1.x + p1.y - edge.p1.y) / (eslope - pslope)\n  const intersectY = eslope * (intersectX - edge.p1.x) + edge.p1.y\n  return new _Point__WEBPACK_IMPORTED_MODULE_0__[\"Point\"]([intersectX, intersectY], null)\n}\n\nfunction calcEdgeDistance (p1, p2) {\n  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2))\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMuanM/MDI1ZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBK0I7O0FBRXhCO0FBQ0E7O0FBRUE7QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0Q0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0Q0FBSztBQUNwQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNENBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBIiwiZmlsZSI6Ii4vc3JjL3V0aWxzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuL1BvaW50J1xuXG5leHBvcnQgY29uc3QgcGkxID0gTWF0aC5QSSAqIDMgLyAyXG5leHBvcnQgY29uc3QgcGkyID0gTWF0aC5QSSAvIDJcblxuZXhwb3J0IGNvbnN0IElORiA9IDEwMDAwXG5jb25zdCBDT0xJTl9UT0xFUkFOQ0UgPSAxM1xuY29uc3QgVCA9IE1hdGgucG93KDEwLCBDT0xJTl9UT0xFUkFOQ0UpXG5jb25zdCBUMiA9IE1hdGgucG93KDEwLjAsIENPTElOX1RPTEVSQU5DRSlcblxuZXhwb3J0IGZ1bmN0aW9uIGVkZ2VJbnRlcnNlY3QgKHAxLCBxMSwgZWRnZSkge1xuICBjb25zdCBwMiA9IGVkZ2UucDFcbiAgY29uc3QgcTIgPSBlZGdlLnAyXG4gIGNvbnN0IG8xID0gY2N3KHAxLCBxMSwgcDIpXG4gIGNvbnN0IG8yID0gY2N3KHAxLCBxMSwgcTIpXG4gIGNvbnN0IG8zID0gY2N3KHAyLCBxMiwgcDEpXG4gIGNvbnN0IG80ID0gY2N3KHAyLCBxMiwgcTEpXG4gIGlmIChvMSAhPT0gbzIgJiYgbzMgIT09IG80KSByZXR1cm4gdHJ1ZVxuICBpZiAobzEgPT09IDAgJiYgb25TZWdtZW50KHAxLCBwMiwgcTEpKSByZXR1cm4gdHJ1ZVxuICBpZiAobzIgPT09IDAgJiYgb25TZWdtZW50KHAxLCBxMiwgcTEpKSByZXR1cm4gdHJ1ZVxuICBpZiAobzMgPT09IDAgJiYgb25TZWdtZW50KHAyLCBwMSwgcTIpKSByZXR1cm4gdHJ1ZVxuICBpZiAobzQgPT09IDAgJiYgb25TZWdtZW50KHAyLCBxMSwgcTIpKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNjdyAoYSwgYiwgYykge1xuICBjb25zdCBhcmVhID0gTWF0aC5yb3VuZCgoKGIueCAtIGEueCkgKiAoYy55IC0gYS55KSAtIChiLnkgLSBhLnkpICogKGMueCAtIGEueCkpICogVCkgLyBUMlxuICBpZiAoYXJlYSA+IDApIHJldHVybiAxXG4gIGlmIChhcmVhIDwgMCkgcmV0dXJuIC0xXG4gIHJldHVybiAwXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvblNlZ21lbnQgKHAsIHEsIHIpIHtcbiAgaWYgKHEueCA8PSBNYXRoLm1heChwLngsIHIueCkgJiYgcS54ID49IE1hdGgubWluKHAueCwgci54KSkge1xuICAgIGlmIChxLnkgPD0gTWF0aC5tYXgocC55LCByLnkpICYmIHEueSA+PSBNYXRoLm1pbihwLnksIHIueSkpIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhbmdsZTIgKHAxLCBwMiwgcDMpIHtcbiAgY29uc3QgYSA9IE1hdGgucG93KChwMy54IC0gcDIueCksIDIpICsgTWF0aC5wb3coKHAzLnkgLSBwMi55KSwgMilcbiAgY29uc3QgYiA9IE1hdGgucG93KChwMy54IC0gcDEueCksIDIpICsgTWF0aC5wb3coKHAzLnkgLSBwMS55KSwgMilcbiAgY29uc3QgYyA9IE1hdGgucG93KChwMi54IC0gcDEueCksIDIpICsgTWF0aC5wb3coKHAyLnkgLSBwMS55KSwgMilcbiAgcmV0dXJuIE1hdGguYWNvcygoYSArIGMgLSBiKSAvICgyICogTWF0aC5zcXJ0KGEpICogTWF0aC5zcXJ0KGMpKSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvaW50RWRnZURpc3RhbmNlIChwMSwgcDIsIGVkZ2UpIHtcbiAgY29uc3QgaXAgPSBpbnRlcnNlY3RQb2ludChwMSwgcDIsIGVkZ2UpXG4gIHJldHVybiBpcCAhPT0gbnVsbCA/IGNhbGNFZGdlRGlzdGFuY2UocDEsIGlwKSA6IDBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdFBvaW50IChwMSwgcDIsIGVkZ2UpIHtcbiAgaWYgKGVkZ2UuY29udGFpbnNQb2ludChwMSkpIHJldHVybiBwMVxuICBpZiAoZWRnZS5jb250YWluc1BvaW50KHAyKSkgcmV0dXJuIHAyXG4gIGlmIChlZGdlLnAxLnggPT09IGVkZ2UucDIueCkge1xuICAgIGlmIChwMS54ID09PSBwMi54KSByZXR1cm4gbnVsbFxuICAgIGNvbnN0IHBzbG9wZSA9IChwMS55IC0gcDIueSkgLyAocDEueCAtIHAyLngpXG4gICAgY29uc3QgaW50ZXJzZWN0WCA9IGVkZ2UucDEueFxuICAgIGNvbnN0IGludGVyc2VjdFkgPSBwc2xvcGUgKiAoaW50ZXJzZWN0WCAtIHAxLngpICsgcDEueVxuICAgIHJldHVybiBuZXcgUG9pbnQoW2ludGVyc2VjdFgsIGludGVyc2VjdFldLCBudWxsKVxuICB9XG4gIGlmIChwMS54ID09PSBwMi54KSB7XG4gICAgY29uc3QgZXNsb3BlID0gKGVkZ2UucDEueSAtIGVkZ2UucDIueSkgLyAoZWRnZS5wMS54IC0gZWRnZS5wMi54KVxuICAgIGNvbnN0IGludGVyc2VjdFggPSBwMS54XG4gICAgY29uc3QgaW50ZXJzZWN0WSA9IGVzbG9wZSAqIChpbnRlcnNlY3RYIC0gZWRnZS5wMS54KSArIGVkZ2UucDEueVxuICAgIHJldHVybiBuZXcgUG9pbnQoW2ludGVyc2VjdFgsIGludGVyc2VjdFldLCBudWxsKVxuICB9XG5cbiAgY29uc3QgcHNsb3BlID0gKHAxLnkgLSBwMi55KSAvIChwMS54IC0gcDIueClcbiAgY29uc3QgZXNsb3BlID0gKGVkZ2UucDEueSAtIGVkZ2UucDIueSkgLyAoZWRnZS5wMS54IC0gZWRnZS5wMi54KVxuXG4gIGlmIChwc2xvcGUgPT09IGVzbG9wZSkgcmV0dXJuIG51bGxcbiAgY29uc3QgaW50ZXJzZWN0WCA9IChlc2xvcGUgKiBlZGdlLnAxLnggLSBwc2xvcGUgKiBwMS54ICsgcDEueSAtIGVkZ2UucDEueSkgLyAoZXNsb3BlIC0gcHNsb3BlKVxuICBjb25zdCBpbnRlcnNlY3RZID0gZXNsb3BlICogKGludGVyc2VjdFggLSBlZGdlLnAxLngpICsgZWRnZS5wMS55XG4gIHJldHVybiBuZXcgUG9pbnQoW2ludGVyc2VjdFgsIGludGVyc2VjdFldLCBudWxsKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsY0VkZ2VEaXN0YW5jZSAocDEsIHAyKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3cocDIueCAtIHAxLngsIDIpICsgTWF0aC5wb3cocDIueSAtIHAxLnksIDIpKVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/utils.js\n");

/***/ })

/******/ });